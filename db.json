{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/10.jpg","path":"images/10.jpg","modified":0,"renderable":0},{"_id":"source/images/13.png","path":"images/13.png","modified":0,"renderable":0},{"_id":"source/images/6.png","path":"images/6.png","modified":0,"renderable":0},{"_id":"source/images/8.jpg","path":"images/8.jpg","modified":0,"renderable":0},{"_id":"source/images/1.jpg","path":"images/1.jpg","modified":0,"renderable":0},{"_id":"source/images/11.jpg","path":"images/11.jpg","modified":0,"renderable":0},{"_id":"source/images/3.jpg","path":"images/3.jpg","modified":0,"renderable":0},{"_id":"source/images/7.png","path":"images/7.png","modified":0,"renderable":0},{"_id":"source/images/12.png","path":"images/12.png","modified":0,"renderable":0},{"_id":"source/images/4.jpg","path":"images/4.jpg","modified":0,"renderable":0},{"_id":"source/images/5.jpg","path":"images/5.jpg","modified":0,"renderable":0},{"_id":"source/images/9.jpg","path":"images/9.jpg","modified":0,"renderable":0},{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/logo.jpg","path":"img/logo.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"source/images/2.jpg","path":"images/2.jpg","modified":0,"renderable":0},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"5b927045776d2720b73f17de6bdede8a15801a9d","modified":1465384471000},{"_id":"themes/indigo/_config.yml","hash":"6905e8204edf1c20e715ec955affedf0b2992baf","modified":1465383942000},{"_id":"themes/indigo/README.md","hash":"c07f8d00a117cb1f7c1bc480d4d2b3d129340959","modified":1465367447000},{"_id":"themes/indigo/package.json","hash":"8ab2c2ef5c47df0f84961bfae0d8ddd990774f95","modified":1465367447000},{"_id":"source/_posts/CSS border-image.md","hash":"ab887948363103a16f8bd25fbcc1e03cc6a7a3bd","modified":1465443924000},{"_id":"source/_posts/CSS 变形.md","hash":"1cec375164fb5f610475bd133ab28e8cea8297b2","modified":1465443070000},{"_id":"source/_posts/CSS 空心字.md","hash":"f03d7cdabaa619f270fbf000a16470322ab58e25","modified":1465443428000},{"_id":"source/_posts/CSS border-radius.md","hash":"6dad7e6086eb505146bebd493c527abda5cb2f5b","modified":1465443667000},{"_id":"source/_posts/CSS 语法速查.md","hash":"789e2d5557ee5cae6ae66ba7d5ac25f3bdf71828","modified":1465379641000},{"_id":"source/_posts/ES6 简单特性概览.md","hash":"8d5c9d55c5cb41bf780e77f4b42d5f8ce44aa888","modified":1465384868000},{"_id":"source/_posts/Reflux 使用进化日记.md","hash":"056b8f59362854096ac9adcbca8203891a349a5e","modified":1465379667000},{"_id":"source/_posts/oracle安装.md","hash":"cfe892dac670db38ea06c3b331c3eb0e1faf0519","modified":1465382104000},{"_id":"source/_posts/web 前端外部点击事件的实现.md","hash":"0e836becbcb29ba7f436a062dcef18fe6916023d","modified":1465379673000},{"_id":"source/_posts/一个 JavaScript.md","hash":"95bdd0638887c00008cc57c518f841a24882b52e","modified":1465379440000},{"_id":"source/_posts/使用 CSS background 构造一个棋盘.md","hash":"9a676f2f492a35171e533b28c3ed1ab0530d71a8","modified":1465444463000},{"_id":"source/_posts/一些 core javascript 的基础知识.md","hash":"5b78bf6f390ac570563321ee745ddd0e08147666","modified":1465379465000},{"_id":"source/_posts/使用marked解析markdown.md","hash":"9fe79efa2446e97c92e8fc5ef24b96400fbdb2a3","modified":1465379482000},{"_id":"source/_posts/实现第一个 vscode 扩展.md","hash":"8fbdd414d49646f497a1cc2cfbdd9ac2c5f69297","modified":1465379528000},{"_id":"source/_posts/爬虫与编码.md","hash":"f3463ec16bac295b88e0134e91839e6461acb5b1","modified":1465379541000},{"_id":"source/_posts/生成器（ generator ）.md","hash":"100d67fc6fa0a5f4fa9cf35215134824fc907fe8","modified":1465379552000},{"_id":"source/_posts/百度 EFE 前端框架学习笔记（ef）.md","hash":"e7a16dfc43465cb65e6115552ec441b2db298ed3","modified":1465379564000},{"_id":"source/_posts/百度 EFE 前端框架学习笔记（er）.md","hash":"3a9fb7b4eabaa939caccd5621acc8e5a4eb51d58","modified":1465379570000},{"_id":"source/_posts/记一次坑爹的对接经历.md","hash":"44b309d8c3f797ea60f41d0db73eb8eaa1c22596","modified":1465379612000},{"_id":"source/_posts/百度 EFE 前端框架学习笔记（esui）.md","hash":"126dae9115bea10f36c9a7040b79bfe6953ce2da","modified":1465444650000},{"_id":"source/images/10.jpg","hash":"906e7332b1198b78316d5436ce674f44700cdaae","modified":1465273954000},{"_id":"source/images/13.png","hash":"30227705d6c65db3d0a0079a329a5664e8432a91","modified":1465273954000},{"_id":"source/images/6.png","hash":"2540ef82a10707d536ec9f8313a1e529b0b97ed4","modified":1465273954000},{"_id":"source/images/8.jpg","hash":"320024a19a4402847e231090c0872b82aa899f74","modified":1465273954000},{"_id":"themes/indigo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1465367447000},{"_id":"themes/indigo/.git/config","hash":"12b35407a939147ac490763ecfb433aa87d8cfb9","modified":1465367447000},{"_id":"themes/indigo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1465367433000},{"_id":"themes/indigo/.git/index","hash":"987de2db82e8a1caf05e8e82df0eb760a61da090","modified":1465367447000},{"_id":"themes/indigo/.git/packed-refs","hash":"a59e55c9cba038a39523466657606d26ae5e2926","modified":1465367447000},{"_id":"themes/indigo/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1465367447000},{"_id":"themes/indigo/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1465367447000},{"_id":"themes/indigo/layout/category.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1465367447000},{"_id":"themes/indigo/layout/layout.ejs","hash":"fc36f206a97bf65eacead631a0dbf043dcf356ac","modified":1465367447000},{"_id":"themes/indigo/layout/post.ejs","hash":"a05fd1a27e1c54c9dbab9e69a257a299b0f549cc","modified":1465388884000},{"_id":"themes/indigo/layout/tag.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1465367447000},{"_id":"themes/indigo/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1465367447000},{"_id":"source/images/1.jpg","hash":"d3f71673e7e0a5785559bf18a45a6074d2267c4c","modified":1465273954000},{"_id":"source/images/11.jpg","hash":"9fbcbe6b096df4d0b0ae1b28610a25f2f390c07e","modified":1465273954000},{"_id":"source/images/3.jpg","hash":"a5f9496f1e6dbd3141f3881d4676dfdaf13202ec","modified":1465273954000},{"_id":"source/images/7.png","hash":"f9de759cf2d5ef2271049ed537b7a95a70c00a82","modified":1465273954000},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1465377200000},{"_id":"themes/indigo/screenshots/hexo-theme-pad.png","hash":"d7c897b32e7eab0146bb2530433c9b8b7571d59c","modified":1465367447000},{"_id":"themes/indigo/screenshots/hexo-theme-phone-1.png","hash":"9b30409ec4c9b94b5582346323ed2c8e26dbc4c0","modified":1465367447000},{"_id":"themes/indigo/screenshots/hexo-theme-phone-2.png","hash":"b6807228992222a8fa095a940a41f40f841a5f6e","modified":1465367447000},{"_id":"source/images/12.png","hash":"aa0e49edbef374addd722cdce1af04b4c6d590bd","modified":1465273954000},{"_id":"source/images/4.jpg","hash":"cc17a1b9d9265f1aedda29cfd15b24798caafb79","modified":1465273954000},{"_id":"source/images/5.jpg","hash":"b20a459406751349285f5f09b535efc054e6d9e3","modified":1465273954000},{"_id":"themes/indigo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1465367433000},{"_id":"themes/indigo/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1465367433000},{"_id":"source/images/9.jpg","hash":"b20a459406751349285f5f09b535efc054e6d9e3","modified":1465273954000},{"_id":"themes/indigo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1465367433000},{"_id":"themes/indigo/.git/logs/HEAD","hash":"e0399466946a1ad6c88720a179bdf4f5bf3ba0cd","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"3b160eaaefb7a493d9dc96c932f06f0ee2772f7d","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/archive-post.ejs","hash":"60a468dcf37c9f313090c9fe569278b6c846891f","modified":1465381581000},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"7f632fcfde543ea87a9a70fafabebf76ef21e9e0","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/article.ejs","hash":"75a0ff40e5bd63b2492bf30b7fa6ee8bd8afe0e2","modified":1465383025000},{"_id":"themes/indigo/layout/_partial/cnzz.ejs","hash":"03f75c55cb78686603a430fa42c63805872fb902","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"5c4db4d00e7d93ba275f3cf700615eecd2a6be9e","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"417ede6f9721045f0c7a1d0c6c480cebc2811273","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"bc4cb19b20de55a0332647f4dca9684184383685","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/mathjax.ejs","hash":"c3394a1257a4f2cf30644016d9dc43e3a44d61dc","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"3905d8869ba4aa19e635fedd0819152f6bdb996a","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"555527d72e538897defd0cc7c9b8bf4dc3166153","modified":1465394214000},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"1c8e7a1d512f4b81431f03eb80b0b331229799bb","modified":1465367447000},{"_id":"themes/indigo/source/css/style.less","hash":"bc2bcbf43091599ab63edc79413f9d08e8fb061f","modified":1465367447000},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1465367447000},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1465367447000},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1465367447000},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1465367447000},{"_id":"themes/indigo/source/img/logo.jpg","hash":"a089e42acab93864d33e16801b0ac5dc1617c373","modified":1465367447000},{"_id":"themes/indigo/source/js/main.js","hash":"e3ccf70da521a03a581b1dd23b0cbea9b4f023a9","modified":1465367447000},{"_id":"themes/indigo/source/js/search.js","hash":"a7046c9d279b0519715348dffc62d2f879cb485f","modified":1465367447000},{"_id":"source/images/2.jpg","hash":"a09b477549ff2523dd0185f1259243f83a7a65bd","modified":1465273954000},{"_id":"themes/indigo/screenshots/hexo-theme-pc.png","hash":"497742866f4b550c05e9cb0d353c08b4f9e9d171","modified":1465367447000},{"_id":"themes/indigo/.git/refs/heads/master","hash":"f093f8cbf6bdada651b23dbfc872aebe0dd36744","modified":1465367447000},{"_id":"themes/indigo/.git/objects/pack/pack-b8d89544fa0a4ee42d6915f96ab1265d3e14c499.idx","hash":"44546fade2e08b34659638013423461d694d6e13","modified":1465367446000},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"cc86872859e924cebd35cb2acdd0c79c074c48d0","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"6c359ca773dee87ecf7a1553a31a9418c900583a","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"f17cbe521405a8b3a699a4477f8816eb8a86d92e","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"6b2ab0a9a67732ba18bc8520f0ff6805457bb427","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"cfb58029f04ffaa3a45e807a848ac077b987d7c4","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"33181dbf9c126b3354a2e6a83605c40674b222b7","modified":1465367447000},{"_id":"themes/indigo/layout/_partial/post/tags.ejs","hash":"91e94dcd997acb71ac688993715390c7e48b89c1","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"fbb88e9d0885001dea95c2fd3c10a640b1494802","modified":1465443190000},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"05e2a6ec8ac4d8cf50d050509442276122fcf43b","modified":1465381618000},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"b7db31b9bc563c10b9e3cf3e6d9cfddfeb3e805a","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"ca7e3c0d6b1b77f572ce25d87f482a1a36cb579c","modified":1465382493000},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"a43d79dee0f667d85bcddee23ad43e736e133ee3","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"d7bfa678f162afb9cffbb5f197c072dc2058794a","modified":1465383141000},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"c32656b8d51fca9b3bfa95f1aa44b51ade203e18","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"7c7f5314bc20ec1a8d20269671a8b858f9e21d67","modified":1465382120000},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"2e0469ed8161d5672d903ca1a8027cd65fe007f1","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"d73a12ca56cd710a13cb61074958c82a5cb95d63","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"ee3e78323e52aa7e8b8c3f66324ca141a69ecb6a","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"6a256bfa57547ede5e05dfa61878f582780db6ad","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"7b30ad46ae89cc2bbd8b27bff1443909ee596010","modified":1465382068000},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"61019c991dff98a380314b88c6f875d693c3e7e1","modified":1465367447000},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"9d9b1946357a653adebc29859ad0de70adcc27dd","modified":1465367447000},{"_id":"themes/indigo/.git/logs/refs/heads/master","hash":"e0399466946a1ad6c88720a179bdf4f5bf3ba0cd","modified":1465367447000},{"_id":"themes/indigo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1465367447000},{"_id":"themes/indigo/.git/logs/refs/remotes/origin/HEAD","hash":"e0399466946a1ad6c88720a179bdf4f5bf3ba0cd","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1465367447000},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1465367447000},{"_id":"themes/indigo/.git/objects/pack/pack-b8d89544fa0a4ee42d6915f96ab1265d3e14c499.pack","hash":"9ba3714df466404d8c9743d727968a588da28383","modified":1465367446000},{"_id":"source/demos/border-image.html","hash":"ad3fc4b07fa7c772733525294d0b55ea58d5fcc4","modified":1465443783000},{"_id":"source/demos/空心字1.demo","hash":"d584cd759659d682898279247c47658235399915","modified":1465389595000},{"_id":"source/images/.DS_Store","hash":"a6119698a465a656345a0da301784ca7d2059617","modified":1465399060000},{"_id":"source/_demos/cssskew.html","hash":"61887c7c66bc7687bd5c5bfa9b56aa7047763745","modified":1465356169000},{"_id":"themes/indigo/layout/demo.ejs","hash":"18a1f7cc1fc0ec59cd048289ad4fad17a5b056b5","modified":1465441777000},{"_id":"public/atom.xml","hash":"3efea21cd4cadfbe29713683be55fd0cf7519dd3","modified":1465444995186},{"_id":"public/content.json","hash":"ce2d30ce17beab7b9f38ec1ef975a628adcff0df","modified":1465444995195},{"_id":"public/blogs/site/blogs/oracle安装.html","hash":"111d516ec95e56de8525bbd909916402ce439e21","modified":1465444792031},{"_id":"public/blogs/site/blogs/爬虫与编码.html","hash":"7a558c8e15f61123d4dc6d046e290f9a782f2199","modified":1465444792032},{"_id":"public/blogs/site/blogs/CSS 语法速查.html","hash":"13bc8e2c2f5c0a80dfaa7cdc1c8738a42f2d4a8e","modified":1465444792031},{"_id":"public/blogs/site/blogs/CSS 空心字.html","hash":"03f73b815c0efced8615a1b2acff4a5d5a38be03","modified":1465444792031},{"_id":"public/blogs/site/blogs/CSS 变形.html","hash":"edeeaff9cf68e06a3524cdf2015f297d988a2187","modified":1465444792031},{"_id":"public/blogs/site/blogs/CSS border-image.html","hash":"8e8cbc7b13cf1b768504ea80a6288dea54371769","modified":1465444792032},{"_id":"public/blogs/site/blogs/CSS border-radius.html","hash":"5ef50e51ebb7fef0df63910b008c1f06ed854be8","modified":1465444792031},{"_id":"public/blogs/site/blogs/使用 CSS background 构造一个棋盘.html","hash":"afabc5d95bae9478cf779e8a61f851227123ad59","modified":1465444792032},{"_id":"public/blogs/site/blogs/百度 EFE 前端框架学习笔记（ef）.html","hash":"ce67ff451c30f9b7d9c5a6be58deda1a4478e022","modified":1465444792032},{"_id":"public/blogs/site/blogs/web 前端外部点击事件的实现.html","hash":"5457928a1b1ec7f307949dc65cdf2e5a3509b03c","modified":1465444792032},{"_id":"public/archives/index.html","hash":"20e293e93155dc4aa7ec926ce5ab49e5b17ae8ff","modified":1465444995369},{"_id":"public/archives/page/2/index.html","hash":"90249ec4b74ce29b6699e5195924a4117c12c000","modified":1465444995369},{"_id":"public/archives/2014/10/index.html","hash":"66c071089bd07af7ddcf824ae0809f300f118671","modified":1465444995369},{"_id":"public/archives/2014/index.html","hash":"422afc4b6a6fb4cf31b85cb1d01da246f98c8033","modified":1465444995369},{"_id":"public/archives/2015/index.html","hash":"bf0c8c195a6173d772be1231d85ebcc518c67e8b","modified":1465444995369},{"_id":"public/archives/2015/page/2/index.html","hash":"fd027ea16a5465cdb1ab731793e00813a805bf42","modified":1465444995369},{"_id":"public/archives/2015/05/index.html","hash":"7c1ab7184bfa3c1c951aa71245a2f4bb7daf7fb1","modified":1465444995369},{"_id":"public/archives/2015/06/index.html","hash":"773d98d6d02a4947668d2a35a10aca0874fd7db5","modified":1465444995370},{"_id":"public/archives/2015/07/index.html","hash":"f2e771e9ce4755b66075a9e17cc05a748bf9ba6e","modified":1465444995370},{"_id":"public/archives/2015/08/index.html","hash":"be16f88a328c4aff0e99098f13736527ef5588a0","modified":1465444995370},{"_id":"public/archives/2015/09/index.html","hash":"c764594983d290d8b2953134d3f3cc57a937fe51","modified":1465444995370},{"_id":"public/archives/2015/10/index.html","hash":"3e42cf1f10e48d2532fbf7fb9f817cfdded986c6","modified":1465444995370},{"_id":"public/archives/2016/index.html","hash":"2cdd94b4e35fbea67de9a75f50a980ae09fc03d9","modified":1465444995370},{"_id":"public/archives/2016/01/index.html","hash":"ce48935320ab75f693ac80825f3282fcf86e2bfa","modified":1465444995370},{"_id":"public/archives/2016/05/index.html","hash":"ebe6523d88510bf8a185bf29b316cb6438d3e44e","modified":1465444995370},{"_id":"public/tags/oracle/index.html","hash":"e65204eafe6955830c92d6d7c84b0356b2f0ce9c","modified":1465444995370},{"_id":"public/tags/数据库/index.html","hash":"410d1afb25a83db4cec7645af6d547712fd85537","modified":1465444995370},{"_id":"public/blogs/site/blogs/使用marked解析markdown.html","hash":"41dd8f992f5ab838eb5f37881ecaa6c256fce97c","modified":1465444792033},{"_id":"public/blogs/site/blogs/实现第一个 vscode 扩展.html","hash":"6b4b299b847e2bedadb0be22edba1f8c1923217f","modified":1465444792033},{"_id":"public/blogs/site/blogs/ES6 简单特性概览.html","hash":"cc3aad07e424acfdc1844a713345e98cc1f842b1","modified":1465444792033},{"_id":"public/blogs/site/blogs/一个 JavaScript.html","hash":"78332467d2a0ae3aa191293007c310fc69b15645","modified":1465444792033},{"_id":"public/blogs/site/blogs/生成器（ generator ）.html","hash":"3d34b0fee235044ff7727ae6ea663b9b8049ddde","modified":1465444792033},{"_id":"public/blogs/site/blogs/百度 EFE 前端框架学习笔记（esui）.html","hash":"34b9cd8099d11d5359fd85275b387b4ec10d7719","modified":1465444792033},{"_id":"public/blogs/site/blogs/百度 EFE 前端框架学习笔记（er）.html","hash":"4d1406ecaf440a28253a6107f866b240aa48d112","modified":1465444792033},{"_id":"public/blogs/site/blogs/Reflux 使用进化日记.html","hash":"79874823b89592f3f3355ad578eb8f5469880975","modified":1465444792033},{"_id":"public/blogs/site/blogs/记一次坑爹的对接经历.html","hash":"553c9aba14d755d5d428c3e6af8d4685d353d842","modified":1465444792033},{"_id":"public/blogs/site/blogs/一些 core javascript 的基础知识.html","hash":"6767b8980db65da20847c0ff9e9b8d1d163b6da1","modified":1465444792034},{"_id":"public/index.html","hash":"70f7f681cb9ca3143af283fcc0293c9065b54d82","modified":1465444995371},{"_id":"public/page/2/index.html","hash":"f06436407bb31852d04277d9da7b16e29530f8cc","modified":1465444995371},{"_id":"public/images/10.jpg","hash":"906e7332b1198b78316d5436ce674f44700cdaae","modified":1465444792034},{"_id":"public/images/13.png","hash":"30227705d6c65db3d0a0079a329a5664e8432a91","modified":1465444792046},{"_id":"public/images/6.png","hash":"2540ef82a10707d536ec9f8313a1e529b0b97ed4","modified":1465444792034},{"_id":"public/images/8.jpg","hash":"320024a19a4402847e231090c0872b82aa899f74","modified":1465444792034},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1465444792046},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1465444792046},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1465444792046},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1465444792046},{"_id":"public/img/logo.jpg","hash":"a089e42acab93864d33e16801b0ac5dc1617c373","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1465444792046},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1465444792048},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1465444792047},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1465444792048},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1465444792048},{"_id":"public/images/1.jpg","hash":"d3f71673e7e0a5785559bf18a45a6074d2267c4c","modified":1465444792083},{"_id":"public/images/11.jpg","hash":"9fbcbe6b096df4d0b0ae1b28610a25f2f390c07e","modified":1465444792083},{"_id":"public/images/3.jpg","hash":"a5f9496f1e6dbd3141f3881d4676dfdaf13202ec","modified":1465444792083},{"_id":"public/images/7.png","hash":"f9de759cf2d5ef2271049ed537b7a95a70c00a82","modified":1465444792083},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1465444792083},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1465444792083},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1465444792084},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1465444792086},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1465444792083},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1465444792086},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1465444792086},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1465444792086},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1465444792084},{"_id":"public/js/search.js","hash":"a7046c9d279b0519715348dffc62d2f879cb485f","modified":1465444792090},{"_id":"public/js/main.js","hash":"e3ccf70da521a03a581b1dd23b0cbea9b4f023a9","modified":1465444792091},{"_id":"public/images/12.png","hash":"aa0e49edbef374addd722cdce1af04b4c6d590bd","modified":1465444792091},{"_id":"public/images/4.jpg","hash":"cc17a1b9d9265f1aedda29cfd15b24798caafb79","modified":1465444792091},{"_id":"public/images/5.jpg","hash":"b20a459406751349285f5f09b535efc054e6d9e3","modified":1465444792091},{"_id":"public/images/9.jpg","hash":"b20a459406751349285f5f09b535efc054e6d9e3","modified":1465444792091},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1465444792091},{"_id":"public/images/2.jpg","hash":"a09b477549ff2523dd0185f1259243f83a7a65bd","modified":1465444792095},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1465444792101},{"_id":"public/css/style.css","hash":"c72cc6de8499ef4dc4861df5358813cc93690bde","modified":1465444792302},{"_id":"source/demos/cssskew.html","hash":"d2d71ecc3fc8d8793be404f7f5a967d12aa16849","modified":1465441673000},{"_id":"public/demos/cssskew.html","hash":"0fb4a0e38aeba5b163d41aa9cb9e398d026dcd17","modified":1465441601566},{"_id":"source/demos/-webkit-border-image.html","hash":"c1bba9ee59820500fe64cdf804c199c8f2c0c1b7","modified":1465443940000},{"_id":"source/demos/border-radius.html","hash":"465733cc0acda1f510f114499dc0128342847d7c","modified":1465443547000},{"_id":"source/demos/css background.html","hash":"5cfe1e77ab3a06b3d593edb9b18ed3cad51b2032","modified":1465444168000},{"_id":"source/demos/envelope.html","hash":"6f59d00b990f239801c5d63a7cfe9d21a329b6da","modified":1465444066000},{"_id":"source/demos/css skew.html","hash":"078325170188d7f42b2f6fc35ac90087ea2a8093","modified":1465441857000},{"_id":"source/demos/half ellipse.html","hash":"b57e4fffe5e52369a92d24bca1f8340108b10f8e","modified":1465443629000},{"_id":"source/demos/marching ants borders.html","hash":"5d530bf3d8f99a618230f63b7e7858d1c097e4b1","modified":1465444218000},{"_id":"source/demos/transform-origin.html","hash":"077d1294072f91ba7b58f5fd016147655fecade0","modified":1465442856000},{"_id":"source/demos/transform-style.html","hash":"26a1a8e77f4a5a1a5a67b86c4524f96c75c2a9d0","modified":1465443004000},{"_id":"source/demos/空心字1.html","hash":"7ebf535e719320e138713935d58d44163cd8c902","modified":1465443323000},{"_id":"source/demos/空心字2.html","hash":"5b9605ae592390398e125e6cb22bfd34ced66731","modified":1465443414000},{"_id":"public/demos/css skew.html","hash":"61887c7c66bc7687bd5c5bfa9b56aa7047763745","modified":1465444791852},{"_id":"public/demos/transform-origin.html","hash":"6922800dbf48280e672be8c504b60efa44bb3fdc","modified":1465444792008},{"_id":"public/demos/border-radius.html","hash":"fe6c99602af9c2f50e927f73af1e88dc1bb1387f","modified":1465444792015},{"_id":"public/demos/transform-style.html","hash":"ed1356c17f9e25750060aae51043c692109a3f0f","modified":1465444792008},{"_id":"public/demos/空心字1.html","hash":"d584cd759659d682898279247c47658235399915","modified":1465444792015},{"_id":"public/demos/border-image.html","hash":"fe6ab016b561b822eb9ff7977f6389b0d563a8ed","modified":1465444792015},{"_id":"public/demos/half ellipse.html","hash":"6dd487332ace60c479d307128da6fb4fac6c906a","modified":1465444792015},{"_id":"public/demos/-webkit-border-image.html","hash":"eb794c59acc6b2f749c93382f0638010fb79e9d6","modified":1465444792015},{"_id":"public/demos/envelope.html","hash":"81e4b6601501999d9bc47f90d4135fe7536756d6","modified":1465444792015},{"_id":"public/demos/空心字2.html","hash":"ce237c37194a8c60ae8c0510a2514cdda11b0454","modified":1465444792014},{"_id":"public/demos/marching ants borders.html","hash":"4423e1f579e3bbddbfc005cb655d21f5cf960b37","modified":1465444792015},{"_id":"public/demos/css background.html","hash":"ddbeacc9053e20a74bb00e464d6f6dc4d1d73118","modified":1465444792015},{"_id":"public/blogs/oracle安装.html","hash":"3963be299137d84b1f395dee25c7232d6aa4558b","modified":1465444995368},{"_id":"public/blogs/爬虫与编码.html","hash":"beaadea0b60b1fcba43ea7c194b065daad2f726c","modified":1465444995368},{"_id":"public/blogs/CSS 语法速查.html","hash":"5201d75d3c8678e51dc46cf5f3530c058cd4ef2c","modified":1465444995368},{"_id":"public/blogs/CSS 空心字.html","hash":"042478b63744628dd0e68a7ca6b1f924ead239a7","modified":1465444995368},{"_id":"public/blogs/CSS 变形.html","hash":"b8605b6997463915baf78d1f9de6d8b04d5532b6","modified":1465444995369},{"_id":"public/blogs/CSS border-radius.html","hash":"4c047ba2a7bbf92f505fc6532b306223cca6a1c5","modified":1465444995369},{"_id":"public/blogs/CSS border-image.html","hash":"41cfd80ebba00aea17cff99262ba372e36e920c7","modified":1465444995369},{"_id":"public/blogs/使用 CSS background 构造一个棋盘.html","hash":"6fa9211e9505ea78644568fc680e89340652664e","modified":1465444995369},{"_id":"public/blogs/百度 EFE 前端框架学习笔记（ef）.html","hash":"cd3f5d1d4df1c0a2fdcd4438997915fd7e58c8ce","modified":1465444995369},{"_id":"public/blogs/web 前端外部点击事件的实现.html","hash":"ee5c85198c38e878d9e23000136ade186cc6faa5","modified":1465444995369},{"_id":"public/blogs/使用marked解析markdown.html","hash":"37ed05aaee7e6e23869ecdaa9a7ec008daca5582","modified":1465444995370},{"_id":"public/blogs/实现第一个 vscode 扩展.html","hash":"9000ee9be7a21a5bcf2e65acdf9bb074e97b83ef","modified":1465444995370},{"_id":"public/blogs/ES6 简单特性概览.html","hash":"38179f77a44db78b78605dbd74da4630eb2bea8a","modified":1465444995370},{"_id":"public/blogs/一个 JavaScript.html","hash":"8b5c44b110f2334268aa2092a38bba8c5588375e","modified":1465444995370},{"_id":"public/blogs/生成器（ generator ）.html","hash":"efe5069f45e55346318527ece46069d6405db4c1","modified":1465444995370},{"_id":"public/blogs/百度 EFE 前端框架学习笔记（esui）.html","hash":"f91573f27c48907536415c556742b6c7a4c7ffed","modified":1465444995371},{"_id":"public/blogs/百度 EFE 前端框架学习笔记（er）.html","hash":"efd47cc045262f983dfefd4d66c96dce29bcc6a4","modified":1465444995371},{"_id":"public/blogs/Reflux 使用进化日记.html","hash":"c9d259e2e31ec12934b31c9ca949203f513dc20d","modified":1465444995371},{"_id":"public/blogs/记一次坑爹的对接经历.html","hash":"70c3f6194648dfccdea1a860b260b186b4a99e41","modified":1465444995371},{"_id":"public/blogs/一些 core javascript 的基础知识.html","hash":"ffb295a25a892cb6b968ce33598958744d2528f7","modified":1465444995371}],"Category":[],"Data":[],"Page":[{"layout":"false","_content":"<style type=\"text/css\">\n.demo3 {\n    width: 400px;\n    height: 300px;\n    position: relative;\n}\n.demo3 .box1, .demo3 .box2, .demo3 .box3, .demo3 .box4 {\n    top: 100px;\n    left: 50px;\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo3 .box1 {\n    border: 1px #000 dotted;\n}\n.demo3 .box2 {\n    border: 1px solid #000;\n    transform: skewX(45deg);\n    -webkit-transform: skewX(45deg);\n}\n\n.demo3 .box3, .demo3 .box4 {\n    left: 240px;\n}\n.demo3 .box3 {\n    border: 1px dotted #000;\n}\n.demo3 .box4 {\n    border: 1px solid #000;\n    transform: skewY(45deg);\n    -webkit-transform: skewY(45deg);\n}\n\n.demo3 h5 {\n    position: absolute;\n    margin: 0;\n    top: 20px;\n}\n.demo3 h5:first-child {\n    left: 24px;\n}\n.demo3 h5:nth-child(4) {\n    left: 246px;\n}\n</style>\n\n<div class=\"demo3\">\n    <h5>skewX(45deg)</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n    <h5>skewY(45deg)</h5>\n    <div class=\"box3\"></div>\n    <div class=\"box4\"></div>\n</div>","source":"demos/css skew.html","raw":"---\nlayout: false\n---\n<style type=\"text/css\">\n.demo3 {\n    width: 400px;\n    height: 300px;\n    position: relative;\n}\n.demo3 .box1, .demo3 .box2, .demo3 .box3, .demo3 .box4 {\n    top: 100px;\n    left: 50px;\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo3 .box1 {\n    border: 1px #000 dotted;\n}\n.demo3 .box2 {\n    border: 1px solid #000;\n    transform: skewX(45deg);\n    -webkit-transform: skewX(45deg);\n}\n\n.demo3 .box3, .demo3 .box4 {\n    left: 240px;\n}\n.demo3 .box3 {\n    border: 1px dotted #000;\n}\n.demo3 .box4 {\n    border: 1px solid #000;\n    transform: skewY(45deg);\n    -webkit-transform: skewY(45deg);\n}\n\n.demo3 h5 {\n    position: absolute;\n    margin: 0;\n    top: 20px;\n}\n.demo3 h5:first-child {\n    left: 24px;\n}\n.demo3 h5:nth-child(4) {\n    left: 246px;\n}\n</style>\n\n<div class=\"demo3\">\n    <h5>skewX(45deg)</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n    <h5>skewY(45deg)</h5>\n    <div class=\"box3\"></div>\n    <div class=\"box4\"></div>\n</div>","date":"2016-06-09T03:10:57.000Z","updated":"2016-06-09T03:10:57.000Z","path":"demos/css skew.html","_id":"cip7q9er300001u07xsm7ky1c","title":"","comments":1,"content":"<style type=\"text/css\">\n.demo3 {\n    width: 400px;\n    height: 300px;\n    position: relative;\n}\n.demo3 .box1, .demo3 .box2, .demo3 .box3, .demo3 .box4 {\n    top: 100px;\n    left: 50px;\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo3 .box1 {\n    border: 1px #000 dotted;\n}\n.demo3 .box2 {\n    border: 1px solid #000;\n    transform: skewX(45deg);\n    -webkit-transform: skewX(45deg);\n}\n\n.demo3 .box3, .demo3 .box4 {\n    left: 240px;\n}\n.demo3 .box3 {\n    border: 1px dotted #000;\n}\n.demo3 .box4 {\n    border: 1px solid #000;\n    transform: skewY(45deg);\n    -webkit-transform: skewY(45deg);\n}\n\n.demo3 h5 {\n    position: absolute;\n    margin: 0;\n    top: 20px;\n}\n.demo3 h5:first-child {\n    left: 24px;\n}\n.demo3 h5:nth-child(4) {\n    left: 246px;\n}\n</style>\n\n<div class=\"demo3\">\n    <h5>skewX(45deg)</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n    <h5>skewY(45deg)</h5>\n    <div class=\"box3\"></div>\n    <div class=\"box4\"></div>\n</div>","excerpt":"","more":"<style type=\"text/css\">\n.demo3 {\n    width: 400px;\n    height: 300px;\n    position: relative;\n}\n.demo3 .box1, .demo3 .box2, .demo3 .box3, .demo3 .box4 {\n    top: 100px;\n    left: 50px;\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo3 .box1 {\n    border: 1px #000 dotted;\n}\n.demo3 .box2 {\n    border: 1px solid #000;\n    transform: skewX(45deg);\n    -webkit-transform: skewX(45deg);\n}\n\n.demo3 .box3, .demo3 .box4 {\n    left: 240px;\n}\n.demo3 .box3 {\n    border: 1px dotted #000;\n}\n.demo3 .box4 {\n    border: 1px solid #000;\n    transform: skewY(45deg);\n    -webkit-transform: skewY(45deg);\n}\n\n.demo3 h5 {\n    position: absolute;\n    margin: 0;\n    top: 20px;\n}\n.demo3 h5:first-child {\n    left: 24px;\n}\n.demo3 h5:nth-child(4) {\n    left: 246px;\n}\n</style>\n\n<div class=\"demo3\">\n    <h5>skewX(45deg)</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n    <h5>skewY(45deg)</h5>\n    <div class=\"box3\"></div>\n    <div class=\"box4\"></div>\n</div>"},{"layout":"false","_content":"<meta charset=\"utf-8\">\n<style type=\"text/css\">\n.demo1 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo1 .box1, .demo1 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo1 .box1 {\n    border: 1px dotted #000;\n}\n.demo1 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 50% 50%;\n    -webkit-transform-origin: 50% 50%;\n}\n</style>\n\n<div class=\"demo1\">\n    <h5>示例1</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>\n\n<style type=\"text/css\">\n.demo2 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo2 .box1, .demo2 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo2 .box1 {\n    border: 1px dotted #000;\n}\n.demo2 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 100% 100%;\n    -webkit-transform-origin: 100% 100%;\n}\n</style>\n\n<div class=\"demo2\">\n    <h5>示例2</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>","source":"demos/transform-origin.html","raw":"---\nlayout: false\n---\n<meta charset=\"utf-8\">\n<style type=\"text/css\">\n.demo1 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo1 .box1, .demo1 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo1 .box1 {\n    border: 1px dotted #000;\n}\n.demo1 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 50% 50%;\n    -webkit-transform-origin: 50% 50%;\n}\n</style>\n\n<div class=\"demo1\">\n    <h5>示例1</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>\n\n<style type=\"text/css\">\n.demo2 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo2 .box1, .demo2 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo2 .box1 {\n    border: 1px dotted #000;\n}\n.demo2 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 100% 100%;\n    -webkit-transform-origin: 100% 100%;\n}\n</style>\n\n<div class=\"demo2\">\n    <h5>示例2</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>","date":"2016-06-09T03:27:36.000Z","updated":"2016-06-09T03:27:36.000Z","path":"demos/transform-origin.html","_id":"cip7qtrjw00011u07tk5b16cy","title":"","comments":1,"content":"<meta charset=\"utf-8\">\n<style type=\"text/css\">\n.demo1 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo1 .box1, .demo1 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo1 .box1 {\n    border: 1px dotted #000;\n}\n.demo1 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 50% 50%;\n    -webkit-transform-origin: 50% 50%;\n}\n</style>\n\n<div class=\"demo1\">\n    <h5>示例1</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>\n\n<style type=\"text/css\">\n.demo2 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo2 .box1, .demo2 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo2 .box1 {\n    border: 1px dotted #000;\n}\n.demo2 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 100% 100%;\n    -webkit-transform-origin: 100% 100%;\n}\n</style>\n\n<div class=\"demo2\">\n    <h5>示例2</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>","excerpt":"","more":"<meta charset=\"utf-8\">\n<style type=\"text/css\">\n.demo1 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo1 .box1, .demo1 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo1 .box1 {\n    border: 1px dotted #000;\n}\n.demo1 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 50% 50%;\n    -webkit-transform-origin: 50% 50%;\n}\n</style>\n\n<div class=\"demo1\">\n    <h5>示例1</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>\n\n<style type=\"text/css\">\n.demo2 {\n    width: 150px;\n    height: 200px;\n    position: relative;\n}\n.demo2 .box1, .demo2 .box2 {\n    top: 25px;\n    width: 100px;\n    height: 100px;\n    position: absolute;\n}\n.demo2 .box1 {\n    border: 1px dotted #000;\n}\n.demo2 .box2 {\n    border: 1px solid #000;\n    transform: translate(40px, 40px);\n    -webkit-transform: translate(40px, 40px);\n    transform-origin: 100% 100%;\n    -webkit-transform-origin: 100% 100%;\n}\n</style>\n\n<div class=\"demo2\">\n    <h5>示例2</h5>\n    <div class=\"box1\"></div>\n    <div class=\"box2\"></div>\n</div>"},{"layout":"false","_content":"<style>\n.demo4 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo4 .container1,\n.demo4 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo4 .container1-origin, .demo4 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo4 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo4 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: flat;\n    -webkit-transform-style: flat;\n}\n.demo4 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo4\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>\n\n<style>\n.demo5 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo5 .container1,\n.demo5 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n.demo5 .container1-origin, .demo5 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo5 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo5 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: preserve-3d;\n    -webkit-transform-style: preserve-3d;\n}\n.demo5 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo5\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>","source":"demos/transform-style.html","raw":"---\nlayout: false\n---\n<style>\n.demo4 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo4 .container1,\n.demo4 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo4 .container1-origin, .demo4 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo4 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo4 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: flat;\n    -webkit-transform-style: flat;\n}\n.demo4 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo4\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>\n\n<style>\n.demo5 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo5 .container1,\n.demo5 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n.demo5 .container1-origin, .demo5 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo5 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo5 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: preserve-3d;\n    -webkit-transform-style: preserve-3d;\n}\n.demo5 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo5\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>","date":"2016-06-09T03:30:04.000Z","updated":"2016-06-09T03:30:04.000Z","path":"demos/transform-style.html","_id":"cip7qx5wu00021u07pcx7r9v5","title":"","comments":1,"content":"<style>\n.demo4 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo4 .container1,\n.demo4 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo4 .container1-origin, .demo4 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo4 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo4 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: flat;\n    -webkit-transform-style: flat;\n}\n.demo4 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo4\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>\n\n<style>\n.demo5 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo5 .container1,\n.demo5 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n.demo5 .container1-origin, .demo5 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo5 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo5 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: preserve-3d;\n    -webkit-transform-style: preserve-3d;\n}\n.demo5 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo5\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>","excerpt":"","more":"<style>\n.demo4 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo4 .container1,\n.demo4 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n\n.demo4 .container1-origin, .demo4 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo4 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo4 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: flat;\n    -webkit-transform-style: flat;\n}\n.demo4 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo4\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>\n\n<style>\n.demo5 {\n    position: relative;\n    width: 200px;\n    height: 200px;\n    perspective: 200px;\n    -webkit-perspective: 200px;\n}\n.demo5 .container1,\n.demo5 .container1-origin {\n    position: absolute;\n    width: 100px;\n    height: 100px;\n}\n.demo5 .container1-origin, .demo5 .container1 {\n    left: 40px;\n    top: 40px;\n}\n.demo5 .container1-origin {\n    border: 1px dotted #000;\n}\n.demo5 .container1 {\n    border: 1px solid #000;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n    transform-style: preserve-3d;\n    -webkit-transform-style: preserve-3d;\n}\n.demo5 .container1 .box {\n    border: 1px solid #f00;\n    width: 50px;\n    height: 50px;\n    transform: rotateY(40deg);\n    -webkit-transform: rotateY(40deg);\n}\n</style>\n\n<div class=\"demo5\">\n    <div class=\"container1-origin\">\n        <div class=\"box\"></div>\n    </div>\n    <div class=\"container1\">\n        <div class=\"box\"></div>\n    </div>\n</div>"},{"layout":"false","_content":"<style>\n    .kongxinzi2 span {\n        position: absolute;\n        color: transparent;\n        background-image: repeating-linear-gradient(to bottom, #f00 0%, #000 100%);\n\n        -webkit-background-clip: text;\n        -webkit-text-fill-color: transparent;\n    }\n    .kongxinzi2:after, .kongxinzi2 span {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: monospace;\n    }\n    .kongxinzi2:after {\n        content: attr(title);\n        text-shadow: 0px 0px 1px #1e1414;\n        color: transparent;\n    }\n</style>\n<div class=\"kongxinzi2\" title=\"BARCITO\"><span>BARCITO</span></div>","source":"demos/空心字2.html","raw":"---\nlayout: false\n---\n<style>\n    .kongxinzi2 span {\n        position: absolute;\n        color: transparent;\n        background-image: repeating-linear-gradient(to bottom, #f00 0%, #000 100%);\n\n        -webkit-background-clip: text;\n        -webkit-text-fill-color: transparent;\n    }\n    .kongxinzi2:after, .kongxinzi2 span {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: monospace;\n    }\n    .kongxinzi2:after {\n        content: attr(title);\n        text-shadow: 0px 0px 1px #1e1414;\n        color: transparent;\n    }\n</style>\n<div class=\"kongxinzi2\" title=\"BARCITO\"><span>BARCITO</span></div>","date":"2016-06-09T03:36:54.000Z","updated":"2016-06-09T03:36:54.000Z","path":"demos/空心字2.html","_id":"cip7r3xoj00031u073l5390if","title":"","comments":1,"content":"<style>\n    .kongxinzi2 span {\n        position: absolute;\n        color: transparent;\n        background-image: repeating-linear-gradient(to bottom, #f00 0%, #000 100%);\n\n        -webkit-background-clip: text;\n        -webkit-text-fill-color: transparent;\n    }\n    .kongxinzi2:after, .kongxinzi2 span {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: monospace;\n    }\n    .kongxinzi2:after {\n        content: attr(title);\n        text-shadow: 0px 0px 1px #1e1414;\n        color: transparent;\n    }\n</style>\n<div class=\"kongxinzi2\" title=\"BARCITO\"><span>BARCITO</span></div>","excerpt":"","more":"<style>\n    .kongxinzi2 span {\n        position: absolute;\n        color: transparent;\n        background-image: repeating-linear-gradient(to bottom, #f00 0%, #000 100%);\n\n        -webkit-background-clip: text;\n        -webkit-text-fill-color: transparent;\n    }\n    .kongxinzi2:after, .kongxinzi2 span {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: monospace;\n    }\n    .kongxinzi2:after {\n        content: attr(title);\n        text-shadow: 0px 0px 1px #1e1414;\n        color: transparent;\n    }\n</style>\n<div class=\"kongxinzi2\" title=\"BARCITO\"><span>BARCITO</span></div>"},{"layout":"false","_content":"<style>\n    @keyframes shadow {\n        0% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n        50% {\n            text-shadow: 0px 0px 10px #f00;\n        }\n        100% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n    }\n    .kongxinzi1 {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: sans-serif;\n        color: #fff;\n\n        animation: shadow 5s linear infinite;\n    }\n</style>\n<div class=\"kongxinzi1\">空心字</div>","source":"demos/空心字1.html","raw":"---\nlayout: false\n---\n<style>\n    @keyframes shadow {\n        0% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n        50% {\n            text-shadow: 0px 0px 10px #f00;\n        }\n        100% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n    }\n    .kongxinzi1 {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: sans-serif;\n        color: #fff;\n\n        animation: shadow 5s linear infinite;\n    }\n</style>\n<div class=\"kongxinzi1\">空心字</div>","date":"2016-06-09T03:35:23.000Z","updated":"2016-06-09T03:35:23.000Z","path":"demos/空心字1.html","_id":"cip7r3xom00041u07bvjl6ckw","title":"","comments":1,"content":"<style>\n    @keyframes shadow {\n        0% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n        50% {\n            text-shadow: 0px 0px 10px #f00;\n        }\n        100% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n    }\n    .kongxinzi1 {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: sans-serif;\n        color: #fff;\n\n        animation: shadow 5s linear infinite;\n    }\n</style>\n<div class=\"kongxinzi1\">空心字</div>","excerpt":"","more":"<style>\n    @keyframes shadow {\n        0% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n        50% {\n            text-shadow: 0px 0px 10px #f00;\n        }\n        100% {\n            text-shadow: 0px 0px 0px #f00;\n        }\n    }\n    .kongxinzi1 {\n        font-size: 5em;\n        font-weight: bold;\n        font-family: sans-serif;\n        color: #fff;\n\n        animation: shadow 5s linear infinite;\n    }\n</style>\n<div class=\"kongxinzi1\">空心字</div>"},{"layout":"false","_content":"<style>\n.demo1 {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n\n    border-radius: 20px/5px;\n}\n</style>\n\n<div class=\"demo1\"></div>\n","source":"demos/border-radius.html","raw":"---\nlayout: false\n---\n<style>\n.demo1 {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n\n    border-radius: 20px/5px;\n}\n</style>\n\n<div class=\"demo1\"></div>\n","date":"2016-06-09T03:39:07.000Z","updated":"2016-06-09T03:39:07.000Z","path":"demos/border-radius.html","_id":"cip7r8r3r00051u07bhovh9pp","title":"","comments":1,"content":"<style>\n.demo1 {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n\n    border-radius: 20px/5px;\n}\n</style>\n\n<div class=\"demo1\"></div>\n","excerpt":"","more":"<style>\n.demo1 {\n    width: 100px;\n    height: 100px;\n    background: lightblue;\n\n    border-radius: 20px/5px;\n}\n</style>\n\n<div class=\"demo1\"></div>\n"},{"layout":"false","_content":"<style>\n    .half-ellipse-demo1 {\n        width: 100px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 100px 0 0;\n    }\n    .half-ellipse-demo2 {\n        width: 50px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 0 0 0;\n    }\n</style>\n<div class=\"half-ellipse-demo1\"></div>\n\n<div class=\"half-ellipse-demo2\"></div>","source":"demos/half ellipse.html","raw":"---\nlayout: false\n---\n<style>\n    .half-ellipse-demo1 {\n        width: 100px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 100px 0 0;\n    }\n    .half-ellipse-demo2 {\n        width: 50px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 0 0 0;\n    }\n</style>\n<div class=\"half-ellipse-demo1\"></div>\n\n<div class=\"half-ellipse-demo2\"></div>","date":"2016-06-09T03:40:29.000Z","updated":"2016-06-09T03:40:29.000Z","path":"demos/half ellipse.html","_id":"cip7raigt00061u07fvdvlg8h","title":"","comments":1,"content":"<style>\n    .half-ellipse-demo1 {\n        width: 100px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 100px 0 0;\n    }\n    .half-ellipse-demo2 {\n        width: 50px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 0 0 0;\n    }\n</style>\n<div class=\"half-ellipse-demo1\"></div>\n\n<div class=\"half-ellipse-demo2\"></div>","excerpt":"","more":"<style>\n    .half-ellipse-demo1 {\n        width: 100px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 100px 0 0;\n    }\n    .half-ellipse-demo2 {\n        width: 50px;\n        height: 50px;\n        background: orange;\n        border-radius: 100px 0 0 0;\n    }\n</style>\n<div class=\"half-ellipse-demo1\"></div>\n\n<div class=\"half-ellipse-demo2\"></div>"},{"layout":"false","_content":"<style>\n.border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n</style>\n\n<div class=\"border-image-demo\"></div>\n","source":"demos/border-image.html","raw":"---\nlayout: false\n---\n<style>\n.border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n</style>\n\n<div class=\"border-image-demo\"></div>\n","date":"2016-06-09T03:43:03.000Z","updated":"2016-06-09T03:43:03.000Z","path":"demos/border-image.html","_id":"cip7rdlfe00071u07upt96l1v","title":"","comments":1,"content":"<style>\n.border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n</style>\n\n<div class=\"border-image-demo\"></div>\n","excerpt":"","more":"<style>\n.border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n</style>\n\n<div class=\"border-image-demo\"></div>\n"},{"layout":"false","_content":"<style>\n.-webkit-border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    -webkit-border-image: url(/images/8.jpg) 60 70 round stretch;\n    background-color: red;\n}\n</style>\n\n<div class=\"-webkit-border-image-demo\"></div>\n","source":"demos/-webkit-border-image.html","raw":"---\nlayout: false\n---\n<style>\n.-webkit-border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    -webkit-border-image: url(/images/8.jpg) 60 70 round stretch;\n    background-color: red;\n}\n</style>\n\n<div class=\"-webkit-border-image-demo\"></div>\n","date":"2016-06-09T03:45:40.000Z","updated":"2016-06-09T03:45:40.000Z","path":"demos/-webkit-border-image.html","_id":"cip7rggtd00081u07w94jn1hy","title":"","comments":1,"content":"<style>\n.-webkit-border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    -webkit-border-image: url(/images/8.jpg) 60 70 round stretch;\n    background-color: red;\n}\n</style>\n\n<div class=\"-webkit-border-image-demo\"></div>\n","excerpt":"","more":"<style>\n.-webkit-border-image-demo {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    -webkit-border-image: url(/images/8.jpg) 60 70 round stretch;\n    background-color: red;\n}\n</style>\n\n<div class=\"-webkit-border-image-demo\"></div>\n"},{"layout":"false","_content":"<style type=\"text/css\">\n    .demo-envelope {\n        width: 200px;\n        height: 80px;\n        margin: 50px 10px;\n\n        padding: 1em;\n        border: .5em solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%)\n            0 / 2em 2em;\n        transform: rotateZ(-10deg);\n        -webkit-transform: rotateZ(-10deg);\n    }\n</style>\n<div class=\"demo-envelope\">the envelope border</div>\n","source":"demos/envelope.html","raw":"---\nlayout: false\n---\n<style type=\"text/css\">\n    .demo-envelope {\n        width: 200px;\n        height: 80px;\n        margin: 50px 10px;\n\n        padding: 1em;\n        border: .5em solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%)\n            0 / 2em 2em;\n        transform: rotateZ(-10deg);\n        -webkit-transform: rotateZ(-10deg);\n    }\n</style>\n<div class=\"demo-envelope\">the envelope border</div>\n","date":"2016-06-09T03:47:46.000Z","updated":"2016-06-09T03:47:46.000Z","path":"demos/envelope.html","_id":"cip7rjxdl00091u07qa3x86p6","title":"","comments":1,"content":"<style type=\"text/css\">\n    .demo-envelope {\n        width: 200px;\n        height: 80px;\n        margin: 50px 10px;\n\n        padding: 1em;\n        border: .5em solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%)\n            0 / 2em 2em;\n        transform: rotateZ(-10deg);\n        -webkit-transform: rotateZ(-10deg);\n    }\n</style>\n<div class=\"demo-envelope\">the envelope border</div>\n","excerpt":"","more":"<style type=\"text/css\">\n    .demo-envelope {\n        width: 200px;\n        height: 80px;\n        margin: 50px 10px;\n\n        padding: 1em;\n        border: .5em solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%)\n            0 / 2em 2em;\n        transform: rotateZ(-10deg);\n        -webkit-transform: rotateZ(-10deg);\n    }\n</style>\n<div class=\"demo-envelope\">the envelope border</div>\n"},{"layout":"false","_content":"<style>\n    .css-background-demo1 {\n        width: 300px;\n        height: 200px;\n        margin: 10px 0;\n\n        background-image:\n            repeating-linear-gradient(45deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            ),\n            repeating-linear-gradient(145deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            );\n    }\n</style>\n<div class=\"css-background-demo1\"></div>\n<style>\n    .css-background-demo2 {\n        width: 300px;\n        height: 200px;\n\n        background-image:\n            radial-gradient(\n                transparent 50%,\n                rgba(0,255,0,.5) 50%,\n                rgba(0,255,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 50%,\n                rgba(255,0,0,.5) 50%,\n                rgba(255,0,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 80%,\n                rgba(0,0,255,.5) 80%,\n                rgba(0,0,255,.5) 90%,\n                transparent 90%);\n        background-size: 40px 40px;\n        background-position: 0 0, 20px 20px, 20px 40px;\n    }\n</style>\n<div class=\"css-background-demo2\"></div>\n","source":"demos/css background.html","raw":"---\nlayout: false\n---\n<style>\n    .css-background-demo1 {\n        width: 300px;\n        height: 200px;\n        margin: 10px 0;\n\n        background-image:\n            repeating-linear-gradient(45deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            ),\n            repeating-linear-gradient(145deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            );\n    }\n</style>\n<div class=\"css-background-demo1\"></div>\n<style>\n    .css-background-demo2 {\n        width: 300px;\n        height: 200px;\n\n        background-image:\n            radial-gradient(\n                transparent 50%,\n                rgba(0,255,0,.5) 50%,\n                rgba(0,255,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 50%,\n                rgba(255,0,0,.5) 50%,\n                rgba(255,0,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 80%,\n                rgba(0,0,255,.5) 80%,\n                rgba(0,0,255,.5) 90%,\n                transparent 90%);\n        background-size: 40px 40px;\n        background-position: 0 0, 20px 20px, 20px 40px;\n    }\n</style>\n<div class=\"css-background-demo2\"></div>\n","date":"2016-06-09T03:49:28.000Z","updated":"2016-06-09T03:49:28.000Z","path":"demos/css background.html","_id":"cip7rm1ht000a1u07s082lbu9","title":"","comments":1,"content":"<style>\n    .css-background-demo1 {\n        width: 300px;\n        height: 200px;\n        margin: 10px 0;\n\n        background-image:\n            repeating-linear-gradient(45deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            ),\n            repeating-linear-gradient(145deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            );\n    }\n</style>\n<div class=\"css-background-demo1\"></div>\n<style>\n    .css-background-demo2 {\n        width: 300px;\n        height: 200px;\n\n        background-image:\n            radial-gradient(\n                transparent 50%,\n                rgba(0,255,0,.5) 50%,\n                rgba(0,255,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 50%,\n                rgba(255,0,0,.5) 50%,\n                rgba(255,0,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 80%,\n                rgba(0,0,255,.5) 80%,\n                rgba(0,0,255,.5) 90%,\n                transparent 90%);\n        background-size: 40px 40px;\n        background-position: 0 0, 20px 20px, 20px 40px;\n    }\n</style>\n<div class=\"css-background-demo2\"></div>\n","excerpt":"","more":"<style>\n    .css-background-demo1 {\n        width: 300px;\n        height: 200px;\n        margin: 10px 0;\n\n        background-image:\n            repeating-linear-gradient(45deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            ),\n            repeating-linear-gradient(145deg,\n                rgba(255,0,0,.3) 0,\n                rgba(255,0,0,.3) 10px,\n                rgba(0,255,0,.3) 10px,\n                rgba(0,255,0,.3) 20px,\n                rgba(0,0,255,.3) 20px,\n                rgba(0,0,255,.3) 30px,\n                rgba(100,100,0,.3) 30px,\n                rgba(100,100,0,.3) 40px\n            );\n    }\n</style>\n<div class=\"css-background-demo1\"></div>\n<style>\n    .css-background-demo2 {\n        width: 300px;\n        height: 200px;\n\n        background-image:\n            radial-gradient(\n                transparent 50%,\n                rgba(0,255,0,.5) 50%,\n                rgba(0,255,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 50%,\n                rgba(255,0,0,.5) 50%,\n                rgba(255,0,0,.5) 60%,\n                transparent 60%),\n            radial-gradient(\n                transparent 80%,\n                rgba(0,0,255,.5) 80%,\n                rgba(0,0,255,.5) 90%,\n                transparent 90%);\n        background-size: 40px 40px;\n        background-position: 0 0, 20px 20px, 20px 40px;\n    }\n</style>\n<div class=\"css-background-demo2\"></div>\n"},{"layout":"false","_content":"<style type=\"text/css\">\n    @keyframes ants {\n        to {\n            background-position: 100%;\n        }\n    }\n    .marching-ants-borders {\n        width: 10em;\n        height: 10em;\n        margin: 2em 0;\n\n        border: 1px solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, #000 0, #000 25%, #fff 0, #fff 50%) 0 / .6em .6em;\n        animation: ants 12s linear infinite;\n    }\n</style>\n<div class=\"marching-ants-borders\"></div>","source":"demos/marching ants borders.html","raw":"---\nlayout: false\n---\n<style type=\"text/css\">\n    @keyframes ants {\n        to {\n            background-position: 100%;\n        }\n    }\n    .marching-ants-borders {\n        width: 10em;\n        height: 10em;\n        margin: 2em 0;\n\n        border: 1px solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, #000 0, #000 25%, #fff 0, #fff 50%) 0 / .6em .6em;\n        animation: ants 12s linear infinite;\n    }\n</style>\n<div class=\"marching-ants-borders\"></div>","date":"2016-06-09T03:50:18.000Z","updated":"2016-06-09T03:50:18.000Z","path":"demos/marching ants borders.html","_id":"cip7rn9eb000b1u076flexcmq","title":"","comments":1,"content":"<style type=\"text/css\">\n    @keyframes ants {\n        to {\n            background-position: 100%;\n        }\n    }\n    .marching-ants-borders {\n        width: 10em;\n        height: 10em;\n        margin: 2em 0;\n\n        border: 1px solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, #000 0, #000 25%, #fff 0, #fff 50%) 0 / .6em .6em;\n        animation: ants 12s linear infinite;\n    }\n</style>\n<div class=\"marching-ants-borders\"></div>","excerpt":"","more":"<style type=\"text/css\">\n    @keyframes ants {\n        to {\n            background-position: 100%;\n        }\n    }\n    .marching-ants-borders {\n        width: 10em;\n        height: 10em;\n        margin: 2em 0;\n\n        border: 1px solid transparent;\n        background: linear-gradient(white, white) padding-box,\n            repeating-linear-gradient(-45deg, #000 0, #000 25%, #fff 0, #fff 50%) 0 / .6em .6em;\n        animation: ants 12s linear infinite;\n    }\n</style>\n<div class=\"marching-ants-borders\"></div>"}],"Post":[{"title":"CSS border-image","date":"2015-08-26T16:00:00.000Z","_content":"\n{% iframe /demos/border-image.html 100% 336 %}\n\n上面示例的 css 代码为：\n<!-- more -->\n\n```css\n.demo1 {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n```\n\nCSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分：\n\n* 1、图片来源。即示例中的 `url(/images/8.jpg)` ；\n* 2、图片裁剪尺寸。即示例中的 `60 70`。裁剪尺寸遵循 `top-right-bottom-left` 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中`60 70`的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的；\n* 3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。\n\n`-webkit-border-image` 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：\n\n{% iframe /demos/-webkit-border-image.html 100% 336 %}\n\n","source":"_posts/CSS border-image.md","raw":"---\ntitle: CSS border-image\ndate: 2015-08-27\n---\n\n{% iframe /demos/border-image.html 100% 336 %}\n\n上面示例的 css 代码为：\n<!-- more -->\n\n```css\n.demo1 {\n    display: inline-block;\n    width: 400px;\n    height: 200px;\n\n    border-width: 60px 70px;\n    border-image: url(/images/8.jpg) 60 70 round stretch;\n}\n```\n\nCSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分：\n\n* 1、图片来源。即示例中的 `url(/images/8.jpg)` ；\n* 2、图片裁剪尺寸。即示例中的 `60 70`。裁剪尺寸遵循 `top-right-bottom-left` 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中`60 70`的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的；\n* 3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。\n\n`-webkit-border-image` 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：\n\n{% iframe /demos/-webkit-border-image.html 100% 336 %}\n\n","slug":"CSS border-image","published":1,"updated":"2016-06-09T03:45:24.000Z","_id":"cip6tknd80000n4073s9mwqu1","comments":1,"layout":"post","photos":[],"link":"","content":"<iframe src=\"/demos/border-image.html\" width=\"100%\" height=\"336\" frameborder=\"0\" allowfullscreen></iframe>\n<p>上面示例的 css 代码为：<br><a id=\"more\"></a></p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">border-width</span>: <span class=\"number\">60px</span> <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-image</span>: <span class=\"built_in\">url</span>(/images/8.jpg) <span class=\"number\">60</span> <span class=\"number\">70</span> round stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分：</p>\n<ul>\n<li>1、图片来源。即示例中的 <code>url(/images/8.jpg)</code> ；</li>\n<li>2、图片裁剪尺寸。即示例中的 <code>60 70</code>。裁剪尺寸遵循 <code>top-right-bottom-left</code> 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中<code>60 70</code>的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的；</li>\n<li>3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。</li>\n</ul>\n<p><code>-webkit-border-image</code> 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：</p>\n<iframe src=\"/demos/-webkit-border-image.html\" width=\"100%\" height=\"336\" frameborder=\"0\" allowfullscreen></iframe>\n","excerpt":"<iframe src=\"/demos/border-image.html\" width=\"100%\" height=\"336\" frameborder=\"0\" allowfullscreen></iframe>\n<p>上面示例的 css 代码为：<br>","more":"</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">400px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">border-width</span>: <span class=\"number\">60px</span> <span class=\"number\">70px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-image</span>: <span class=\"built_in\">url</span>(/images/8.jpg) <span class=\"number\">60</span> <span class=\"number\">70</span> round stretch;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分：</p>\n<ul>\n<li>1、图片来源。即示例中的 <code>url(/images/8.jpg)</code> ；</li>\n<li>2、图片裁剪尺寸。即示例中的 <code>60 70</code>。裁剪尺寸遵循 <code>top-right-bottom-left</code> 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中<code>60 70</code>的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的；</li>\n<li>3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。</li>\n</ul>\n<p><code>-webkit-border-image</code> 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：</p>\n<iframe src=\"/demos/-webkit-border-image.html\" width=\"100%\" height=\"336\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"CSS 变形","date":"2015-08-31T16:00:00.000Z","_content":"\n## 2D\n\n2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。\n<!-- more -->\n\n### skew() 函数\n\n示例：\n\n{% iframe /demos/css%20skew.html 100% 320 %}\n\n下图描述了`skew(30deg, 10deg)`的工作原理：\n\n![](/images/10.jpg)\n\n> **注：**上图来自 [http://dtop.powereasy.net/Item/3715.aspx](http://dtop.powereasy.net/Item/3715.aspx) 。\n\n### transform-origin\n\ntransform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。\n\n但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如：\n\n{% iframe /demos/transform-origin.html 100% 440 %}\n\n`示例1`和`示例2`中的虚线框是元素的原始位置，实线框是位移之后的位置。`示例1`的 transform-origin 是`50% 50%`，而`示例2`是`100% 100%`，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。\n\n## 3D\n\n3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。\n\n### transform-style\n\ntransform-style 的取值为 `flat` 或者 `preserve-3d` 。下面的例子展示了两者的差别：\n\n{% iframe /demos/transform-style.html 100% 416 %}\n\n从示例中可以看出， `preserve-3d` 会让子元素在父元素变形的基础上继续变形，而 `flat` 则会消除父元素变形对子元素变形带来的影响。\n\n__理解：__\n\n对于第一种 `div.container1` 元素的 transform-style 为 `flat` 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 `div.container1` 元素的 transform-style 为 `preserve-3d` 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 `div.container1` 为基准的平面做变形。\n","source":"_posts/CSS 变形.md","raw":"---\ntitle: CSS 变形\ndate: 2015-09-01\n---\n\n## 2D\n\n2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。\n<!-- more -->\n\n### skew() 函数\n\n示例：\n\n{% iframe /demos/css%20skew.html 100% 320 %}\n\n下图描述了`skew(30deg, 10deg)`的工作原理：\n\n![](/images/10.jpg)\n\n> **注：**上图来自 [http://dtop.powereasy.net/Item/3715.aspx](http://dtop.powereasy.net/Item/3715.aspx) 。\n\n### transform-origin\n\ntransform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。\n\n但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如：\n\n{% iframe /demos/transform-origin.html 100% 440 %}\n\n`示例1`和`示例2`中的虚线框是元素的原始位置，实线框是位移之后的位置。`示例1`的 transform-origin 是`50% 50%`，而`示例2`是`100% 100%`，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。\n\n## 3D\n\n3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。\n\n### transform-style\n\ntransform-style 的取值为 `flat` 或者 `preserve-3d` 。下面的例子展示了两者的差别：\n\n{% iframe /demos/transform-style.html 100% 416 %}\n\n从示例中可以看出， `preserve-3d` 会让子元素在父元素变形的基础上继续变形，而 `flat` 则会消除父元素变形对子元素变形带来的影响。\n\n__理解：__\n\n对于第一种 `div.container1` 元素的 transform-style 为 `flat` 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 `div.container1` 元素的 transform-style 为 `preserve-3d` 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 `div.container1` 为基准的平面做变形。\n","slug":"CSS 变形","published":1,"updated":"2016-06-09T03:31:10.000Z","_id":"cip6tkndd0001n4072bom9ty1","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"2D\"><a href=\"#2D\" class=\"headerlink\" title=\"2D\"></a>2D</h2><p>2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。<br><a id=\"more\"></a></p>\n<h3 id=\"skew-函数\"><a href=\"#skew-函数\" class=\"headerlink\" title=\"skew() 函数\"></a>skew() 函数</h3><p>示例：</p>\n<iframe src=\"/demos/css%20skew.html\" width=\"100%\" height=\"320\" frameborder=\"0\" allowfullscreen></iframe>\n<p>下图描述了<code>skew(30deg, 10deg)</code>的工作原理：</p>\n<p><img src=\"/images/10.jpg\" alt=\"\"></p>\n<blockquote>\n<p><strong>注：</strong>上图来自 <a href=\"http://dtop.powereasy.net/Item/3715.aspx\" target=\"_blank\" rel=\"external\">http://dtop.powereasy.net/Item/3715.aspx</a> 。</p>\n</blockquote>\n<h3 id=\"transform-origin\"><a href=\"#transform-origin\" class=\"headerlink\" title=\"transform-origin\"></a>transform-origin</h3><p>transform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。</p>\n<p>但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如：</p>\n<iframe src=\"/demos/transform-origin.html\" width=\"100%\" height=\"440\" frameborder=\"0\" allowfullscreen></iframe>\n<p><code>示例1</code>和<code>示例2</code>中的虚线框是元素的原始位置，实线框是位移之后的位置。<code>示例1</code>的 transform-origin 是<code>50% 50%</code>，而<code>示例2</code>是<code>100% 100%</code>，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。</p>\n<h2 id=\"3D\"><a href=\"#3D\" class=\"headerlink\" title=\"3D\"></a>3D</h2><p>3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。</p>\n<h3 id=\"transform-style\"><a href=\"#transform-style\" class=\"headerlink\" title=\"transform-style\"></a>transform-style</h3><p>transform-style 的取值为 <code>flat</code> 或者 <code>preserve-3d</code> 。下面的例子展示了两者的差别：</p>\n<iframe src=\"/demos/transform-style.html\" width=\"100%\" height=\"416\" frameborder=\"0\" allowfullscreen></iframe>\n<p>从示例中可以看出， <code>preserve-3d</code> 会让子元素在父元素变形的基础上继续变形，而 <code>flat</code> 则会消除父元素变形对子元素变形带来的影响。</p>\n<p><strong>理解：</strong></p>\n<p>对于第一种 <code>div.container1</code> 元素的 transform-style 为 <code>flat</code> 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 <code>div.container1</code> 元素的 transform-style 为 <code>preserve-3d</code> 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 <code>div.container1</code> 为基准的平面做变形。</p>\n","excerpt":"<h2 id=\"2D\"><a href=\"#2D\" class=\"headerlink\" title=\"2D\"></a>2D</h2><p>2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。<br>","more":"</p>\n<h3 id=\"skew-函数\"><a href=\"#skew-函数\" class=\"headerlink\" title=\"skew() 函数\"></a>skew() 函数</h3><p>示例：</p>\n<iframe src=\"/demos/css%20skew.html\" width=\"100%\" height=\"320\" frameborder=\"0\" allowfullscreen></iframe>\n<p>下图描述了<code>skew(30deg, 10deg)</code>的工作原理：</p>\n<p><img src=\"/images/10.jpg\" alt=\"\"></p>\n<blockquote>\n<p><strong>注：</strong>上图来自 <a href=\"http://dtop.powereasy.net/Item/3715.aspx\">http://dtop.powereasy.net/Item/3715.aspx</a> 。</p>\n</blockquote>\n<h3 id=\"transform-origin\"><a href=\"#transform-origin\" class=\"headerlink\" title=\"transform-origin\"></a>transform-origin</h3><p>transform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。</p>\n<p>但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如：</p>\n<iframe src=\"/demos/transform-origin.html\" width=\"100%\" height=\"440\" frameborder=\"0\" allowfullscreen></iframe>\n<p><code>示例1</code>和<code>示例2</code>中的虚线框是元素的原始位置，实线框是位移之后的位置。<code>示例1</code>的 transform-origin 是<code>50% 50%</code>，而<code>示例2</code>是<code>100% 100%</code>，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。</p>\n<h2 id=\"3D\"><a href=\"#3D\" class=\"headerlink\" title=\"3D\"></a>3D</h2><p>3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。</p>\n<h3 id=\"transform-style\"><a href=\"#transform-style\" class=\"headerlink\" title=\"transform-style\"></a>transform-style</h3><p>transform-style 的取值为 <code>flat</code> 或者 <code>preserve-3d</code> 。下面的例子展示了两者的差别：</p>\n<iframe src=\"/demos/transform-style.html\" width=\"100%\" height=\"416\" frameborder=\"0\" allowfullscreen></iframe>\n<p>从示例中可以看出， <code>preserve-3d</code> 会让子元素在父元素变形的基础上继续变形，而 <code>flat</code> 则会消除父元素变形对子元素变形带来的影响。</p>\n<p><strong>理解：</strong></p>\n<p>对于第一种 <code>div.container1</code> 元素的 transform-style 为 <code>flat</code> 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 <code>div.container1</code> 元素的 transform-style 为 <code>preserve-3d</code> 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 <code>div.container1</code> 为基准的平面做变形。</p>"},{"title":"CSS 空心字","date":"2015-09-01T16:00:00.000Z","_content":"\n空心字。\n<!-- more -->\n\n### 闪烁的空心字\n\n{% iframe /demos/空心字1.html 100% 96 %}\n\n### 带背景渐变的空心字\n\n{% iframe /demos/空心字2.html 100% 91 %}\n\ntext-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。","source":"_posts/CSS 空心字.md","raw":"---\ntitle: CSS 空心字\ndate: 2015-09-02\n---\n\n空心字。\n<!-- more -->\n\n### 闪烁的空心字\n\n{% iframe /demos/空心字1.html 100% 96 %}\n\n### 带背景渐变的空心字\n\n{% iframe /demos/空心字2.html 100% 91 %}\n\ntext-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。","slug":"CSS 空心字","published":1,"updated":"2016-06-09T03:37:08.000Z","_id":"cip6tkndf0002n407vgauo8zi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>空心字。<br><a id=\"more\"></a></p>\n<h3 id=\"闪烁的空心字\"><a href=\"#闪烁的空心字\" class=\"headerlink\" title=\"闪烁的空心字\"></a>闪烁的空心字</h3><iframe src=\"/demos/空心字1.html\" width=\"100%\" height=\"96\" frameborder=\"0\" allowfullscreen></iframe>\n<h3 id=\"带背景渐变的空心字\"><a href=\"#带背景渐变的空心字\" class=\"headerlink\" title=\"带背景渐变的空心字\"></a>带背景渐变的空心字</h3><iframe src=\"/demos/空心字2.html\" width=\"100%\" height=\"91\" frameborder=\"0\" allowfullscreen></iframe>\n<p>text-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。</p>\n","excerpt":"<p>空心字。<br>","more":"</p>\n<h3 id=\"闪烁的空心字\"><a href=\"#闪烁的空心字\" class=\"headerlink\" title=\"闪烁的空心字\"></a>闪烁的空心字</h3><iframe src=\"/demos/空心字1.html\" width=\"100%\" height=\"96\" frameborder=\"0\" allowfullscreen></iframe>\n<h3 id=\"带背景渐变的空心字\"><a href=\"#带背景渐变的空心字\" class=\"headerlink\" title=\"带背景渐变的空心字\"></a>带背景渐变的空心字</h3><iframe src=\"/demos/空心字2.html\" width=\"100%\" height=\"91\" frameborder=\"0\" allowfullscreen></iframe>\n<p>text-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。</p>"},{"title":"CSS border-radius","date":"2015-08-26T16:00:00.000Z","_content":"\n`border-radius` 的取值：\n<!-- more -->\n\n> [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?\n\n{% iframe /demos/border-radius.html 100% 116 %}\n\n上述示例的 CSS 代码为：\n\nborder-radius 是可以通过`/`的形式来对某一个角设置一个椭圆弧的。\n\n比如示例中的 `20px/5px` 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。\n\n如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。\n\n对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。\n\n当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。\n\nborder-radius 可以做的效果：圆形、半圆、扇形、椭圆。\n\n{% iframe /demos/half%20ellipse.html 100% 116 %}","source":"_posts/CSS border-radius.md","raw":"---\ntitle: CSS border-radius\ndate: 2015-08-27\n---\n\n`border-radius` 的取值：\n<!-- more -->\n\n> [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?\n\n{% iframe /demos/border-radius.html 100% 116 %}\n\n上述示例的 CSS 代码为：\n\nborder-radius 是可以通过`/`的形式来对某一个角设置一个椭圆弧的。\n\n比如示例中的 `20px/5px` 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。\n\n如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。\n\n对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。\n\n当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。\n\nborder-radius 可以做的效果：圆形、半圆、扇形、椭圆。\n\n{% iframe /demos/half%20ellipse.html 100% 116 %}","slug":"CSS border-radius","published":1,"updated":"2016-06-09T03:41:07.000Z","_id":"cip6tkndh0003n407qtduu3he","comments":1,"layout":"post","photos":[],"link":"","content":"<p><code>border-radius</code> 的取值：<br><a id=\"more\"></a></p>\n<blockquote>\n<p>[ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?</p>\n</blockquote>\n<iframe src=\"/demos/border-radius.html\" width=\"100%\" height=\"116\" frameborder=\"0\" allowfullscreen></iframe>\n<p>上述示例的 CSS 代码为：</p>\n<p>border-radius 是可以通过<code>/</code>的形式来对某一个角设置一个椭圆弧的。</p>\n<p>比如示例中的 <code>20px/5px</code> 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。</p>\n<p>如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。</p>\n<p>对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。</p>\n<p>当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。</p>\n<p>border-radius 可以做的效果：圆形、半圆、扇形、椭圆。</p>\n<iframe src=\"/demos/half%20ellipse.html\" width=\"100%\" height=\"116\" frameborder=\"0\" allowfullscreen></iframe>","excerpt":"<p><code>border-radius</code> 的取值：<br>","more":"</p>\n<blockquote>\n<p>[ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?</p>\n</blockquote>\n<iframe src=\"/demos/border-radius.html\" width=\"100%\" height=\"116\" frameborder=\"0\" allowfullscreen></iframe>\n<p>上述示例的 CSS 代码为：</p>\n<p>border-radius 是可以通过<code>/</code>的形式来对某一个角设置一个椭圆弧的。</p>\n<p>比如示例中的 <code>20px/5px</code> 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。</p>\n<p>如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。</p>\n<p>对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。</p>\n<p>当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。</p>\n<p>border-radius 可以做的效果：圆形、半圆、扇形、椭圆。</p>\n<iframe src=\"/demos/half%20ellipse.html\" width=\"100%\" height=\"116\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"CSS 语法速查","date":"2015-09-03T11:06:00.000Z","_content":"\n<!-- more -->\n### [background](http://www.w3.org/TR/css3-background/)\n\n```\n[ <bg-layer> , ]* <final-bg-layer>\n\n    <bg-layer> = <bg-image> || <position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\n    <final-bg-layer> = <bg-image> || <position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box> || <'background-color'>\n\n        <bg-image> = <image> | none\n```\n\n[&lt;image&gt;](http://www.w3.org/TR/css3-background/#ltimagegt)\n[&lt;position&gt;](http://www.w3.org/TR/css3-background/#ltpositiongt)\n[&lt;bg-size&gt;](http://www.w3.org/TR/css3-background/#ltbg-sizegt)\n[&lt;repeat-style&gt;](http://www.w3.org/TR/css3-background/#ltrepeat-stylegt)\n[&lt;attachment&gt;](http://www.w3.org/TR/css3-background/#ltattachmentgt)\n[&lt;box&gt;](http://www.w3.org/TR/css3-background/#ltboxgt)\n\n### [radial-gradient()](http://www.w3.org/TR/2012/CR-css3-images-20120417/#radial-gradients)\n\n```\n<radial-gradient> = radial-gradient(\n  [ [ <shape> || <size> ] [ at <position> ]? , |\n    at <position>, \n  ]?\n  <color-stop> [ , <color-stop> ]+\n)\n\n    <shape> = circle || ellipse\n```","source":"_posts/CSS 语法速查.md","raw":"---\ntitle: CSS 语法速查\ndate: 2015-09-03 19:06\n---\n\n<!-- more -->\n### [background](http://www.w3.org/TR/css3-background/)\n\n```\n[ <bg-layer> , ]* <final-bg-layer>\n\n    <bg-layer> = <bg-image> || <position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>\n    <final-bg-layer> = <bg-image> || <position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box> || <'background-color'>\n\n        <bg-image> = <image> | none\n```\n\n[&lt;image&gt;](http://www.w3.org/TR/css3-background/#ltimagegt)\n[&lt;position&gt;](http://www.w3.org/TR/css3-background/#ltpositiongt)\n[&lt;bg-size&gt;](http://www.w3.org/TR/css3-background/#ltbg-sizegt)\n[&lt;repeat-style&gt;](http://www.w3.org/TR/css3-background/#ltrepeat-stylegt)\n[&lt;attachment&gt;](http://www.w3.org/TR/css3-background/#ltattachmentgt)\n[&lt;box&gt;](http://www.w3.org/TR/css3-background/#ltboxgt)\n\n### [radial-gradient()](http://www.w3.org/TR/2012/CR-css3-images-20120417/#radial-gradients)\n\n```\n<radial-gradient> = radial-gradient(\n  [ [ <shape> || <size> ] [ at <position> ]? , |\n    at <position>, \n  ]?\n  <color-stop> [ , <color-stop> ]+\n)\n\n    <shape> = circle || ellipse\n```","slug":"CSS 语法速查","published":1,"updated":"2016-06-08T09:54:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndi0004n407wbaswd1w","content":"<a id=\"more\"></a>\n<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a><a href=\"http://www.w3.org/TR/css3-background/\" target=\"_blank\" rel=\"external\">background</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ &lt;bg-layer&gt; , ]* &lt;final-bg-layer&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt;</span><br><span class=\"line\">    &lt;final-bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; || &lt;&apos;background-color&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;bg-image&gt; = &lt;image&gt; | none</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.w3.org/TR/css3-background/#ltimagegt\" target=\"_blank\" rel=\"external\">&lt;image&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltpositiongt\" target=\"_blank\" rel=\"external\">&lt;position&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltbg-sizegt\" target=\"_blank\" rel=\"external\">&lt;bg-size&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltrepeat-stylegt\" target=\"_blank\" rel=\"external\">&lt;repeat-style&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltattachmentgt\" target=\"_blank\" rel=\"external\">&lt;attachment&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltboxgt\" target=\"_blank\" rel=\"external\">&lt;box&gt;</a></p>\n<h3 id=\"radial-gradient\"><a href=\"#radial-gradient\" class=\"headerlink\" title=\"radial-gradient()\"></a><a href=\"http://www.w3.org/TR/2012/CR-css3-images-20120417/#radial-gradients\" target=\"_blank\" rel=\"external\">radial-gradient()</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;radial-gradient&gt; = radial-gradient(</span><br><span class=\"line\">  [ [ &lt;shape&gt; || &lt;size&gt; ] [ at &lt;position&gt; ]? , |</span><br><span class=\"line\">    at &lt;position&gt;, </span><br><span class=\"line\">  ]?</span><br><span class=\"line\">  &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;shape&gt; = circle || ellipse</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<h3 id=\"background\"><a href=\"#background\" class=\"headerlink\" title=\"background\"></a><a href=\"http://www.w3.org/TR/css3-background/\">background</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ &lt;bg-layer&gt; , ]* &lt;final-bg-layer&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt;</span><br><span class=\"line\">    &lt;final-bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; || &lt;&apos;background-color&apos;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;bg-image&gt; = &lt;image&gt; | none</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://www.w3.org/TR/css3-background/#ltimagegt\">&lt;image&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltpositiongt\">&lt;position&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltbg-sizegt\">&lt;bg-size&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltrepeat-stylegt\">&lt;repeat-style&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltattachmentgt\">&lt;attachment&gt;</a><br><a href=\"http://www.w3.org/TR/css3-background/#ltboxgt\">&lt;box&gt;</a></p>\n<h3 id=\"radial-gradient\"><a href=\"#radial-gradient\" class=\"headerlink\" title=\"radial-gradient()\"></a><a href=\"http://www.w3.org/TR/2012/CR-css3-images-20120417/#radial-gradients\">radial-gradient()</a></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;radial-gradient&gt; = radial-gradient(</span><br><span class=\"line\">  [ [ &lt;shape&gt; || &lt;size&gt; ] [ at &lt;position&gt; ]? , |</span><br><span class=\"line\">    at &lt;position&gt;, </span><br><span class=\"line\">  ]?</span><br><span class=\"line\">  &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;shape&gt; = circle || ellipse</span><br></pre></td></tr></table></figure>"},{"title":"ES6 简单特性概览","date":"2015-10-18T03:43:00.000Z","_content":"\n本文内容：\n\n* 讲解了如何使用交互式的方式体验 ES6 。\n* 列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。\n\n<!-- more -->\n\n## 体验 ECMAScript 6\n\n有三种简单的方式可以运行 ES6 代码：\n\n* 1、 Web 浏览器：使用[在线的 Babel REPL ](http://babeljs.io/repl/)，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。\n* 2、命令行：使用 `babel-node` ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。\n* 3、各种 JavaScript 引擎：查询[ kangax 的 ES6 兼容表格](https://kangax.github.io/compat-table/es6/)，可以找到本地支持 ES6 的引擎。\n\n下面将会给出更多关于选项1和2的内容。\n\n### Babel REPL\n\nBabel REPL 有四个主要部分：\n\n* 左上角部分包含 ES6 源码。\n* 左下角部分显示 ES6 代码中发现的语法错误。\n* 右上角部分包含 ES6 代码编译成的 ES5 代码。\n* 右下角部分展示通过 `console.log()` 输出的内容。\n\n![](/images/11.jpg)\n\n### babel-node\n\n`babel-node` 可执行程序可以通过 npm 安装：\n\n```\nnpm install --global babel\n```\n\n你可以像使用可执行程序 `node` 一样使用 `babel-node` 。类似于 `node` ，像这样启动一个交互式的 REPL ：\n\n```\nbabel-node\n```\n\n一旦进入该 REPL ，你就可以执行 ES6 代码了：\n\n```\n> let arr = [1, 2, 3];\n> arr.map(x => x * x)\n[ 1, 4, 9 ]\n```\n\n注意 [babel-node 目前还不支持多行输入](https://github.com/babel/babel/issues/1741)。\n\nBabel 官网有[更多关于 Babel 命令行工具的信息](http://babeljs.io/docs/usage/cli/)。\n\n本文接下来的部分描述了易于接受的 ES6 特性。\n\n## 从 var 到 let/const\n\nES6 有两种新的声明变量的方式：\n\n* `let` （大致）相当于 `var` 的一个块级范围版本。\n* `const` 类似于 `let` ，但是用于创建*常量*：值不能被改变的变量。\n\n一般情况下，你可以用 `let` 或者 `const` 替换每一个 `var` 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子：\n\n```js\nvar x = 3;\nfunction func(randomize) {\n    if (randomize) {\n        var x = Math.random(); // (A) scope: whole function\n        return x;\n    }\n    return x; // accesses the x from line A\n}\nfunc(false); // undefined\n```\n\n`func()` 返回 `undefined` ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了：\n\n```js\nvar x = 3;\nfunction func(randomize) {\n    var x;\n    if (randomize) {\n        x = Math.random();\n        return x;\n    }\n    return x;\n}\nfunc(false); // undefined\n```\n\n如果你在最初的版本中用 `let` 替换 `var` ，将会得到不一样的结果：\n\n```js\nlet x = 3;\nfunction func(randomize) {\n    if (randomize) {\n        let x = Math.random();\n        return x;\n    }\n    return x;\n}\nfunc(false); // 3\n```\n\n因此，盲目地用 `let` 或者 `const` 替换 `var` 很危险。我的建议是：\n\n* 仅在新的代码中使用 `let`/`const` 。\n* 不动老的代码，或者小心地重构老的代码。\n\n## 从 IIFE 到块级作用域\n\n在 ES5 中，你必须使用 IIFE 来使变量保持本地化：\n\n```js\n(function () {  // open IIFE\n    var tmp = ···;\n    ···\n}());  // close IIFE\n\nconsole.log(tmp); // ReferenceError\n```\n\n在 ECMAScript 6 中，你可以简单地使用一个块和一个 `let` 声明：\n\n```js\n{  // open block\n    let tmp = ···;\n    ···\n}  // close block\n\nconsole.log(tmp); // ReferenceError\n```\n\n## 从拼接字符串到模板字面量\n\n在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。\n\n### 字符串插值\n\n在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中：\n\n```js\nfunction printCoord(x, y) {\n    console.log('('+x+', '+y+')');\n}\n```\n\n在 ES6 中，你可以通过模板字面量的方式实现字符串插值：\n\n```js\nfunction printCoord(x, y) {\n    console.log(`(${x}, ${y})`);\n}\n```\n\n### 多行字符串\n\n模板字面量也可以用于表示多行字符串。\n\n例如，下面是在 ES5 中表示多行文本的样子：\n\n```js\nvar HTML5_SKELETON =\n    '<!doctype html>\\n' +\n    '<html>\\n' +\n    '<head>\\n' +\n    '    <meta charset=\"UTF-8\">\\n' +\n    '    <title></title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '</body>\\n' +\n    '</html>\\n';\n```\n\n如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）：\n\n```js\nvar HTML5_SKELETON = '\\\n    <!doctype html>\\n\\\n    <html>\\n\\\n    <head>\\n\\\n        <meta charset=\"UTF-8\">\\n\\\n        <title></title>\\n\\\n    </head>\\n\\\n    <body>\\n\\\n    </body>\\n\\\n    </html>';\n```\n\nES6 模板字面量可以跨越多行：\n\n```js\nconst HTML5_SKELETON = `\n    <!doctype html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title></title>\n    </head>\n    <body>\n    </body>\n    </html>`;\n```\n\n（这些例子包含的空格数是不一样的，但是在此处并不重要。）\n\n## 从函数表达式到箭头函数\n\n在当前的 ES5 代码中，在函数表达式中必须小心使用 `this` 。在下面的例子中，我创建了辅助变量 `_this` （行 A ），以便在行 B 能够访问到 UiComponent 的 `this` 。\n\n```js\nfunction UiComponent {\n    var _this = this; // (A)\n    var button = document.getElementById('myButton');\n    button.addEventListener('click', function () {\n        console.log('CLICK');\n        _this.handleClick(); // (B)\n    });\n}\nUiComponent.prototype.handleClick = function () {\n    ···\n};\n```\n\n在 ES6 中，你可以使用箭头函数，它不会改变 `this` 指向（行 A ，*词法范围的 this* ）：\n\n```js\nclass UiComponent {\n    constructor() {\n        let button = document.getElementById('myButton');\n        button.addEventListener('click', () => {\n            console.log('CLICK');\n            this.handleClick(); // (A)\n        });\n    }\n    handleClick() {\n        ···\n    }\n}\n```\n\n箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。\n\n在 ES5 中，这样的回调函数相当啰嗦：\n\n```js\nvar arr = [1, 2, 3];\nvar squares = arr.map(function (x) { return x * x });\n```\n\n在 ES6 中，箭头函数简洁很多：\n\n```js\nlet arr = [1, 2, 3];\nlet squares = arr.map(x => x * x);\n```\n\n在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： `(x) => x * x` 和 `x => x * x` 都是合法的。\n\n## 处理多个返回值\n\n一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。\n\n### 借助数组返回多个值\n\n`exec()` 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 `matchObj` ），即便是你仅对匹配组感兴趣：\n\n```js\nvar matchObj =\n    /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\n    .exec('2999-12-31');\nvar year = matchObj[1];\nvar month = matchObj[2];\nvar day = matchObj[3];\n```\n\n在 ES6 中，解构使代码更简单：\n\n```js\nlet [, year, month, day] =\n    /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\n    .exec('2999-12-31');\n```\n\n左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。\n\n### 借助对象返回多个值\n\n方法 `Object.getOwnPropertyDescriptor()` 返回一个*属性描述符*，一个包含多个属性值的对象。\n\n在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 `propDesc` ）：\n\n```js\nvar obj = { foo: 123 };\n\nvar propDesc = Object.getOwnPropertyDescriptor(obj, 'foo');\nvar writable = propDesc.writable;\nvar configurable = propDesc.configurable;\n\nconsole.log(writable, configurable); // true true\n```\n\n在 ES6 中，可以使用解构：\n\n```js\nlet obj = { foo: 123 };\n\nlet {writable, configurable} =\n    Object.getOwnPropertyDescriptor(obj, 'foo');\n\nconsole.log(writable, configurable); // true true\n```\n\n`{writable, configurable}` 是下面内容的缩写：\n\n```js\n{ writable: writable, configurable: configurable }\n```\n\n## 从 for 到 forEach() ，再到 for-of\n\n在 ES5 之前，可以选择使用数组方法 `forEach()` ：\n\n```js\narr.forEach(function (elem) {\n    console.log(elem);\n});\n```\n\n`for` 循环的优点在于可以中断， `forEach()` 的优点在于简洁。\n\n在 ES6 中， `for-of` 循环结合了两种优点：\n\n```js\nlet arr = ['a', 'b', 'c'];\nfor (let elem of arr) {\n    console.log(elem);\n}\n```\n\n如果想访问每个元素的索引和值， `for-of` 也可以做到，通过新的数组方法 `entries()` 和解构：\n\n```js\nfor (let [index, elem] of arr.entries()) {\n    console.log(index+'. '+elem);\n}\n```\n\n## 处理参数默认值\n\n在 ES5 中，为参数指定默认值的代码像这样：\n\n```js\nfunction foo(x, y) {\n    x = x || 0;\n    y = y || 0;\n    ···\n}\n```\n\nES6 有更漂亮的语法：\n\n```js\nfunction foo(x=0, y=0) {\n    ···\n}\n```\n\n一个额外的好处就是，在 ES6 中，参数默认值只会被 `undefined` 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。\n\n## 处理命名参数\n\n在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的*可选对象模式*）：\n\n```js\nselectEntries({ start: 0, end: -1 });\n```\n\n这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。\n\n在 ES5 中，你可以这样实现 `selectEntries()` ：\n\n```js\nfunction selectEntries(options) {\n    var start = options.start || 0;\n    var end = options.end || -1;\n    var step = options.step || 1;\n    ···\n}\n```\n\n在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了：\n\n```js\nfunction selectEntries({ start=0, end=-1, step=1 }) {\n    ···\n}\n```\n\n### 可选参数\n\n在 ES5 中，要让参数 `options` 变得可选，会添加行 A 所示的代码：\n\n```js\nfunction selectEntries(options) {\n    options = options || {}; // (A)\n    var start = options.start || 0;\n    var end = options.end || -1;\n    var step = options.step || 1;\n    ···\n}\n```\n\n在 ES6 中，可以用 `{}` 指定参数的默认值：\n\n```js\nfunction selectEntries({ start=0, end=-1, step=1 } = {}) {\n    ···\n}\n```\n\n## 从 arguments 到剩余参数\n\n在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 `arguments` ：\n\n```js\nfunction logAllArguments() {\n    for (var i=0; i < arguments.length; i++) {\n        console.log(arguments[i]);\n    }\n}\n```\n\n在 ES6 中，可以通过 `...` 操作符声明一个剩余参数（下例中的 args ）：\n\n```js\nfunction logAllArguments(...args) {\n    for (let arg of args) {\n        console.log(arg);\n    }\n}\n```\n\n如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了：\n\n```js\nfunction format(pattern, ...args) {\n    ···\n}\n```\n\n在 ES5 中处理这种场景很笨拙：\n\n```js\nfunction format() {\n    var pattern = arguments[0];\n    var args = arguments.slice(1);\n    ···\n}\n```\n\n剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。\n\n## 从 apply() 到扩展操作符（ ... ）\n\n在 ES5 中，用 `apply()` 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。\n\n### 4.11.1 Math.max()\n\nES5 - apply() ：\n\n```\n> Math.max.apply(null, [-1, 5, 11, 3])\n11\n```\n\nES6 - 扩展操作符：\n\n```\n> Math.max(...[-1, 5, 11, 3])\n11\n```\n\n### Array.prototype.push()\n\nES5 - apply() ：\n\n```js\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c', 'd'];\n\narr1.push.apply(arr1, arr2);\n    // arr1 is now ['a', 'b', 'c', 'd']\n```\n\nES6 - 扩展操作符：\n\nlet arr1 = ['a', 'b'];\nlet arr2 = ['c', 'd'];\n\narr1.push(...arr2);\n    // arr1 is now ['a', 'b', 'c', 'd']\n\n## 从 concat() 到扩展操作符（ ... ）\n\n扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 `concat()` 的功能。\n\nES5 - concat() ：\n\n```js\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n\nconsole.log(arr1.concat(arr2, arr3));\n    // [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\nES6 - 扩展操作符：\n\n```js\nlet arr1 = ['a', 'b'];\nlet arr2 = ['c'];\nlet arr3 = ['d', 'e'];\n\nconsole.log([...arr1, ...arr2, ...arr3]);\n    // [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\n## 从构造函数到类\n\n相对于构造函数来说，ES6 类是一种更加方便的语法。\n\n### 基类\n\n在 ES5 中，直接实现构造函数：\n\n```js\nfunction Person(name) {\n    this.name = name;\n}\nPerson.prototype.describe = function () {\n    return 'Person called '+this.name;\n};\n```\n\n在 ES6 中，类为构造函数提供了略微方便的语法：\n\n```js\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    describe() {\n        return 'Person called '+this.name;\n    }\n}\n```\n\n### 继承类\n\n在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 `Person` 的子构造器 `Employee` 的方式：\n\n```js\nfunction Employee(name, title) {\n    Person.call(this, name); // super(name)\n    this.title = title;\n}\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\nEmployee.prototype.describe = function () {\n    return Person.prototype.describe.call(this) // super.describe()\n           + ' (' + this.title + ')';\n};\n```\n\nES6 内置支持子类继承，使用 extends 子句：\n\n```js\nclass Employee extends Person {\n    constructor(name, title) {\n        super(name);\n        this.title = title;\n    }\n    describe() {\n        return super.describe() + ' (' + this.title + ')';\n    }\n}\n```\n\n## 从自定义错误构造函数到 Error 子类\n\n在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪：\n\n```js\nfunction MyError() {\n    // Use Error as a function\n    var superInstance = Error.apply(null, arguments);\n    copyOwnPropertiesFrom(this, superInstance);\n}\nMyError.prototype = Object.create(Error.prototype);\nMyError.prototype.constructor = MyError;\n```\n\n在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能：\n\n```js\nclass MyError extends Error {\n}\n```\n\n## 从对象字面量中的函数表达式到方法定义\n\n在 JavaScript 中，方法就是值为函数的属性。\n\n在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。\n\n```js\nvar obj = {\n    foo: function () {\n        ···\n    },\n    bar: function () {\n        this.foo();\n    }, // trailing comma is legal in ES5\n}\n```\n\nES6 有*方法定义*，一种创建方法的特殊语法：\n\n```js\nlet obj = {\n    foo() {\n        ···\n    },\n    bar() {\n        this.foo();\n    },\n}\n```\n\n## 从对象到 Map\n\n把语言结构 *object* 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 `__proto__` ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。\n\n下面的 ES5 代码包含了函数 `countWords` ，该函数将对象 `dict` 用作一个 map ：\n\n```js\nvar dict = Object.create(null);\nfunction countWords(word) {\n    var escapedWord = escapeKey(word);\n    if (escapedWord in dict) {\n        dict[escapedWord]++;\n    } else {\n        dict[escapedWord] = 1;\n    }\n}\nfunction escapeKey(key) {\n    if (key.indexOf('__proto__') === 0) {\n        return key+'%';\n    } else {\n        return key;\n    }\n}\n```\n\n在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。\n\n```js\nlet map = new Map();\nfunction countWords(word) {\n    let count = map.get(word) || 0;\n    map.set(word, count + 1);\n}\n```\n\nmap 的另一个优点是可以用任何值作为键，而不仅仅是字符串。\n\n## 从 CommonJS 模块到 ES6 模块\n\n直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如[暴露的模块方式](http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/)）。\n\nES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。\n\n### 导出多个值\n\n在 CommonJS 里，像下面这样导出多个实体：\n\n```js\n//------ lib.js ------\nvar sqrt = Math.sqrt;\nfunction square(x) {\n    return x * x;\n}\nfunction diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\nmodule.exports = {\n    sqrt: sqrt,\n    square: square,\n    diag: diag,\n};\n\n//------ main1.js ------\nvar square = require('lib').square;\nvar diag = require('lib').diag;\n\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5\n```\n\n相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 `square` 和 `diag` ：\n\n```js\n//------ main2.js ------\nvar lib = require('lib');\nconsole.log(lib.square(11)); // 121\nconsole.log(lib.diag(4, 3)); // 5\n```\n\n在 ES6 中，多个导出值被称为*命名导出*，像这样处理：\n\n```js\n//------ lib.js ------\nexport const sqrt = Math.sqrt;\nexport function square(x) {\n    return x * x;\n}\nexport function diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\n\n//------ main1.js ------\nimport { square, diag } from 'lib';\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5\n```\n\n引入模块为对象的语法就像下面这样（行 A ）：\n\n```js\n//------ main2.js ------\nimport * as lib from 'lib'; // (A)\nconsole.log(lib.square(11)); // 121\nconsole.log(lib.diag(4, 3)); // 5\n```\n\n### 导出一个值\n\nNode.js 使用了 CommonJS 的模块方案，允许通过 `module.exports` 在模块中导出一个值：\n\n```js\n//------ myFunc.js ------\nmodule.exports = function () { ··· };\n\n//------ main1.js ------\nvar myFunc = require('myFunc');\nmyFunc();\n```\n\n在 ES6 中， `export default` 完成同样的功能：\n\n```js\n//------ myFunc.js ------\nexport default function () { ··· } // no semicolon!\n\n//------ main1.js ------\nimport myFunc from 'myFunc';\nmyFunc();\n```\n\n","source":"_posts/ES6 简单特性概览.md","raw":"---\ntitle: ES6 简单特性概览\ndate: 2015-10-18 11:43\n---\n\n本文内容：\n\n* 讲解了如何使用交互式的方式体验 ES6 。\n* 列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。\n\n<!-- more -->\n\n## 体验 ECMAScript 6\n\n有三种简单的方式可以运行 ES6 代码：\n\n* 1、 Web 浏览器：使用[在线的 Babel REPL ](http://babeljs.io/repl/)，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。\n* 2、命令行：使用 `babel-node` ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。\n* 3、各种 JavaScript 引擎：查询[ kangax 的 ES6 兼容表格](https://kangax.github.io/compat-table/es6/)，可以找到本地支持 ES6 的引擎。\n\n下面将会给出更多关于选项1和2的内容。\n\n### Babel REPL\n\nBabel REPL 有四个主要部分：\n\n* 左上角部分包含 ES6 源码。\n* 左下角部分显示 ES6 代码中发现的语法错误。\n* 右上角部分包含 ES6 代码编译成的 ES5 代码。\n* 右下角部分展示通过 `console.log()` 输出的内容。\n\n![](/images/11.jpg)\n\n### babel-node\n\n`babel-node` 可执行程序可以通过 npm 安装：\n\n```\nnpm install --global babel\n```\n\n你可以像使用可执行程序 `node` 一样使用 `babel-node` 。类似于 `node` ，像这样启动一个交互式的 REPL ：\n\n```\nbabel-node\n```\n\n一旦进入该 REPL ，你就可以执行 ES6 代码了：\n\n```\n> let arr = [1, 2, 3];\n> arr.map(x => x * x)\n[ 1, 4, 9 ]\n```\n\n注意 [babel-node 目前还不支持多行输入](https://github.com/babel/babel/issues/1741)。\n\nBabel 官网有[更多关于 Babel 命令行工具的信息](http://babeljs.io/docs/usage/cli/)。\n\n本文接下来的部分描述了易于接受的 ES6 特性。\n\n## 从 var 到 let/const\n\nES6 有两种新的声明变量的方式：\n\n* `let` （大致）相当于 `var` 的一个块级范围版本。\n* `const` 类似于 `let` ，但是用于创建*常量*：值不能被改变的变量。\n\n一般情况下，你可以用 `let` 或者 `const` 替换每一个 `var` 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子：\n\n```js\nvar x = 3;\nfunction func(randomize) {\n    if (randomize) {\n        var x = Math.random(); // (A) scope: whole function\n        return x;\n    }\n    return x; // accesses the x from line A\n}\nfunc(false); // undefined\n```\n\n`func()` 返回 `undefined` ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了：\n\n```js\nvar x = 3;\nfunction func(randomize) {\n    var x;\n    if (randomize) {\n        x = Math.random();\n        return x;\n    }\n    return x;\n}\nfunc(false); // undefined\n```\n\n如果你在最初的版本中用 `let` 替换 `var` ，将会得到不一样的结果：\n\n```js\nlet x = 3;\nfunction func(randomize) {\n    if (randomize) {\n        let x = Math.random();\n        return x;\n    }\n    return x;\n}\nfunc(false); // 3\n```\n\n因此，盲目地用 `let` 或者 `const` 替换 `var` 很危险。我的建议是：\n\n* 仅在新的代码中使用 `let`/`const` 。\n* 不动老的代码，或者小心地重构老的代码。\n\n## 从 IIFE 到块级作用域\n\n在 ES5 中，你必须使用 IIFE 来使变量保持本地化：\n\n```js\n(function () {  // open IIFE\n    var tmp = ···;\n    ···\n}());  // close IIFE\n\nconsole.log(tmp); // ReferenceError\n```\n\n在 ECMAScript 6 中，你可以简单地使用一个块和一个 `let` 声明：\n\n```js\n{  // open block\n    let tmp = ···;\n    ···\n}  // close block\n\nconsole.log(tmp); // ReferenceError\n```\n\n## 从拼接字符串到模板字面量\n\n在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。\n\n### 字符串插值\n\n在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中：\n\n```js\nfunction printCoord(x, y) {\n    console.log('('+x+', '+y+')');\n}\n```\n\n在 ES6 中，你可以通过模板字面量的方式实现字符串插值：\n\n```js\nfunction printCoord(x, y) {\n    console.log(`(${x}, ${y})`);\n}\n```\n\n### 多行字符串\n\n模板字面量也可以用于表示多行字符串。\n\n例如，下面是在 ES5 中表示多行文本的样子：\n\n```js\nvar HTML5_SKELETON =\n    '<!doctype html>\\n' +\n    '<html>\\n' +\n    '<head>\\n' +\n    '    <meta charset=\"UTF-8\">\\n' +\n    '    <title></title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '</body>\\n' +\n    '</html>\\n';\n```\n\n如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）：\n\n```js\nvar HTML5_SKELETON = '\\\n    <!doctype html>\\n\\\n    <html>\\n\\\n    <head>\\n\\\n        <meta charset=\"UTF-8\">\\n\\\n        <title></title>\\n\\\n    </head>\\n\\\n    <body>\\n\\\n    </body>\\n\\\n    </html>';\n```\n\nES6 模板字面量可以跨越多行：\n\n```js\nconst HTML5_SKELETON = `\n    <!doctype html>\n    <html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title></title>\n    </head>\n    <body>\n    </body>\n    </html>`;\n```\n\n（这些例子包含的空格数是不一样的，但是在此处并不重要。）\n\n## 从函数表达式到箭头函数\n\n在当前的 ES5 代码中，在函数表达式中必须小心使用 `this` 。在下面的例子中，我创建了辅助变量 `_this` （行 A ），以便在行 B 能够访问到 UiComponent 的 `this` 。\n\n```js\nfunction UiComponent {\n    var _this = this; // (A)\n    var button = document.getElementById('myButton');\n    button.addEventListener('click', function () {\n        console.log('CLICK');\n        _this.handleClick(); // (B)\n    });\n}\nUiComponent.prototype.handleClick = function () {\n    ···\n};\n```\n\n在 ES6 中，你可以使用箭头函数，它不会改变 `this` 指向（行 A ，*词法范围的 this* ）：\n\n```js\nclass UiComponent {\n    constructor() {\n        let button = document.getElementById('myButton');\n        button.addEventListener('click', () => {\n            console.log('CLICK');\n            this.handleClick(); // (A)\n        });\n    }\n    handleClick() {\n        ···\n    }\n}\n```\n\n箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。\n\n在 ES5 中，这样的回调函数相当啰嗦：\n\n```js\nvar arr = [1, 2, 3];\nvar squares = arr.map(function (x) { return x * x });\n```\n\n在 ES6 中，箭头函数简洁很多：\n\n```js\nlet arr = [1, 2, 3];\nlet squares = arr.map(x => x * x);\n```\n\n在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： `(x) => x * x` 和 `x => x * x` 都是合法的。\n\n## 处理多个返回值\n\n一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。\n\n### 借助数组返回多个值\n\n`exec()` 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 `matchObj` ），即便是你仅对匹配组感兴趣：\n\n```js\nvar matchObj =\n    /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\n    .exec('2999-12-31');\nvar year = matchObj[1];\nvar month = matchObj[2];\nvar day = matchObj[3];\n```\n\n在 ES6 中，解构使代码更简单：\n\n```js\nlet [, year, month, day] =\n    /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\n    .exec('2999-12-31');\n```\n\n左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。\n\n### 借助对象返回多个值\n\n方法 `Object.getOwnPropertyDescriptor()` 返回一个*属性描述符*，一个包含多个属性值的对象。\n\n在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 `propDesc` ）：\n\n```js\nvar obj = { foo: 123 };\n\nvar propDesc = Object.getOwnPropertyDescriptor(obj, 'foo');\nvar writable = propDesc.writable;\nvar configurable = propDesc.configurable;\n\nconsole.log(writable, configurable); // true true\n```\n\n在 ES6 中，可以使用解构：\n\n```js\nlet obj = { foo: 123 };\n\nlet {writable, configurable} =\n    Object.getOwnPropertyDescriptor(obj, 'foo');\n\nconsole.log(writable, configurable); // true true\n```\n\n`{writable, configurable}` 是下面内容的缩写：\n\n```js\n{ writable: writable, configurable: configurable }\n```\n\n## 从 for 到 forEach() ，再到 for-of\n\n在 ES5 之前，可以选择使用数组方法 `forEach()` ：\n\n```js\narr.forEach(function (elem) {\n    console.log(elem);\n});\n```\n\n`for` 循环的优点在于可以中断， `forEach()` 的优点在于简洁。\n\n在 ES6 中， `for-of` 循环结合了两种优点：\n\n```js\nlet arr = ['a', 'b', 'c'];\nfor (let elem of arr) {\n    console.log(elem);\n}\n```\n\n如果想访问每个元素的索引和值， `for-of` 也可以做到，通过新的数组方法 `entries()` 和解构：\n\n```js\nfor (let [index, elem] of arr.entries()) {\n    console.log(index+'. '+elem);\n}\n```\n\n## 处理参数默认值\n\n在 ES5 中，为参数指定默认值的代码像这样：\n\n```js\nfunction foo(x, y) {\n    x = x || 0;\n    y = y || 0;\n    ···\n}\n```\n\nES6 有更漂亮的语法：\n\n```js\nfunction foo(x=0, y=0) {\n    ···\n}\n```\n\n一个额外的好处就是，在 ES6 中，参数默认值只会被 `undefined` 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。\n\n## 处理命名参数\n\n在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的*可选对象模式*）：\n\n```js\nselectEntries({ start: 0, end: -1 });\n```\n\n这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。\n\n在 ES5 中，你可以这样实现 `selectEntries()` ：\n\n```js\nfunction selectEntries(options) {\n    var start = options.start || 0;\n    var end = options.end || -1;\n    var step = options.step || 1;\n    ···\n}\n```\n\n在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了：\n\n```js\nfunction selectEntries({ start=0, end=-1, step=1 }) {\n    ···\n}\n```\n\n### 可选参数\n\n在 ES5 中，要让参数 `options` 变得可选，会添加行 A 所示的代码：\n\n```js\nfunction selectEntries(options) {\n    options = options || {}; // (A)\n    var start = options.start || 0;\n    var end = options.end || -1;\n    var step = options.step || 1;\n    ···\n}\n```\n\n在 ES6 中，可以用 `{}` 指定参数的默认值：\n\n```js\nfunction selectEntries({ start=0, end=-1, step=1 } = {}) {\n    ···\n}\n```\n\n## 从 arguments 到剩余参数\n\n在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 `arguments` ：\n\n```js\nfunction logAllArguments() {\n    for (var i=0; i < arguments.length; i++) {\n        console.log(arguments[i]);\n    }\n}\n```\n\n在 ES6 中，可以通过 `...` 操作符声明一个剩余参数（下例中的 args ）：\n\n```js\nfunction logAllArguments(...args) {\n    for (let arg of args) {\n        console.log(arg);\n    }\n}\n```\n\n如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了：\n\n```js\nfunction format(pattern, ...args) {\n    ···\n}\n```\n\n在 ES5 中处理这种场景很笨拙：\n\n```js\nfunction format() {\n    var pattern = arguments[0];\n    var args = arguments.slice(1);\n    ···\n}\n```\n\n剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。\n\n## 从 apply() 到扩展操作符（ ... ）\n\n在 ES5 中，用 `apply()` 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。\n\n### 4.11.1 Math.max()\n\nES5 - apply() ：\n\n```\n> Math.max.apply(null, [-1, 5, 11, 3])\n11\n```\n\nES6 - 扩展操作符：\n\n```\n> Math.max(...[-1, 5, 11, 3])\n11\n```\n\n### Array.prototype.push()\n\nES5 - apply() ：\n\n```js\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c', 'd'];\n\narr1.push.apply(arr1, arr2);\n    // arr1 is now ['a', 'b', 'c', 'd']\n```\n\nES6 - 扩展操作符：\n\nlet arr1 = ['a', 'b'];\nlet arr2 = ['c', 'd'];\n\narr1.push(...arr2);\n    // arr1 is now ['a', 'b', 'c', 'd']\n\n## 从 concat() 到扩展操作符（ ... ）\n\n扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 `concat()` 的功能。\n\nES5 - concat() ：\n\n```js\nvar arr1 = ['a', 'b'];\nvar arr2 = ['c'];\nvar arr3 = ['d', 'e'];\n\nconsole.log(arr1.concat(arr2, arr3));\n    // [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\nES6 - 扩展操作符：\n\n```js\nlet arr1 = ['a', 'b'];\nlet arr2 = ['c'];\nlet arr3 = ['d', 'e'];\n\nconsole.log([...arr1, ...arr2, ...arr3]);\n    // [ 'a', 'b', 'c', 'd', 'e' ]\n```\n\n## 从构造函数到类\n\n相对于构造函数来说，ES6 类是一种更加方便的语法。\n\n### 基类\n\n在 ES5 中，直接实现构造函数：\n\n```js\nfunction Person(name) {\n    this.name = name;\n}\nPerson.prototype.describe = function () {\n    return 'Person called '+this.name;\n};\n```\n\n在 ES6 中，类为构造函数提供了略微方便的语法：\n\n```js\nclass Person {\n    constructor(name) {\n        this.name = name;\n    }\n    describe() {\n        return 'Person called '+this.name;\n    }\n}\n```\n\n### 继承类\n\n在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 `Person` 的子构造器 `Employee` 的方式：\n\n```js\nfunction Employee(name, title) {\n    Person.call(this, name); // super(name)\n    this.title = title;\n}\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\nEmployee.prototype.describe = function () {\n    return Person.prototype.describe.call(this) // super.describe()\n           + ' (' + this.title + ')';\n};\n```\n\nES6 内置支持子类继承，使用 extends 子句：\n\n```js\nclass Employee extends Person {\n    constructor(name, title) {\n        super(name);\n        this.title = title;\n    }\n    describe() {\n        return super.describe() + ' (' + this.title + ')';\n    }\n}\n```\n\n## 从自定义错误构造函数到 Error 子类\n\n在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪：\n\n```js\nfunction MyError() {\n    // Use Error as a function\n    var superInstance = Error.apply(null, arguments);\n    copyOwnPropertiesFrom(this, superInstance);\n}\nMyError.prototype = Object.create(Error.prototype);\nMyError.prototype.constructor = MyError;\n```\n\n在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能：\n\n```js\nclass MyError extends Error {\n}\n```\n\n## 从对象字面量中的函数表达式到方法定义\n\n在 JavaScript 中，方法就是值为函数的属性。\n\n在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。\n\n```js\nvar obj = {\n    foo: function () {\n        ···\n    },\n    bar: function () {\n        this.foo();\n    }, // trailing comma is legal in ES5\n}\n```\n\nES6 有*方法定义*，一种创建方法的特殊语法：\n\n```js\nlet obj = {\n    foo() {\n        ···\n    },\n    bar() {\n        this.foo();\n    },\n}\n```\n\n## 从对象到 Map\n\n把语言结构 *object* 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 `__proto__` ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。\n\n下面的 ES5 代码包含了函数 `countWords` ，该函数将对象 `dict` 用作一个 map ：\n\n```js\nvar dict = Object.create(null);\nfunction countWords(word) {\n    var escapedWord = escapeKey(word);\n    if (escapedWord in dict) {\n        dict[escapedWord]++;\n    } else {\n        dict[escapedWord] = 1;\n    }\n}\nfunction escapeKey(key) {\n    if (key.indexOf('__proto__') === 0) {\n        return key+'%';\n    } else {\n        return key;\n    }\n}\n```\n\n在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。\n\n```js\nlet map = new Map();\nfunction countWords(word) {\n    let count = map.get(word) || 0;\n    map.set(word, count + 1);\n}\n```\n\nmap 的另一个优点是可以用任何值作为键，而不仅仅是字符串。\n\n## 从 CommonJS 模块到 ES6 模块\n\n直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如[暴露的模块方式](http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/)）。\n\nES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。\n\n### 导出多个值\n\n在 CommonJS 里，像下面这样导出多个实体：\n\n```js\n//------ lib.js ------\nvar sqrt = Math.sqrt;\nfunction square(x) {\n    return x * x;\n}\nfunction diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\nmodule.exports = {\n    sqrt: sqrt,\n    square: square,\n    diag: diag,\n};\n\n//------ main1.js ------\nvar square = require('lib').square;\nvar diag = require('lib').diag;\n\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5\n```\n\n相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 `square` 和 `diag` ：\n\n```js\n//------ main2.js ------\nvar lib = require('lib');\nconsole.log(lib.square(11)); // 121\nconsole.log(lib.diag(4, 3)); // 5\n```\n\n在 ES6 中，多个导出值被称为*命名导出*，像这样处理：\n\n```js\n//------ lib.js ------\nexport const sqrt = Math.sqrt;\nexport function square(x) {\n    return x * x;\n}\nexport function diag(x, y) {\n    return sqrt(square(x) + square(y));\n}\n\n//------ main1.js ------\nimport { square, diag } from 'lib';\nconsole.log(square(11)); // 121\nconsole.log(diag(4, 3)); // 5\n```\n\n引入模块为对象的语法就像下面这样（行 A ）：\n\n```js\n//------ main2.js ------\nimport * as lib from 'lib'; // (A)\nconsole.log(lib.square(11)); // 121\nconsole.log(lib.diag(4, 3)); // 5\n```\n\n### 导出一个值\n\nNode.js 使用了 CommonJS 的模块方案，允许通过 `module.exports` 在模块中导出一个值：\n\n```js\n//------ myFunc.js ------\nmodule.exports = function () { ··· };\n\n//------ main1.js ------\nvar myFunc = require('myFunc');\nmyFunc();\n```\n\n在 ES6 中， `export default` 完成同样的功能：\n\n```js\n//------ myFunc.js ------\nexport default function () { ··· } // no semicolon!\n\n//------ main1.js ------\nimport myFunc from 'myFunc';\nmyFunc();\n```\n\n","slug":"ES6 简单特性概览","published":1,"updated":"2016-06-08T11:21:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndj0005n407n70sussj","content":"<p>本文内容：</p>\n<ul>\n<li>讲解了如何使用交互式的方式体验 ES6 。</li>\n<li>列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"体验-ECMAScript-6\"><a href=\"#体验-ECMAScript-6\" class=\"headerlink\" title=\"体验 ECMAScript 6\"></a>体验 ECMAScript 6</h2><p>有三种简单的方式可以运行 ES6 代码：</p>\n<ul>\n<li>1、 Web 浏览器：使用<a href=\"http://babeljs.io/repl/\" target=\"_blank\" rel=\"external\">在线的 Babel REPL </a>，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。</li>\n<li>2、命令行：使用 <code>babel-node</code> ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。</li>\n<li>3、各种 JavaScript 引擎：查询<a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\" rel=\"external\"> kangax 的 ES6 兼容表格</a>，可以找到本地支持 ES6 的引擎。</li>\n</ul>\n<p>下面将会给出更多关于选项1和2的内容。</p>\n<h3 id=\"Babel-REPL\"><a href=\"#Babel-REPL\" class=\"headerlink\" title=\"Babel REPL\"></a>Babel REPL</h3><p>Babel REPL 有四个主要部分：</p>\n<ul>\n<li>左上角部分包含 ES6 源码。</li>\n<li>左下角部分显示 ES6 代码中发现的语法错误。</li>\n<li>右上角部分包含 ES6 代码编译成的 ES5 代码。</li>\n<li>右下角部分展示通过 <code>console.log()</code> 输出的内容。</li>\n</ul>\n<p><img src=\"/images/11.jpg\" alt=\"\"></p>\n<h3 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h3><p><code>babel-node</code> 可执行程序可以通过 npm 安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global babel</span><br></pre></td></tr></table></figure>\n<p>你可以像使用可执行程序 <code>node</code> 一样使用 <code>babel-node</code> 。类似于 <code>node</code> ，像这样启动一个交互式的 REPL ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-node</span><br></pre></td></tr></table></figure>\n<p>一旦进入该 REPL ，你就可以执行 ES6 代码了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; let arr = [1, 2, 3];</span><br><span class=\"line\">&gt; arr.map(x =&gt; x * x)</span><br><span class=\"line\">[ 1, 4, 9 ]</span><br></pre></td></tr></table></figure>\n<p>注意 <a href=\"https://github.com/babel/babel/issues/1741\" target=\"_blank\" rel=\"external\">babel-node 目前还不支持多行输入</a>。</p>\n<p>Babel 官网有<a href=\"http://babeljs.io/docs/usage/cli/\" target=\"_blank\" rel=\"external\">更多关于 Babel 命令行工具的信息</a>。</p>\n<p>本文接下来的部分描述了易于接受的 ES6 特性。</p>\n<h2 id=\"从-var-到-let-const\"><a href=\"#从-var-到-let-const\" class=\"headerlink\" title=\"从 var 到 let/const\"></a>从 var 到 let/const</h2><p>ES6 有两种新的声明变量的方式：</p>\n<ul>\n<li><code>let</code> （大致）相当于 <code>var</code> 的一个块级范围版本。</li>\n<li><code>const</code> 类似于 <code>let</code> ，但是用于创建<em>常量</em>：值不能被改变的变量。</li>\n</ul>\n<p>一般情况下，你可以用 <code>let</code> 或者 <code>const</code> 替换每一个 <code>var</code> 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"built_in\">Math</span>.random(); <span class=\"comment\">// (A) scope: whole function</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x; <span class=\"comment\">// accesses the x from line A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p><code>func()</code> 返回 <code>undefined</code> ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果你在最初的版本中用 <code>let</code> 替换 <code>var</code> ，将会得到不一样的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>因此，盲目地用 <code>let</code> 或者 <code>const</code> 替换 <code>var</code> 很危险。我的建议是：</p>\n<ul>\n<li>仅在新的代码中使用 <code>let</code>/<code>const</code> 。</li>\n<li>不动老的代码，或者小心地重构老的代码。</li>\n</ul>\n<h2 id=\"从-IIFE-到块级作用域\"><a href=\"#从-IIFE-到块级作用域\" class=\"headerlink\" title=\"从 IIFE 到块级作用域\"></a>从 IIFE 到块级作用域</h2><p>在 ES5 中，你必须使用 IIFE 来使变量保持本地化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// open IIFE</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = ···;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;());  <span class=\"comment\">// close IIFE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>在 ECMAScript 6 中，你可以简单地使用一个块和一个 <code>let</code> 声明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  <span class=\"comment\">// open block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = ···;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;  <span class=\"comment\">// close block</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从拼接字符串到模板字面量\"><a href=\"#从拼接字符串到模板字面量\" class=\"headerlink\" title=\"从拼接字符串到模板字面量\"></a>从拼接字符串到模板字面量</h2><p>在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。</p>\n<h3 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h3><p>在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'('</span>+x+<span class=\"string\">', '</span>+y+<span class=\"string\">')'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以通过模板字面量的方式实现字符串插值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>)`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>模板字面量也可以用于表示多行字符串。</p>\n<p>例如，下面是在 ES5 中表示多行文本的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HTML5_SKELETON =</span><br><span class=\"line\">    <span class=\"string\">'&lt;!doctype html&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;html&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;head&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'    &lt;meta charset=\"UTF-8\"&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'    &lt;title&gt;&lt;/title&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/head&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;body&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/body&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/html&gt;\\n'</span>;</span><br></pre></td></tr></table></figure>\n<p>如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HTML5_SKELETON = <span class=\"string\">'\\</span><br><span class=\"line\">    &lt;!doctype html&gt;\\n\\</span><br><span class=\"line\">    &lt;html&gt;\\n\\</span><br><span class=\"line\">    &lt;head&gt;\\n\\</span><br><span class=\"line\">        &lt;meta charset=\"UTF-8\"&gt;\\n\\</span><br><span class=\"line\">        &lt;title&gt;&lt;/title&gt;\\n\\</span><br><span class=\"line\">    &lt;/head&gt;\\n\\</span><br><span class=\"line\">    &lt;body&gt;\\n\\</span><br><span class=\"line\">    &lt;/body&gt;\\n\\</span><br><span class=\"line\">    &lt;/html&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>ES6 模板字面量可以跨越多行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HTML5_SKELETON = <span class=\"string\">`</span><br><span class=\"line\">    &lt;!doctype html&gt;</span><br><span class=\"line\">    &lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=\"UTF-8\"&gt;</span><br><span class=\"line\">        &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">    &lt;/html&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<p>（这些例子包含的空格数是不一样的，但是在此处并不重要。）</p>\n<h2 id=\"从函数表达式到箭头函数\"><a href=\"#从函数表达式到箭头函数\" class=\"headerlink\" title=\"从函数表达式到箭头函数\"></a>从函数表达式到箭头函数</h2><p>在当前的 ES5 代码中，在函数表达式中必须小心使用 <code>this</code> 。在下面的例子中，我创建了辅助变量 <code>_this</code> （行 A ），以便在行 B 能够访问到 UiComponent 的 <code>this</code> 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UiComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myButton'</span>);</span><br><span class=\"line\">    button.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'CLICK'</span>);</span><br><span class=\"line\">        _this.handleClick(); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">UiComponent.prototype.handleClick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以使用箭头函数，它不会改变 <code>this</code> 指向（行 A ，<em>词法范围的 this</em> ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UiComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myButton'</span>);</span><br><span class=\"line\">        button.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'CLICK'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handleClick(); <span class=\"comment\">// (A)</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleClick() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。</p>\n<p>在 ES5 中，这样的回调函数相当啰嗦：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> squares = arr.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，箭头函数简洁很多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares = arr.map(x =&gt; x * x);</span><br></pre></td></tr></table></figure>\n<p>在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： <code>(x) =&gt; x * x</code> 和 <code>x =&gt; x * x</code> 都是合法的。</p>\n<h2 id=\"处理多个返回值\"><a href=\"#处理多个返回值\" class=\"headerlink\" title=\"处理多个返回值\"></a>处理多个返回值</h2><p>一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。</p>\n<h3 id=\"借助数组返回多个值\"><a href=\"#借助数组返回多个值\" class=\"headerlink\" title=\"借助数组返回多个值\"></a>借助数组返回多个值</h3><p><code>exec()</code> 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 <code>matchObj</code> ），即便是你仅对匹配组感兴趣：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> matchObj =</span><br><span class=\"line\">    <span class=\"regexp\">/^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/</span></span><br><span class=\"line\">    .exec(<span class=\"string\">'2999-12-31'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> year = matchObj[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> month = matchObj[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> day = matchObj[<span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，解构使代码更简单：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, year, month, day] =</span><br><span class=\"line\">    <span class=\"regexp\">/^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/</span></span><br><span class=\"line\">    .exec(<span class=\"string\">'2999-12-31'</span>);</span><br></pre></td></tr></table></figure>\n<p>左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。</p>\n<h3 id=\"借助对象返回多个值\"><a href=\"#借助对象返回多个值\" class=\"headerlink\" title=\"借助对象返回多个值\"></a>借助对象返回多个值</h3><p>方法 <code>Object.getOwnPropertyDescriptor()</code> 返回一个<em>属性描述符</em>，一个包含多个属性值的对象。</p>\n<p>在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 <code>propDesc</code> ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; foo: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> propDesc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> writable = propDesc.writable;</span><br><span class=\"line\"><span class=\"keyword\">var</span> configurable = propDesc.configurable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(writable, configurable); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以使用解构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; foo: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;writable, configurable&#125; =</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(writable, configurable); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<p><code>{writable, configurable}</code> 是下面内容的缩写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; writable: writable, configurable: configurable &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从-for-到-forEach-，再到-for-of\"><a href=\"#从-for-到-forEach-，再到-for-of\" class=\"headerlink\" title=\"从 for 到 forEach() ，再到 for-of\"></a>从 for 到 forEach() ，再到 for-of</h2><p>在 ES5 之前，可以选择使用数组方法 <code>forEach()</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>for</code> 循环的优点在于可以中断， <code>forEach()</code> 的优点在于简洁。</p>\n<p>在 ES6 中， <code>for-of</code> 循环结合了两种优点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想访问每个元素的索引和值， <code>for-of</code> 也可以做到，通过新的数组方法 <code>entries()</code> 和解构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> arr.entries()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index+<span class=\"string\">'. '</span>+elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理参数默认值\"><a href=\"#处理参数默认值\" class=\"headerlink\" title=\"处理参数默认值\"></a>处理参数默认值</h2><p>在 ES5 中，为参数指定默认值的代码像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    x = x || <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = y || <span class=\"number\">0</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 有更漂亮的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x=0, y=0</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个额外的好处就是，在 ES6 中，参数默认值只会被 <code>undefined</code> 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。</p>\n<h2 id=\"处理命名参数\"><a href=\"#处理命名参数\" class=\"headerlink\" title=\"处理命名参数\"></a>处理命名参数</h2><p>在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的<em>可选对象模式</em>）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selectEntries(&#123; start: <span class=\"number\">0</span>, end: <span class=\"number\">-1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。</p>\n<p>在 ES5 中，你可以这样实现 <code>selectEntries()</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = options.start || <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> end = options.end || <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> step = options.step || <span class=\"number\">1</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">&#123; start=0, end=-1, step=1 &#125;</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h3><p>在 ES5 中，要让参数 <code>options</code> 变得可选，会添加行 A 所示的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = options.start || <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> end = options.end || <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> step = options.step || <span class=\"number\">1</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以用 <code>{}</code> 指定参数的默认值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">&#123; start=0, end=-1, step=1 &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从-arguments-到剩余参数\"><a href=\"#从-arguments-到剩余参数\" class=\"headerlink\" title=\"从 arguments 到剩余参数\"></a>从 arguments 到剩余参数</h2><p>在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 <code>arguments</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logAllArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以通过 <code>...</code> 操作符声明一个剩余参数（下例中的 args ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logAllArguments</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> args) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">pattern, ...args</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES5 中处理这种场景很笨拙：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pattern = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。</p>\n<h2 id=\"从-apply-到扩展操作符（-…-）\"><a href=\"#从-apply-到扩展操作符（-…-）\" class=\"headerlink\" title=\"从 apply() 到扩展操作符（ … ）\"></a>从 apply() 到扩展操作符（ … ）</h2><p>在 ES5 中，用 <code>apply()</code> 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。</p>\n<h3 id=\"4-11-1-Math-max\"><a href=\"#4-11-1-Math-max\" class=\"headerlink\" title=\"4.11.1 Math.max()\"></a>4.11.1 Math.max()</h3><p>ES5 - apply() ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Math.max.apply(null, [-1, 5, 11, 3])</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Math.max(...[-1, 5, 11, 3])</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-push\"><a href=\"#Array-prototype-push\" class=\"headerlink\" title=\"Array.prototype.push()\"></a>Array.prototype.push()</h3><p>ES5 - apply() ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr1.push.apply(arr1, arr2);</span><br><span class=\"line\">    <span class=\"comment\">// arr1 is now ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<p>let arr1 = [‘a’, ‘b’];<br>let arr2 = [‘c’, ‘d’];</p>\n<p>arr1.push(…arr2);<br>    // arr1 is now [‘a’, ‘b’, ‘c’, ‘d’]</p>\n<h2 id=\"从-concat-到扩展操作符（-…-）\"><a href=\"#从-concat-到扩展操作符（-…-）\" class=\"headerlink\" title=\"从 concat() 到扩展操作符（ … ）\"></a>从 concat() 到扩展操作符（ … ）</h2><p>扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 <code>concat()</code> 的功能。</p>\n<p>ES5 - concat() ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.concat(arr2, arr3));</span><br><span class=\"line\">    <span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...arr1, ...arr2, ...arr3]);</span><br><span class=\"line\">    <span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从构造函数到类\"><a href=\"#从构造函数到类\" class=\"headerlink\" title=\"从构造函数到类\"></a>从构造函数到类</h2><p>相对于构造函数来说，ES6 类是一种更加方便的语法。</p>\n<h3 id=\"基类\"><a href=\"#基类\" class=\"headerlink\" title=\"基类\"></a>基类</h3><p>在 ES5 中，直接实现构造函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Person called '</span>+<span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，类为构造函数提供了略微方便的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    describe() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Person called '</span>+<span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承类\"><a href=\"#继承类\" class=\"headerlink\" title=\"继承类\"></a>继承类</h3><p>在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 <code>Person</code> 的子构造器 <code>Employee</code> 的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employee</span>(<span class=\"params\">name, title</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// super(name)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employee.prototype = <span class=\"built_in\">Object</span>.create(Person.prototype);</span><br><span class=\"line\">Employee.prototype.constructor = Employee;</span><br><span class=\"line\">Employee.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Person.prototype.describe.call(<span class=\"keyword\">this</span>) <span class=\"comment\">// super.describe()</span></span><br><span class=\"line\">           + <span class=\"string\">' ('</span> + <span class=\"keyword\">this</span>.title + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ES6 内置支持子类继承，使用 extends 子句：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name, title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    describe() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.describe() + <span class=\"string\">' ('</span> + <span class=\"keyword\">this</span>.title + <span class=\"string\">')'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从自定义错误构造函数到-Error-子类\"><a href=\"#从自定义错误构造函数到-Error-子类\" class=\"headerlink\" title=\"从自定义错误构造函数到 Error 子类\"></a>从自定义错误构造函数到 Error 子类</h2><p>在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyError</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use Error as a function</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> superInstance = <span class=\"built_in\">Error</span>.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    copyOwnPropertiesFrom(<span class=\"keyword\">this</span>, superInstance);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyError.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Error</span>.prototype);</span><br><span class=\"line\">MyError.prototype.constructor = MyError;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyError</span> <span class=\"keyword\">extends</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从对象字面量中的函数表达式到方法定义\"><a href=\"#从对象字面量中的函数表达式到方法定义\" class=\"headerlink\" title=\"从对象字面量中的函数表达式到方法定义\"></a>从对象字面量中的函数表达式到方法定义</h2><p>在 JavaScript 中，方法就是值为函数的属性。</p>\n<p>在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.foo();</span><br><span class=\"line\">    &#125;, <span class=\"comment\">// trailing comma is legal in ES5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 有<em>方法定义</em>，一种创建方法的特殊语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    foo() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.foo();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从对象到-Map\"><a href=\"#从对象到-Map\" class=\"headerlink\" title=\"从对象到 Map\"></a>从对象到 Map</h2><p>把语言结构 <em>object</em> 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 <code>__proto__</code> ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。</p>\n<p>下面的 ES5 代码包含了函数 <code>countWords</code> ，该函数将对象 <code>dict</code> 用作一个 map ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dict = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countWords</span>(<span class=\"params\">word</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> escapedWord = escapeKey(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (escapedWord <span class=\"keyword\">in</span> dict) &#123;</span><br><span class=\"line\">        dict[escapedWord]++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dict[escapedWord] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escapeKey</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.indexOf(<span class=\"string\">'__proto__'</span>) === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key+<span class=\"string\">'%'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countWords</span>(<span class=\"params\">word</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = map.get(word) || <span class=\"number\">0</span>;</span><br><span class=\"line\">    map.set(word, count + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map 的另一个优点是可以用任何值作为键，而不仅仅是字符串。</p>\n<h2 id=\"从-CommonJS-模块到-ES6-模块\"><a href=\"#从-CommonJS-模块到-ES6-模块\" class=\"headerlink\" title=\"从 CommonJS 模块到 ES6 模块\"></a>从 CommonJS 模块到 ES6 模块</h2><p>直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如<a href=\"http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/\" target=\"_blank\" rel=\"external\">暴露的模块方式</a>）。</p>\n<p>ES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。</p>\n<h3 id=\"导出多个值\"><a href=\"#导出多个值\" class=\"headerlink\" title=\"导出多个值\"></a>导出多个值</h3><p>在 CommonJS 里，像下面这样导出多个实体：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ lib.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sqrt = <span class=\"built_in\">Math</span>.sqrt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diag</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(square(x) + square(y));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    sqrt: sqrt,</span><br><span class=\"line\">    square: square,</span><br><span class=\"line\">    diag: diag,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> square = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>).square;</span><br><span class=\"line\"><span class=\"keyword\">var</span> diag = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>).diag;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 <code>square</code> 和 <code>diag</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ main2.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，多个导出值被称为<em>命名导出</em>，像这样处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ lib.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> sqrt = <span class=\"built_in\">Math</span>.sqrt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diag</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(square(x) + square(y));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; square, diag &#125; <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>引入模块为对象的语法就像下面这样（行 A ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ main2.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> lib <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"导出一个值\"><a href=\"#导出一个值\" class=\"headerlink\" title=\"导出一个值\"></a>导出一个值</h3><p>Node.js 使用了 CommonJS 的模块方案，允许通过 <code>module.exports</code> 在模块中导出一个值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ myFunc.js ------</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; ··· &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myFunc = <span class=\"built_in\">require</span>(<span class=\"string\">'myFunc'</span>);</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中， <code>export default</code> 完成同样的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ myFunc.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; ··· &#125; <span class=\"comment\">// no semicolon!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myFunc <span class=\"keyword\">from</span> <span class=\"string\">'myFunc'</span>;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n","excerpt":"<p>本文内容：</p>\n<ul>\n<li>讲解了如何使用交互式的方式体验 ES6 。</li>\n<li>列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。</li>\n</ul>","more":"<h2 id=\"体验-ECMAScript-6\"><a href=\"#体验-ECMAScript-6\" class=\"headerlink\" title=\"体验 ECMAScript 6\"></a>体验 ECMAScript 6</h2><p>有三种简单的方式可以运行 ES6 代码：</p>\n<ul>\n<li>1、 Web 浏览器：使用<a href=\"http://babeljs.io/repl/\">在线的 Babel REPL </a>，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。</li>\n<li>2、命令行：使用 <code>babel-node</code> ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。</li>\n<li>3、各种 JavaScript 引擎：查询<a href=\"https://kangax.github.io/compat-table/es6/\"> kangax 的 ES6 兼容表格</a>，可以找到本地支持 ES6 的引擎。</li>\n</ul>\n<p>下面将会给出更多关于选项1和2的内容。</p>\n<h3 id=\"Babel-REPL\"><a href=\"#Babel-REPL\" class=\"headerlink\" title=\"Babel REPL\"></a>Babel REPL</h3><p>Babel REPL 有四个主要部分：</p>\n<ul>\n<li>左上角部分包含 ES6 源码。</li>\n<li>左下角部分显示 ES6 代码中发现的语法错误。</li>\n<li>右上角部分包含 ES6 代码编译成的 ES5 代码。</li>\n<li>右下角部分展示通过 <code>console.log()</code> 输出的内容。</li>\n</ul>\n<p><img src=\"/images/11.jpg\" alt=\"\"></p>\n<h3 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h3><p><code>babel-node</code> 可执行程序可以通过 npm 安装：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --global babel</span><br></pre></td></tr></table></figure>\n<p>你可以像使用可执行程序 <code>node</code> 一样使用 <code>babel-node</code> 。类似于 <code>node</code> ，像这样启动一个交互式的 REPL ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel-node</span><br></pre></td></tr></table></figure>\n<p>一旦进入该 REPL ，你就可以执行 ES6 代码了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; let arr = [1, 2, 3];</span><br><span class=\"line\">&gt; arr.map(x =&gt; x * x)</span><br><span class=\"line\">[ 1, 4, 9 ]</span><br></pre></td></tr></table></figure>\n<p>注意 <a href=\"https://github.com/babel/babel/issues/1741\">babel-node 目前还不支持多行输入</a>。</p>\n<p>Babel 官网有<a href=\"http://babeljs.io/docs/usage/cli/\">更多关于 Babel 命令行工具的信息</a>。</p>\n<p>本文接下来的部分描述了易于接受的 ES6 特性。</p>\n<h2 id=\"从-var-到-let-const\"><a href=\"#从-var-到-let-const\" class=\"headerlink\" title=\"从 var 到 let/const\"></a>从 var 到 let/const</h2><p>ES6 有两种新的声明变量的方式：</p>\n<ul>\n<li><code>let</code> （大致）相当于 <code>var</code> 的一个块级范围版本。</li>\n<li><code>const</code> 类似于 <code>let</code> ，但是用于创建<em>常量</em>：值不能被改变的变量。</li>\n</ul>\n<p>一般情况下，你可以用 <code>let</code> 或者 <code>const</code> 替换每一个 <code>var</code> 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"built_in\">Math</span>.random(); <span class=\"comment\">// (A) scope: whole function</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x; <span class=\"comment\">// accesses the x from line A</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p><code>func()</code> 返回 <code>undefined</code> ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        x = <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<p>如果你在最初的版本中用 <code>let</code> 替换 <code>var</code> ，将会得到不一样的结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">randomize</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (randomize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> x = <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func(<span class=\"literal\">false</span>); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>因此，盲目地用 <code>let</code> 或者 <code>const</code> 替换 <code>var</code> 很危险。我的建议是：</p>\n<ul>\n<li>仅在新的代码中使用 <code>let</code>/<code>const</code> 。</li>\n<li>不动老的代码，或者小心地重构老的代码。</li>\n</ul>\n<h2 id=\"从-IIFE-到块级作用域\"><a href=\"#从-IIFE-到块级作用域\" class=\"headerlink\" title=\"从 IIFE 到块级作用域\"></a>从 IIFE 到块级作用域</h2><p>在 ES5 中，你必须使用 IIFE 来使变量保持本地化：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// open IIFE</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = ···;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;());  <span class=\"comment\">// close IIFE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<p>在 ECMAScript 6 中，你可以简单地使用一个块和一个 <code>let</code> 声明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;  <span class=\"comment\">// open block</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> tmp = ···;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;  <span class=\"comment\">// close block</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(tmp); <span class=\"comment\">// ReferenceError</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从拼接字符串到模板字面量\"><a href=\"#从拼接字符串到模板字面量\" class=\"headerlink\" title=\"从拼接字符串到模板字面量\"></a>从拼接字符串到模板字面量</h2><p>在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。</p>\n<h3 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h3><p>在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'('</span>+x+<span class=\"string\">', '</span>+y+<span class=\"string\">')'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以通过模板字面量的方式实现字符串插值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`(<span class=\"subst\">$&#123;x&#125;</span>, <span class=\"subst\">$&#123;y&#125;</span>)`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>模板字面量也可以用于表示多行字符串。</p>\n<p>例如，下面是在 ES5 中表示多行文本的样子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HTML5_SKELETON =</span><br><span class=\"line\">    <span class=\"string\">'&lt;!doctype html&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;html&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;head&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'    &lt;meta charset=\"UTF-8\"&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'    &lt;title&gt;&lt;/title&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/head&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;body&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/body&gt;\\n'</span> +</span><br><span class=\"line\">    <span class=\"string\">'&lt;/html&gt;\\n'</span>;</span><br></pre></td></tr></table></figure>\n<p>如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HTML5_SKELETON = <span class=\"string\">'\\</span><br><span class=\"line\">    &lt;!doctype html&gt;\\n\\</span><br><span class=\"line\">    &lt;html&gt;\\n\\</span><br><span class=\"line\">    &lt;head&gt;\\n\\</span><br><span class=\"line\">        &lt;meta charset=\"UTF-8\"&gt;\\n\\</span><br><span class=\"line\">        &lt;title&gt;&lt;/title&gt;\\n\\</span><br><span class=\"line\">    &lt;/head&gt;\\n\\</span><br><span class=\"line\">    &lt;body&gt;\\n\\</span><br><span class=\"line\">    &lt;/body&gt;\\n\\</span><br><span class=\"line\">    &lt;/html&gt;'</span>;</span><br></pre></td></tr></table></figure>\n<p>ES6 模板字面量可以跨越多行：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> HTML5_SKELETON = <span class=\"string\">`</span><br><span class=\"line\">    &lt;!doctype html&gt;</span><br><span class=\"line\">    &lt;html&gt;</span><br><span class=\"line\">    &lt;head&gt;</span><br><span class=\"line\">        &lt;meta charset=\"UTF-8\"&gt;</span><br><span class=\"line\">        &lt;title&gt;&lt;/title&gt;</span><br><span class=\"line\">    &lt;/head&gt;</span><br><span class=\"line\">    &lt;body&gt;</span><br><span class=\"line\">    &lt;/body&gt;</span><br><span class=\"line\">    &lt;/html&gt;`</span>;</span><br></pre></td></tr></table></figure>\n<p>（这些例子包含的空格数是不一样的，但是在此处并不重要。）</p>\n<h2 id=\"从函数表达式到箭头函数\"><a href=\"#从函数表达式到箭头函数\" class=\"headerlink\" title=\"从函数表达式到箭头函数\"></a>从函数表达式到箭头函数</h2><p>在当前的 ES5 代码中，在函数表达式中必须小心使用 <code>this</code> 。在下面的例子中，我创建了辅助变量 <code>_this</code> （行 A ），以便在行 B 能够访问到 UiComponent 的 <code>this</code> 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UiComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myButton'</span>);</span><br><span class=\"line\">    button.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'CLICK'</span>);</span><br><span class=\"line\">        _this.handleClick(); <span class=\"comment\">// (B)</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">UiComponent.prototype.handleClick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以使用箭头函数，它不会改变 <code>this</code> 指向（行 A ，<em>词法范围的 this</em> ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UiComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> button = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'myButton'</span>);</span><br><span class=\"line\">        button.addEventListener(<span class=\"string\">'click'</span>, () =&gt; &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'CLICK'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.handleClick(); <span class=\"comment\">// (A)</span></span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handleClick() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。</p>\n<p>在 ES5 中，这样的回调函数相当啰嗦：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> squares = arr.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">x</span>) </span>&#123; <span class=\"keyword\">return</span> x * x &#125;);</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，箭头函数简洁很多：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> squares = arr.map(x =&gt; x * x);</span><br></pre></td></tr></table></figure>\n<p>在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： <code>(x) =&gt; x * x</code> 和 <code>x =&gt; x * x</code> 都是合法的。</p>\n<h2 id=\"处理多个返回值\"><a href=\"#处理多个返回值\" class=\"headerlink\" title=\"处理多个返回值\"></a>处理多个返回值</h2><p>一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。</p>\n<h3 id=\"借助数组返回多个值\"><a href=\"#借助数组返回多个值\" class=\"headerlink\" title=\"借助数组返回多个值\"></a>借助数组返回多个值</h3><p><code>exec()</code> 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 <code>matchObj</code> ），即便是你仅对匹配组感兴趣：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> matchObj =</span><br><span class=\"line\">    <span class=\"regexp\">/^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/</span></span><br><span class=\"line\">    .exec(<span class=\"string\">'2999-12-31'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> year = matchObj[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> month = matchObj[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> day = matchObj[<span class=\"number\">3</span>];</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，解构使代码更简单：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> [, year, month, day] =</span><br><span class=\"line\">    <span class=\"regexp\">/^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/</span></span><br><span class=\"line\">    .exec(<span class=\"string\">'2999-12-31'</span>);</span><br></pre></td></tr></table></figure>\n<p>左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。</p>\n<h3 id=\"借助对象返回多个值\"><a href=\"#借助对象返回多个值\" class=\"headerlink\" title=\"借助对象返回多个值\"></a>借助对象返回多个值</h3><p>方法 <code>Object.getOwnPropertyDescriptor()</code> 返回一个<em>属性描述符</em>，一个包含多个属性值的对象。</p>\n<p>在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 <code>propDesc</code> ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; foo: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> propDesc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> writable = propDesc.writable;</span><br><span class=\"line\"><span class=\"keyword\">var</span> configurable = propDesc.configurable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(writable, configurable); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以使用解构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; foo: <span class=\"number\">123</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;writable, configurable&#125; =</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(obj, <span class=\"string\">'foo'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(writable, configurable); <span class=\"comment\">// true true</span></span><br></pre></td></tr></table></figure>\n<p><code>{writable, configurable}</code> 是下面内容的缩写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; writable: writable, configurable: configurable &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从-for-到-forEach-，再到-for-of\"><a href=\"#从-for-到-forEach-，再到-for-of\" class=\"headerlink\" title=\"从 for 到 forEach() ，再到 for-of\"></a>从 for 到 forEach() ，再到 for-of</h2><p>在 ES5 之前，可以选择使用数组方法 <code>forEach()</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p><code>for</code> 循环的优点在于可以中断， <code>forEach()</code> 的优点在于简洁。</p>\n<p>在 ES6 中， <code>for-of</code> 循环结合了两种优点：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> elem <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果想访问每个元素的索引和值， <code>for-of</code> 也可以做到，通过新的数组方法 <code>entries()</code> 和解构：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, elem] <span class=\"keyword\">of</span> arr.entries()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(index+<span class=\"string\">'. '</span>+elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"处理参数默认值\"><a href=\"#处理参数默认值\" class=\"headerlink\" title=\"处理参数默认值\"></a>处理参数默认值</h2><p>在 ES5 中，为参数指定默认值的代码像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    x = x || <span class=\"number\">0</span>;</span><br><span class=\"line\">    y = y || <span class=\"number\">0</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 有更漂亮的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x=0, y=0</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个额外的好处就是，在 ES6 中，参数默认值只会被 <code>undefined</code> 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。</p>\n<h2 id=\"处理命名参数\"><a href=\"#处理命名参数\" class=\"headerlink\" title=\"处理命名参数\"></a>处理命名参数</h2><p>在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的<em>可选对象模式</em>）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selectEntries(&#123; start: <span class=\"number\">0</span>, end: <span class=\"number\">-1</span> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。</p>\n<p>在 ES5 中，你可以这样实现 <code>selectEntries()</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = options.start || <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> end = options.end || <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> step = options.step || <span class=\"number\">1</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">&#123; start=0, end=-1, step=1 &#125;</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可选参数\"><a href=\"#可选参数\" class=\"headerlink\" title=\"可选参数\"></a>可选参数</h3><p>在 ES5 中，要让参数 <code>options</code> 变得可选，会添加行 A 所示的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">    options = options || &#123;&#125;; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> start = options.start || <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> end = options.end || <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> step = options.step || <span class=\"number\">1</span>;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以用 <code>{}</code> 指定参数的默认值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectEntries</span>(<span class=\"params\">&#123; start=0, end=-1, step=1 &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从-arguments-到剩余参数\"><a href=\"#从-arguments-到剩余参数\" class=\"headerlink\" title=\"从 arguments 到剩余参数\"></a>从 arguments 到剩余参数</h2><p>在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 <code>arguments</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logAllArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以通过 <code>...</code> 操作符声明一个剩余参数（下例中的 args ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logAllArguments</span>(<span class=\"params\">...args</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> arg <span class=\"keyword\">of</span> args) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(arg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\">pattern, ...args</span>) </span>&#123;</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES5 中处理这种场景很笨拙：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">format</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pattern = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">    ···</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。</p>\n<h2 id=\"从-apply-到扩展操作符（-…-）\"><a href=\"#从-apply-到扩展操作符（-…-）\" class=\"headerlink\" title=\"从 apply() 到扩展操作符（ … ）\"></a>从 apply() 到扩展操作符（ … ）</h2><p>在 ES5 中，用 <code>apply()</code> 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。</p>\n<h3 id=\"4-11-1-Math-max\"><a href=\"#4-11-1-Math-max\" class=\"headerlink\" title=\"4.11.1 Math.max()\"></a>4.11.1 Math.max()</h3><p>ES5 - apply() ：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Math.max.apply(null, [-1, 5, 11, 3])</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; Math.max(...[-1, 5, 11, 3])</span><br><span class=\"line\">11</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-push\"><a href=\"#Array-prototype-push\" class=\"headerlink\" title=\"Array.prototype.push()\"></a>Array.prototype.push()</h3><p>ES5 - apply() ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>, <span class=\"string\">'d'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr1.push.apply(arr1, arr2);</span><br><span class=\"line\">    <span class=\"comment\">// arr1 is now ['a', 'b', 'c', 'd']</span></span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<p>let arr1 = [‘a’, ‘b’];<br>let arr2 = [‘c’, ‘d’];</p>\n<p>arr1.push(…arr2);<br>    // arr1 is now [‘a’, ‘b’, ‘c’, ‘d’]</p>\n<h2 id=\"从-concat-到扩展操作符（-…-）\"><a href=\"#从-concat-到扩展操作符（-…-）\" class=\"headerlink\" title=\"从 concat() 到扩展操作符（ … ）\"></a>从 concat() 到扩展操作符（ … ）</h2><p>扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 <code>concat()</code> 的功能。</p>\n<p>ES5 - concat() ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.concat(arr2, arr3));</span><br><span class=\"line\">    <span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>\n<p>ES6 - 扩展操作符：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2 = [<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3 = [<span class=\"string\">'d'</span>, <span class=\"string\">'e'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([...arr1, ...arr2, ...arr3]);</span><br><span class=\"line\">    <span class=\"comment\">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从构造函数到类\"><a href=\"#从构造函数到类\" class=\"headerlink\" title=\"从构造函数到类\"></a>从构造函数到类</h2><p>相对于构造函数来说，ES6 类是一种更加方便的语法。</p>\n<h3 id=\"基类\"><a href=\"#基类\" class=\"headerlink\" title=\"基类\"></a>基类</h3><p>在 ES5 中，直接实现构造函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'Person called '</span>+<span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，类为构造函数提供了略微方便的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    describe() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Person called '</span>+<span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承类\"><a href=\"#继承类\" class=\"headerlink\" title=\"继承类\"></a>继承类</h3><p>在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 <code>Person</code> 的子构造器 <code>Employee</code> 的方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Employee</span>(<span class=\"params\">name, title</span>) </span>&#123;</span><br><span class=\"line\">    Person.call(<span class=\"keyword\">this</span>, name); <span class=\"comment\">// super(name)</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Employee.prototype = <span class=\"built_in\">Object</span>.create(Person.prototype);</span><br><span class=\"line\">Employee.prototype.constructor = Employee;</span><br><span class=\"line\">Employee.prototype.describe = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Person.prototype.describe.call(<span class=\"keyword\">this</span>) <span class=\"comment\">// super.describe()</span></span><br><span class=\"line\">           + <span class=\"string\">' ('</span> + <span class=\"keyword\">this</span>.title + <span class=\"string\">')'</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>ES6 内置支持子类继承，使用 extends 子句：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name, title) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.title = title;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    describe() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.describe() + <span class=\"string\">' ('</span> + <span class=\"keyword\">this</span>.title + <span class=\"string\">')'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从自定义错误构造函数到-Error-子类\"><a href=\"#从自定义错误构造函数到-Error-子类\" class=\"headerlink\" title=\"从自定义错误构造函数到 Error 子类\"></a>从自定义错误构造函数到 Error 子类</h2><p>在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyError</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Use Error as a function</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> superInstance = <span class=\"built_in\">Error</span>.apply(<span class=\"literal\">null</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    copyOwnPropertiesFrom(<span class=\"keyword\">this</span>, superInstance);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyError.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Error</span>.prototype);</span><br><span class=\"line\">MyError.prototype.constructor = MyError;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyError</span> <span class=\"keyword\">extends</span> <span class=\"title\">Error</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从对象字面量中的函数表达式到方法定义\"><a href=\"#从对象字面量中的函数表达式到方法定义\" class=\"headerlink\" title=\"从对象字面量中的函数表达式到方法定义\"></a>从对象字面量中的函数表达式到方法定义</h2><p>在 JavaScript 中，方法就是值为函数的属性。</p>\n<p>在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    foo: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.foo();</span><br><span class=\"line\">    &#125;, <span class=\"comment\">// trailing comma is legal in ES5</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ES6 有<em>方法定义</em>，一种创建方法的特殊语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    foo() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    bar() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.foo();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"从对象到-Map\"><a href=\"#从对象到-Map\" class=\"headerlink\" title=\"从对象到 Map\"></a>从对象到 Map</h2><p>把语言结构 <em>object</em> 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 <code>__proto__</code> ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。</p>\n<p>下面的 ES5 代码包含了函数 <code>countWords</code> ，该函数将对象 <code>dict</code> 用作一个 map ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dict = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countWords</span>(<span class=\"params\">word</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> escapedWord = escapeKey(word);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (escapedWord <span class=\"keyword\">in</span> dict) &#123;</span><br><span class=\"line\">        dict[escapedWord]++;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        dict[escapedWord] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escapeKey</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key.indexOf(<span class=\"string\">'__proto__'</span>) === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key+<span class=\"string\">'%'</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countWords</span>(<span class=\"params\">word</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = map.get(word) || <span class=\"number\">0</span>;</span><br><span class=\"line\">    map.set(word, count + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>map 的另一个优点是可以用任何值作为键，而不仅仅是字符串。</p>\n<h2 id=\"从-CommonJS-模块到-ES6-模块\"><a href=\"#从-CommonJS-模块到-ES6-模块\" class=\"headerlink\" title=\"从 CommonJS 模块到 ES6 模块\"></a>从 CommonJS 模块到 ES6 模块</h2><p>直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如<a href=\"http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/\">暴露的模块方式</a>）。</p>\n<p>ES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。</p>\n<h3 id=\"导出多个值\"><a href=\"#导出多个值\" class=\"headerlink\" title=\"导出多个值\"></a>导出多个值</h3><p>在 CommonJS 里，像下面这样导出多个实体：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ lib.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sqrt = <span class=\"built_in\">Math</span>.sqrt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diag</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(square(x) + square(y));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    sqrt: sqrt,</span><br><span class=\"line\">    square: square,</span><br><span class=\"line\">    diag: diag,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> square = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>).square;</span><br><span class=\"line\"><span class=\"keyword\">var</span> diag = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>).diag;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 <code>square</code> 和 <code>diag</code> ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ main2.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lib = <span class=\"built_in\">require</span>(<span class=\"string\">'lib'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>在 ES6 中，多个导出值被称为<em>命名导出</em>，像这样处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ lib.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> sqrt = <span class=\"built_in\">Math</span>.sqrt;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diag</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqrt(square(x) + square(y));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; square, diag &#125; <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>引入模块为对象的语法就像下面这样（行 A ）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ main2.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> lib <span class=\"keyword\">from</span> <span class=\"string\">'lib'</span>; <span class=\"comment\">// (A)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.square(<span class=\"number\">11</span>)); <span class=\"comment\">// 121</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lib.diag(<span class=\"number\">4</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"导出一个值\"><a href=\"#导出一个值\" class=\"headerlink\" title=\"导出一个值\"></a>导出一个值</h3><p>Node.js 使用了 CommonJS 的模块方案，允许通过 <code>module.exports</code> 在模块中导出一个值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ myFunc.js ------</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; ··· &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myFunc = <span class=\"built_in\">require</span>(<span class=\"string\">'myFunc'</span>);</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>\n<p>在 ES6 中， <code>export default</code> 完成同样的功能：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//------ myFunc.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123; ··· &#125; <span class=\"comment\">// no semicolon!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//------ main1.js ------</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> myFunc <span class=\"keyword\">from</span> <span class=\"string\">'myFunc'</span>;</span><br><span class=\"line\">myFunc();</span><br></pre></td></tr></table></figure>"},{"title":"Reflux 使用进化日记","date":"2015-05-21T16:00:00.000Z","_content":"\nReflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）：\n\n<!-- more -->\n\n## 第一步：初识 Reflux\n\n一直在听人说 Reflux ，说这个东西比较适合中小型的前端项目，使用起来很方便，于是我就找到了 Reflux  在 GitHub 的[主页](https://github.com/spoike/refluxjs)。\n\n文档说 dispatcher 被移除了，没关系，反正我也没用过 Flux 。\n\n于是继续阅读关于 actions 和 stores 的文档。由于心浮气躁急着用，看文档很马虎，action 、 store 可以监听过去监听过来的，还有 store 可以 connect 啥的，完全看晕了，无法用 Reflux 组织起一个完整的处理流程。但是没关系，我就按照文档上的这些 listen 啥的，自己来写写看吧。\n\n于是， 创建 action ，在 store 中用 listenTo 来监听 action ，然后请求数据，store trigger 返回数据。写的时候，由于完全不理解 Reflux 怎么用，一通胡乱监听，写出来的代码不三不四，看着都觉得累。为了照顾项目进度，放弃 Reflux ，自己写一个 service 层吧。\n\n## 第二步：认识了一点 Reflux\n\n过了几天，对 Reflux 心有不甘，于是转头再去看 Reflux 文档，同时也很开心找到一篇[使用 Reflux 的经验文章](http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615)，于是知道了 action 可以当成方法调用，在 action 中监听调用，发出请求之类的，然后 store 做一些存储等操作，再 trigger ，component 中通过 mixin 来监听 store 中的 trigger ，然后做一些界面变动，摘录一段那篇文章中的例子：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createAction({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    onLoginSuccess: function(payload) {\n        this.trigger(payload);\n    },\n    onLoginFailed: function(payload) {\n        this.trigger(payload);\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.connect(UserStore, 'user')],\n    render: function() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n感觉自己似乎知道怎么来组织流程了，于是很开心地又去改造代码，希望能用上 Reflux 。\n\n写了一会儿，发现完了，因为有这样的场景：就拿上述一小段代码来说，UserAction 中很可能还有其它 action ，例如：\n\n```js\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']},\n    'register': {children: ['success', 'failed']}\n});\n```\n\nlogin 和 register 两个 action 都会触发 UserStore 中相应方法的调用，然后这些方法再调用 trigger ，然后改变 UserComponent 中 `state.user` 的值，此处有两个问题：\n\n* 1、登录和注册最终得到的数据真的都要反映到 UserComponent 的 `state.user` 上吗？这样合适吗？\n* 2、如果登录报错了，怎么通知 UserComponent ，怎么告诉其错误信息？\n\n想了想，有种方案：组织好 trigger 返回的数据结构，比如像这样：\n\n```js\n{\n  actionType: 'login',                  // 本次 action 的类型\n  status: 0,                                 // 0代表出错了，1代表成功了\n  message: 'an error occurred'  // 错误信息\n}\n```\n\n但是转念一想，这明显不对，肯定不是标准的用法，这样的话我又得在 component 中写好多代码来分析这些分发复杂的情况，太不优雅了。\n\n想了半天，实在没想出好的方式，在[《聊一聊基于Flux的前端系统》](http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615)中也没找到相关内容。\n\n于是，使用 Reflux 的想法再次被搁置，继续使用 service 吧！\n\n## 第三步：别扭的方式解决出错处理\n\n改回 service 之后，心中还是蛮不爽的，便去一个牛人云集的 React 群(161461760)求助，初步描述完我的问题之后，群中一位热心网友提出了他的方式：给 store 添加方法，获取 action 执行的结果。\n\n感觉这种方式似乎能解决问题，虽然还是有点别扭，于是代码变成了这样：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar userStoreMixin = {\n    getLoginResult() {\n        if (this._error) {\n            throw this._error;\n        }\n        return this._user;\n    }\n};\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    mixins: [userStoreMixin],\n    onLoginSuccess(payload) {\n        this._error = null;\n        this.trigger(payload);\n    },\n    onLoginFailed(error) {\n        if (error.status === -1) {\n            this._error = new UnloginError(error.message);\n        } else {\n            this._error = new Error(error.message);\n        }\n        this.trigger();\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.listenTo(UserStore, 'onUserStore')],\n    onUserStore() {\n        try {\n            this.setState({\n                user: UserStore.getLoginResult()\n            });\n        } catch (e) {\n            if (e instanceof UnloginError) {\n                alert('not login');\n            } else {\n                alert(e.message);\n            }\n        }\n    },\n    render() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n似乎还行，于是开开心心地翻新项目代码，将 service 改成“这种的 Reflux ”。\n\n## 第四步：产生新的想法\n\n按照第三步的思维使用了一段时间之后，感觉实在是别扭，越来越感受到这不是标准的方案，写出来的代码看着有点丑。\n\n于是想啊想，突然，灵光一闪，还是应该回归到第二步中写的那个例子啊，store 应该只是用来处理`正确的数据`，至于那些报错什么的，可以用额外的 action 、 store 来处理啊！于是上述代码应该是这个样子的：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar ErrorAction = Reflux.createActions({\n    Unlogin: {}, // 未登录\n    error: {}    // 一般性的错误\n});\n\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    onLoginSuccess(payload) {\n        this.trigger(payload);\n    },\n    onLoginFailed(payload) {\n        if (error.status === -1) {\n            ErrorAction.Unlogin(error.message);\n        } else {\n            ErrorAction.error(error.message);\n        }\n    }\n});\n\nvar ErrorStoreMixin = {\n    UNLOGIN: 1,\n    ERROR: 2\n};\nvar ErrorStore = Reflux.createStore({\n    listenables: ErrorAction,\n    mixins: [ErrorStoreMixin],\n    onUnlogin(message) {\n        this.trigger({type: this.UNLOGIN, message: message});\n    },\n    onError(message) {\n        this.trigger({type: this.ERROR, message: message});\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.connect(UserStore, 'user'), Reflux.listenTo(ErrorStore, 'onErrorStore')],\n    onErrorStore(error) {\n        if (error.type === ErrorStore.UNLOGIN) {\n            alert('not login');\n        } else if (error.type === ErrorStore.ERROR) {\n            alert(error.message);\n        }\n    },\n    render() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n现在，感觉似乎完美一点了，代码看着也相对优雅。\n\n不过，到目前为止，还有一点疑问：按照这种 store 写法，似乎会创建很多 store ，是否需要控制 store 数量，如果有必要，如何整合各个 store ？\n\n带着一些疑问，继续前行吧，骚年！\n\n（后续有使用心得的时候会继续更新本文章）\n","source":"_posts/Reflux 使用进化日记.md","raw":"---\ntitle: Reflux 使用进化日记\ndate: 2015-05-22\n---\n\nReflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）：\n\n<!-- more -->\n\n## 第一步：初识 Reflux\n\n一直在听人说 Reflux ，说这个东西比较适合中小型的前端项目，使用起来很方便，于是我就找到了 Reflux  在 GitHub 的[主页](https://github.com/spoike/refluxjs)。\n\n文档说 dispatcher 被移除了，没关系，反正我也没用过 Flux 。\n\n于是继续阅读关于 actions 和 stores 的文档。由于心浮气躁急着用，看文档很马虎，action 、 store 可以监听过去监听过来的，还有 store 可以 connect 啥的，完全看晕了，无法用 Reflux 组织起一个完整的处理流程。但是没关系，我就按照文档上的这些 listen 啥的，自己来写写看吧。\n\n于是， 创建 action ，在 store 中用 listenTo 来监听 action ，然后请求数据，store trigger 返回数据。写的时候，由于完全不理解 Reflux 怎么用，一通胡乱监听，写出来的代码不三不四，看着都觉得累。为了照顾项目进度，放弃 Reflux ，自己写一个 service 层吧。\n\n## 第二步：认识了一点 Reflux\n\n过了几天，对 Reflux 心有不甘，于是转头再去看 Reflux 文档，同时也很开心找到一篇[使用 Reflux 的经验文章](http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615)，于是知道了 action 可以当成方法调用，在 action 中监听调用，发出请求之类的，然后 store 做一些存储等操作，再 trigger ，component 中通过 mixin 来监听 store 中的 trigger ，然后做一些界面变动，摘录一段那篇文章中的例子：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createAction({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    onLoginSuccess: function(payload) {\n        this.trigger(payload);\n    },\n    onLoginFailed: function(payload) {\n        this.trigger(payload);\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.connect(UserStore, 'user')],\n    render: function() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n感觉自己似乎知道怎么来组织流程了，于是很开心地又去改造代码，希望能用上 Reflux 。\n\n写了一会儿，发现完了，因为有这样的场景：就拿上述一小段代码来说，UserAction 中很可能还有其它 action ，例如：\n\n```js\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']},\n    'register': {children: ['success', 'failed']}\n});\n```\n\nlogin 和 register 两个 action 都会触发 UserStore 中相应方法的调用，然后这些方法再调用 trigger ，然后改变 UserComponent 中 `state.user` 的值，此处有两个问题：\n\n* 1、登录和注册最终得到的数据真的都要反映到 UserComponent 的 `state.user` 上吗？这样合适吗？\n* 2、如果登录报错了，怎么通知 UserComponent ，怎么告诉其错误信息？\n\n想了想，有种方案：组织好 trigger 返回的数据结构，比如像这样：\n\n```js\n{\n  actionType: 'login',                  // 本次 action 的类型\n  status: 0,                                 // 0代表出错了，1代表成功了\n  message: 'an error occurred'  // 错误信息\n}\n```\n\n但是转念一想，这明显不对，肯定不是标准的用法，这样的话我又得在 component 中写好多代码来分析这些分发复杂的情况，太不优雅了。\n\n想了半天，实在没想出好的方式，在[《聊一聊基于Flux的前端系统》](http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615)中也没找到相关内容。\n\n于是，使用 Reflux 的想法再次被搁置，继续使用 service 吧！\n\n## 第三步：别扭的方式解决出错处理\n\n改回 service 之后，心中还是蛮不爽的，便去一个牛人云集的 React 群(161461760)求助，初步描述完我的问题之后，群中一位热心网友提出了他的方式：给 store 添加方法，获取 action 执行的结果。\n\n感觉这种方式似乎能解决问题，虽然还是有点别扭，于是代码变成了这样：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar userStoreMixin = {\n    getLoginResult() {\n        if (this._error) {\n            throw this._error;\n        }\n        return this._user;\n    }\n};\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    mixins: [userStoreMixin],\n    onLoginSuccess(payload) {\n        this._error = null;\n        this.trigger(payload);\n    },\n    onLoginFailed(error) {\n        if (error.status === -1) {\n            this._error = new UnloginError(error.message);\n        } else {\n            this._error = new Error(error.message);\n        }\n        this.trigger();\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.listenTo(UserStore, 'onUserStore')],\n    onUserStore() {\n        try {\n            this.setState({\n                user: UserStore.getLoginResult()\n            });\n        } catch (e) {\n            if (e instanceof UnloginError) {\n                alert('not login');\n            } else {\n                alert(e.message);\n            }\n        }\n    },\n    render() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n似乎还行，于是开开心心地翻新项目代码，将 service 改成“这种的 Reflux ”。\n\n## 第四步：产生新的想法\n\n按照第三步的思维使用了一段时间之后，感觉实在是别扭，越来越感受到这不是标准的方案，写出来的代码看着有点丑。\n\n于是想啊想，突然，灵光一闪，还是应该回归到第二步中写的那个例子啊，store 应该只是用来处理`正确的数据`，至于那些报错什么的，可以用额外的 action 、 store 来处理啊！于是上述代码应该是这个样子的：\n\n```js\nvar Reflux = require('reflux');\nvar React = require('react');\n\nvar UserAction = Reflux.createActions({\n    'login': {children: ['success', 'failed']}\n});\n\nUsersAction.login.listen(function(data) {\n    $.post('/api/users/Action/login', data).then(this.success, this.failed);\n});\n\nvar ErrorAction = Reflux.createActions({\n    Unlogin: {}, // 未登录\n    error: {}    // 一般性的错误\n});\n\nvar UserStore = Reflux.createStore({\n    listenables: UserAction,\n    onLoginSuccess(payload) {\n        this.trigger(payload);\n    },\n    onLoginFailed(payload) {\n        if (error.status === -1) {\n            ErrorAction.Unlogin(error.message);\n        } else {\n            ErrorAction.error(error.message);\n        }\n    }\n});\n\nvar ErrorStoreMixin = {\n    UNLOGIN: 1,\n    ERROR: 2\n};\nvar ErrorStore = Reflux.createStore({\n    listenables: ErrorAction,\n    mixins: [ErrorStoreMixin],\n    onUnlogin(message) {\n        this.trigger({type: this.UNLOGIN, message: message});\n    },\n    onError(message) {\n        this.trigger({type: this.ERROR, message: message});\n    }\n});\n\nvar UserComponent = React.createClass({\n    mixins: [Reflux.connect(UserStore, 'user'), Reflux.listenTo(ErrorStore, 'onErrorStore')],\n    onErrorStore(error) {\n        if (error.type === ErrorStore.UNLOGIN) {\n            alert('not login');\n        } else if (error.type === ErrorStore.ERROR) {\n            alert(error.message);\n        }\n    },\n    render() {\n        return <span>{this.state.user.name}</span>;\n    }\n});\n```\n\n现在，感觉似乎完美一点了，代码看着也相对优雅。\n\n不过，到目前为止，还有一点疑问：按照这种 store 写法，似乎会创建很多 store ，是否需要控制 store 数量，如果有必要，如何整合各个 store ？\n\n带着一些疑问，继续前行吧，骚年！\n\n（后续有使用心得的时候会继续更新本文章）\n","slug":"Reflux 使用进化日记","published":1,"updated":"2016-06-08T09:54:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndl0006n4076hddkm15","content":"<p>Reflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）：</p>\n<a id=\"more\"></a>\n<h2 id=\"第一步：初识-Reflux\"><a href=\"#第一步：初识-Reflux\" class=\"headerlink\" title=\"第一步：初识 Reflux\"></a>第一步：初识 Reflux</h2><p>一直在听人说 Reflux ，说这个东西比较适合中小型的前端项目，使用起来很方便，于是我就找到了 Reflux  在 GitHub 的<a href=\"https://github.com/spoike/refluxjs\" target=\"_blank\" rel=\"external\">主页</a>。</p>\n<p>文档说 dispatcher 被移除了，没关系，反正我也没用过 Flux 。</p>\n<p>于是继续阅读关于 actions 和 stores 的文档。由于心浮气躁急着用，看文档很马虎，action 、 store 可以监听过去监听过来的，还有 store 可以 connect 啥的，完全看晕了，无法用 Reflux 组织起一个完整的处理流程。但是没关系，我就按照文档上的这些 listen 啥的，自己来写写看吧。</p>\n<p>于是， 创建 action ，在 store 中用 listenTo 来监听 action ，然后请求数据，store trigger 返回数据。写的时候，由于完全不理解 Reflux 怎么用，一通胡乱监听，写出来的代码不三不四，看着都觉得累。为了照顾项目进度，放弃 Reflux ，自己写一个 service 层吧。</p>\n<h2 id=\"第二步：认识了一点-Reflux\"><a href=\"#第二步：认识了一点-Reflux\" class=\"headerlink\" title=\"第二步：认识了一点 Reflux\"></a>第二步：认识了一点 Reflux</h2><p>过了几天，对 Reflux 心有不甘，于是转头再去看 Reflux 文档，同时也很开心找到一篇<a href=\"http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615\" target=\"_blank\" rel=\"external\">使用 Reflux 的经验文章</a>，于是知道了 action 可以当成方法调用，在 action 中监听调用，发出请求之类的，然后 store 做一些存储等操作，再 trigger ，component 中通过 mixin 来监听 store 中的 trigger ，然后做一些界面变动，摘录一段那篇文章中的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createAction(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    onLoginSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.connect(UserStore, <span class=\"string\">'user'</span>)],</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感觉自己似乎知道怎么来组织流程了，于是很开心地又去改造代码，希望能用上 Reflux 。</p>\n<p>写了一会儿，发现完了，因为有这样的场景：就拿上述一小段代码来说，UserAction 中很可能还有其它 action ，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;,</span><br><span class=\"line\">    <span class=\"string\">'register'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>login 和 register 两个 action 都会触发 UserStore 中相应方法的调用，然后这些方法再调用 trigger ，然后改变 UserComponent 中 <code>state.user</code> 的值，此处有两个问题：</p>\n<ul>\n<li>1、登录和注册最终得到的数据真的都要反映到 UserComponent 的 <code>state.user</code> 上吗？这样合适吗？</li>\n<li>2、如果登录报错了，怎么通知 UserComponent ，怎么告诉其错误信息？</li>\n</ul>\n<p>想了想，有种方案：组织好 trigger 返回的数据结构，比如像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  actionType: <span class=\"string\">'login'</span>,                  <span class=\"comment\">// 本次 action 的类型</span></span><br><span class=\"line\">  status: <span class=\"number\">0</span>,                                 <span class=\"comment\">// 0代表出错了，1代表成功了</span></span><br><span class=\"line\">  message: <span class=\"string\">'an error occurred'</span>  <span class=\"comment\">// 错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是转念一想，这明显不对，肯定不是标准的用法，这样的话我又得在 component 中写好多代码来分析这些分发复杂的情况，太不优雅了。</p>\n<p>想了半天，实在没想出好的方式，在<a href=\"http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615\" target=\"_blank\" rel=\"external\">《聊一聊基于Flux的前端系统》</a>中也没找到相关内容。</p>\n<p>于是，使用 Reflux 的想法再次被搁置，继续使用 service 吧！</p>\n<h2 id=\"第三步：别扭的方式解决出错处理\"><a href=\"#第三步：别扭的方式解决出错处理\" class=\"headerlink\" title=\"第三步：别扭的方式解决出错处理\"></a>第三步：别扭的方式解决出错处理</h2><p>改回 service 之后，心中还是蛮不爽的，便去一个牛人云集的 React 群(161461760)求助，初步描述完我的问题之后，群中一位热心网友提出了他的方式：给 store 添加方法，获取 action 执行的结果。</p>\n<p>感觉这种方式似乎能解决问题，虽然还是有点别扭，于是代码变成了这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> userStoreMixin = &#123;</span><br><span class=\"line\">    getLoginResult() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">this</span>._error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    mixins: [userStoreMixin],</span><br><span class=\"line\">    onLoginSuccess(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._error = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.status === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._error = <span class=\"keyword\">new</span> UnloginError(error.message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._error = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.listenTo(UserStore, <span class=\"string\">'onUserStore'</span>)],</span><br><span class=\"line\">    onUserStore() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                user: UserStore.getLoginResult()</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> UnloginError) &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">'not login'</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                alert(e.message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>似乎还行，于是开开心心地翻新项目代码，将 service 改成“这种的 Reflux ”。</p>\n<h2 id=\"第四步：产生新的想法\"><a href=\"#第四步：产生新的想法\" class=\"headerlink\" title=\"第四步：产生新的想法\"></a>第四步：产生新的想法</h2><p>按照第三步的思维使用了一段时间之后，感觉实在是别扭，越来越感受到这不是标准的方案，写出来的代码看着有点丑。</p>\n<p>于是想啊想，突然，灵光一闪，还是应该回归到第二步中写的那个例子啊，store 应该只是用来处理<code>正确的数据</code>，至于那些报错什么的，可以用额外的 action 、 store 来处理啊！于是上述代码应该是这个样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    Unlogin: &#123;&#125;, <span class=\"comment\">// 未登录</span></span><br><span class=\"line\">    error: &#123;&#125;    <span class=\"comment\">// 一般性的错误</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    onLoginSuccess(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.status === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            ErrorAction.Unlogin(error.message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ErrorAction.error(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorStoreMixin = &#123;</span><br><span class=\"line\">    UNLOGIN: <span class=\"number\">1</span>,</span><br><span class=\"line\">    ERROR: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: ErrorAction,</span><br><span class=\"line\">    mixins: [ErrorStoreMixin],</span><br><span class=\"line\">    onUnlogin(message) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(&#123;type: <span class=\"keyword\">this</span>.UNLOGIN, message: message&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onError(message) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(&#123;type: <span class=\"keyword\">this</span>.ERROR, message: message&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.connect(UserStore, <span class=\"string\">'user'</span>), Reflux.listenTo(ErrorStore, <span class=\"string\">'onErrorStore'</span>)],</span><br><span class=\"line\">    onErrorStore(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.type === ErrorStore.UNLOGIN) &#123;</span><br><span class=\"line\">            alert(<span class=\"string\">'not login'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (error.type === ErrorStore.ERROR) &#123;</span><br><span class=\"line\">            alert(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在，感觉似乎完美一点了，代码看着也相对优雅。</p>\n<p>不过，到目前为止，还有一点疑问：按照这种 store 写法，似乎会创建很多 store ，是否需要控制 store 数量，如果有必要，如何整合各个 store ？</p>\n<p>带着一些疑问，继续前行吧，骚年！</p>\n<p>（后续有使用心得的时候会继续更新本文章）</p>\n","excerpt":"<p>Reflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）：</p>","more":"<h2 id=\"第一步：初识-Reflux\"><a href=\"#第一步：初识-Reflux\" class=\"headerlink\" title=\"第一步：初识 Reflux\"></a>第一步：初识 Reflux</h2><p>一直在听人说 Reflux ，说这个东西比较适合中小型的前端项目，使用起来很方便，于是我就找到了 Reflux  在 GitHub 的<a href=\"https://github.com/spoike/refluxjs\">主页</a>。</p>\n<p>文档说 dispatcher 被移除了，没关系，反正我也没用过 Flux 。</p>\n<p>于是继续阅读关于 actions 和 stores 的文档。由于心浮气躁急着用，看文档很马虎，action 、 store 可以监听过去监听过来的，还有 store 可以 connect 啥的，完全看晕了，无法用 Reflux 组织起一个完整的处理流程。但是没关系，我就按照文档上的这些 listen 啥的，自己来写写看吧。</p>\n<p>于是， 创建 action ，在 store 中用 listenTo 来监听 action ，然后请求数据，store trigger 返回数据。写的时候，由于完全不理解 Reflux 怎么用，一通胡乱监听，写出来的代码不三不四，看着都觉得累。为了照顾项目进度，放弃 Reflux ，自己写一个 service 层吧。</p>\n<h2 id=\"第二步：认识了一点-Reflux\"><a href=\"#第二步：认识了一点-Reflux\" class=\"headerlink\" title=\"第二步：认识了一点 Reflux\"></a>第二步：认识了一点 Reflux</h2><p>过了几天，对 Reflux 心有不甘，于是转头再去看 Reflux 文档，同时也很开心找到一篇<a href=\"http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615\">使用 Reflux 的经验文章</a>，于是知道了 action 可以当成方法调用，在 action 中监听调用，发出请求之类的，然后 store 做一些存储等操作，再 trigger ，component 中通过 mixin 来监听 store 中的 trigger ，然后做一些界面变动，摘录一段那篇文章中的例子：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createAction(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    onLoginSuccess: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">payload</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.connect(UserStore, <span class=\"string\">'user'</span>)],</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>感觉自己似乎知道怎么来组织流程了，于是很开心地又去改造代码，希望能用上 Reflux 。</p>\n<p>写了一会儿，发现完了，因为有这样的场景：就拿上述一小段代码来说，UserAction 中很可能还有其它 action ，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;,</span><br><span class=\"line\">    <span class=\"string\">'register'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>login 和 register 两个 action 都会触发 UserStore 中相应方法的调用，然后这些方法再调用 trigger ，然后改变 UserComponent 中 <code>state.user</code> 的值，此处有两个问题：</p>\n<ul>\n<li>1、登录和注册最终得到的数据真的都要反映到 UserComponent 的 <code>state.user</code> 上吗？这样合适吗？</li>\n<li>2、如果登录报错了，怎么通知 UserComponent ，怎么告诉其错误信息？</li>\n</ul>\n<p>想了想，有种方案：组织好 trigger 返回的数据结构，比如像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  actionType: <span class=\"string\">'login'</span>,                  <span class=\"comment\">// 本次 action 的类型</span></span><br><span class=\"line\">  status: <span class=\"number\">0</span>,                                 <span class=\"comment\">// 0代表出错了，1代表成功了</span></span><br><span class=\"line\">  message: <span class=\"string\">'an error occurred'</span>  <span class=\"comment\">// 错误信息</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是转念一想，这明显不对，肯定不是标准的用法，这样的话我又得在 component 中写好多代码来分析这些分发复杂的情况，太不优雅了。</p>\n<p>想了半天，实在没想出好的方式，在<a href=\"http://react.nodejs-china.org/t/liao-liao-ji-yu-fluxde-qian-duan-xi-tong/615\">《聊一聊基于Flux的前端系统》</a>中也没找到相关内容。</p>\n<p>于是，使用 Reflux 的想法再次被搁置，继续使用 service 吧！</p>\n<h2 id=\"第三步：别扭的方式解决出错处理\"><a href=\"#第三步：别扭的方式解决出错处理\" class=\"headerlink\" title=\"第三步：别扭的方式解决出错处理\"></a>第三步：别扭的方式解决出错处理</h2><p>改回 service 之后，心中还是蛮不爽的，便去一个牛人云集的 React 群(161461760)求助，初步描述完我的问题之后，群中一位热心网友提出了他的方式：给 store 添加方法，获取 action 执行的结果。</p>\n<p>感觉这种方式似乎能解决问题，虽然还是有点别扭，于是代码变成了这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> userStoreMixin = &#123;</span><br><span class=\"line\">    getLoginResult() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._error) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">this</span>._error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    mixins: [userStoreMixin],</span><br><span class=\"line\">    onLoginSuccess(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._error = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.status === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._error = <span class=\"keyword\">new</span> UnloginError(error.message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>._error = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.listenTo(UserStore, <span class=\"string\">'onUserStore'</span>)],</span><br><span class=\"line\">    onUserStore() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">                user: UserStore.getLoginResult()</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> UnloginError) &#123;</span><br><span class=\"line\">                alert(<span class=\"string\">'not login'</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                alert(e.message);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>似乎还行，于是开开心心地翻新项目代码，将 service 改成“这种的 Reflux ”。</p>\n<h2 id=\"第四步：产生新的想法\"><a href=\"#第四步：产生新的想法\" class=\"headerlink\" title=\"第四步：产生新的想法\"></a>第四步：产生新的想法</h2><p>按照第三步的思维使用了一段时间之后，感觉实在是别扭，越来越感受到这不是标准的方案，写出来的代码看着有点丑。</p>\n<p>于是想啊想，突然，灵光一闪，还是应该回归到第二步中写的那个例子啊，store 应该只是用来处理<code>正确的数据</code>，至于那些报错什么的，可以用额外的 action 、 store 来处理啊！于是上述代码应该是这个样子的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Reflux = <span class=\"built_in\">require</span>(<span class=\"string\">'reflux'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> React = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    <span class=\"string\">'login'</span>: &#123;children: [<span class=\"string\">'success'</span>, <span class=\"string\">'failed'</span>]&#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">UsersAction.login.listen(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    $.post(<span class=\"string\">'/api/users/Action/login'</span>, data).then(<span class=\"keyword\">this</span>.success, <span class=\"keyword\">this</span>.failed);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorAction = Reflux.createActions(&#123;</span><br><span class=\"line\">    Unlogin: &#123;&#125;, <span class=\"comment\">// 未登录</span></span><br><span class=\"line\">    error: &#123;&#125;    <span class=\"comment\">// 一般性的错误</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: UserAction,</span><br><span class=\"line\">    onLoginSuccess(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(payload);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onLoginFailed(payload) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.status === <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            ErrorAction.Unlogin(error.message);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ErrorAction.error(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorStoreMixin = &#123;</span><br><span class=\"line\">    UNLOGIN: <span class=\"number\">1</span>,</span><br><span class=\"line\">    ERROR: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> ErrorStore = Reflux.createStore(&#123;</span><br><span class=\"line\">    listenables: ErrorAction,</span><br><span class=\"line\">    mixins: [ErrorStoreMixin],</span><br><span class=\"line\">    onUnlogin(message) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(&#123;type: <span class=\"keyword\">this</span>.UNLOGIN, message: message&#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    onError(message) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.trigger(&#123;type: <span class=\"keyword\">this</span>.ERROR, message: message&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> UserComponent = React.createClass(&#123;</span><br><span class=\"line\">    mixins: [Reflux.connect(UserStore, <span class=\"string\">'user'</span>), Reflux.listenTo(ErrorStore, <span class=\"string\">'onErrorStore'</span>)],</span><br><span class=\"line\">    onErrorStore(error) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (error.type === ErrorStore.UNLOGIN) &#123;</span><br><span class=\"line\">            alert(<span class=\"string\">'not login'</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (error.type === ErrorStore.ERROR) &#123;</span><br><span class=\"line\">            alert(error.message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>现在，感觉似乎完美一点了，代码看着也相对优雅。</p>\n<p>不过，到目前为止，还有一点疑问：按照这种 store 写法，似乎会创建很多 store ，是否需要控制 store 数量，如果有必要，如何整合各个 store ？</p>\n<p>带着一些疑问，继续前行吧，骚年！</p>\n<p>（后续有使用心得的时候会继续更新本文章）</p>"},{"title":"web 前端外部点击事件的实现","date":"2014-10-22T06:52:00.000Z","_content":"\n在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。\n\n<!-- more -->\n\n实现这个事件有一个核心的东西，就是判断两个节点是否存在父子关系，整个事件流程如下：\n\n* 1、事先设定好的一组元素，如果在这组元素外部点击的话，就会触发外部点击事件，这组元素暂记为 nodes ；\n* 2、用户点击一个元素，可以从 event.target 中获取到当前用户点击的节点，暂记为 nodeClick ；\n* 3、当用户点击 nodeClick 的时候，需要判断 nodes 中是否存在 nodeClick 的祖先节点，如果不存在的话，则触发外部点击事件。\n\n按照这个分析，关键点就落在了判断节点父子关系上面了。\n\n其实早在 IE5 的时候，元素节点上面就有一个方法 `contains()` ，用于判断父子关系，具体文档可参见： https://developer.mozilla.org/en-US/docs/Web/API/Node.contains 。从文档中，我们可以看见 mobile 部分测试不太充分，所以此处最好保留一个自己实现的版本，代码如下：\n\n```js\nfunction contains(parentNode, childNode) {\n  var fn = Node.prototype.contains || function(childNode) {\n    while (childNode) {\n      if (childNode === parentNode) return true;\n      childNode = childNode.parentNode;\n    }\n  };\n  return fn.call(parentNode, childNode);\n}\nfunction isIn(parentNodes, node) {\n  for (var i = 0, il = parentNodes.length; i < il; i += 1) {\n    if (contains(parentNodes[i], node)) return true;\n  }\n  return false;\n}\n```\n\n实现了这个之后，接下来的事情就是维护回调函数队列了，实现机制可能会有多种，此处给出其中一种。\n\n给出一个Array，用于记录所有回调函数，其中每一个数组元素的结构如下：\n\n```js\n{\n  nodes: [node1, node2, ...],      // 对应上一大步中的nodes变量，即事先设定好的那一组元素\n  callback: function() {}          // 触发本次out click事件的回调函数\n}\n```\n\n暂记这个 Array 变量的名字是 outerCallbacks 。\n\n接下来，就剩下对外提供 API 了，此处向外部提供两个 API ：\n\n* 1、 `on()` 函数，用于注册回调函数；\n* 2、 `off()` 函数，用于取消回调函数。\n\non函数的实现非常简单，此处直接上代码：\n\n```js\nfunction outer(elem, callback) {\n  if (!isFunction(callback)) return;            // isFunction = function(obj) {return Object.prototype.toString.call(obj) === '[object Function]';}\n\n  outerCallbacks.push({\n    nodes: (isArray(elem) ? elem : [elem]),     // isArray = function(obj) {return Object.prototype.toString.call(obj) === '[object Array]'}\n    callback: callback\n  });\n}\n```\n\n实现 `off()` 函数的时候，有一个难点和一个注意点：\n\n难点：参数处理，条件判断；\n\n注意点：在外部点击事件回调函数里面调用了 `off()` 函数怎么办？\n\n可以参看我的实现： https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js 。","source":"_posts/web 前端外部点击事件的实现.md","raw":"---\ntitle: web 前端外部点击事件的实现\ndate: 2014-10-22 14:52\n---\n\n在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。\n\n<!-- more -->\n\n实现这个事件有一个核心的东西，就是判断两个节点是否存在父子关系，整个事件流程如下：\n\n* 1、事先设定好的一组元素，如果在这组元素外部点击的话，就会触发外部点击事件，这组元素暂记为 nodes ；\n* 2、用户点击一个元素，可以从 event.target 中获取到当前用户点击的节点，暂记为 nodeClick ；\n* 3、当用户点击 nodeClick 的时候，需要判断 nodes 中是否存在 nodeClick 的祖先节点，如果不存在的话，则触发外部点击事件。\n\n按照这个分析，关键点就落在了判断节点父子关系上面了。\n\n其实早在 IE5 的时候，元素节点上面就有一个方法 `contains()` ，用于判断父子关系，具体文档可参见： https://developer.mozilla.org/en-US/docs/Web/API/Node.contains 。从文档中，我们可以看见 mobile 部分测试不太充分，所以此处最好保留一个自己实现的版本，代码如下：\n\n```js\nfunction contains(parentNode, childNode) {\n  var fn = Node.prototype.contains || function(childNode) {\n    while (childNode) {\n      if (childNode === parentNode) return true;\n      childNode = childNode.parentNode;\n    }\n  };\n  return fn.call(parentNode, childNode);\n}\nfunction isIn(parentNodes, node) {\n  for (var i = 0, il = parentNodes.length; i < il; i += 1) {\n    if (contains(parentNodes[i], node)) return true;\n  }\n  return false;\n}\n```\n\n实现了这个之后，接下来的事情就是维护回调函数队列了，实现机制可能会有多种，此处给出其中一种。\n\n给出一个Array，用于记录所有回调函数，其中每一个数组元素的结构如下：\n\n```js\n{\n  nodes: [node1, node2, ...],      // 对应上一大步中的nodes变量，即事先设定好的那一组元素\n  callback: function() {}          // 触发本次out click事件的回调函数\n}\n```\n\n暂记这个 Array 变量的名字是 outerCallbacks 。\n\n接下来，就剩下对外提供 API 了，此处向外部提供两个 API ：\n\n* 1、 `on()` 函数，用于注册回调函数；\n* 2、 `off()` 函数，用于取消回调函数。\n\non函数的实现非常简单，此处直接上代码：\n\n```js\nfunction outer(elem, callback) {\n  if (!isFunction(callback)) return;            // isFunction = function(obj) {return Object.prototype.toString.call(obj) === '[object Function]';}\n\n  outerCallbacks.push({\n    nodes: (isArray(elem) ? elem : [elem]),     // isArray = function(obj) {return Object.prototype.toString.call(obj) === '[object Array]'}\n    callback: callback\n  });\n}\n```\n\n实现 `off()` 函数的时候，有一个难点和一个注意点：\n\n难点：参数处理，条件判断；\n\n注意点：在外部点击事件回调函数里面调用了 `off()` 函数怎么办？\n\n可以参看我的实现： https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js 。","slug":"web 前端外部点击事件的实现","published":1,"updated":"2016-06-08T09:54:33.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndp0007n407oxpq39un","content":"<p>在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。</p>\n<a id=\"more\"></a>\n<p>实现这个事件有一个核心的东西，就是判断两个节点是否存在父子关系，整个事件流程如下：</p>\n<ul>\n<li>1、事先设定好的一组元素，如果在这组元素外部点击的话，就会触发外部点击事件，这组元素暂记为 nodes ；</li>\n<li>2、用户点击一个元素，可以从 event.target 中获取到当前用户点击的节点，暂记为 nodeClick ；</li>\n<li>3、当用户点击 nodeClick 的时候，需要判断 nodes 中是否存在 nodeClick 的祖先节点，如果不存在的话，则触发外部点击事件。</li>\n</ul>\n<p>按照这个分析，关键点就落在了判断节点父子关系上面了。</p>\n<p>其实早在 IE5 的时候，元素节点上面就有一个方法 <code>contains()</code> ，用于判断父子关系，具体文档可参见： <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/en-US/docs/Web/API/Node.contains</a> 。从文档中，我们可以看见 mobile 部分测试不太充分，所以此处最好保留一个自己实现的版本，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contains</span>(<span class=\"params\">parentNode, childNode</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Node.prototype.contains || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (childNode) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (childNode === parentNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      childNode = childNode.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(parentNode, childNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isIn</span>(<span class=\"params\">parentNodes, node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, il = parentNodes.length; i &lt; il; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contains(parentNodes[i], node)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现了这个之后，接下来的事情就是维护回调函数队列了，实现机制可能会有多种，此处给出其中一种。</p>\n<p>给出一个Array，用于记录所有回调函数，其中每一个数组元素的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  nodes: [node1, node2, ...],      <span class=\"comment\">// 对应上一大步中的nodes变量，即事先设定好的那一组元素</span></span><br><span class=\"line\">  callback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;          <span class=\"comment\">// 触发本次out click事件的回调函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>暂记这个 Array 变量的名字是 outerCallbacks 。</p>\n<p>接下来，就剩下对外提供 API 了，此处向外部提供两个 API ：</p>\n<ul>\n<li>1、 <code>on()</code> 函数，用于注册回调函数；</li>\n<li>2、 <code>off()</code> 函数，用于取消回调函数。</li>\n</ul>\n<p>on函数的实现非常简单，此处直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\">elem, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFunction(callback)) <span class=\"keyword\">return</span>;            <span class=\"comment\">// isFunction = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Function]';&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  outerCallbacks.push(&#123;</span><br><span class=\"line\">    nodes: (isArray(elem) ? elem : [elem]),     <span class=\"comment\">// isArray = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Array]'&#125;</span></span><br><span class=\"line\">    callback: callback</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现 <code>off()</code> 函数的时候，有一个难点和一个注意点：</p>\n<p>难点：参数处理，条件判断；</p>\n<p>注意点：在外部点击事件回调函数里面调用了 <code>off()</code> 函数怎么办？</p>\n<p>可以参看我的实现： <a href=\"https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js\" target=\"_blank\" rel=\"external\">https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js</a> 。</p>\n","excerpt":"<p>在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。</p>","more":"<p>实现这个事件有一个核心的东西，就是判断两个节点是否存在父子关系，整个事件流程如下：</p>\n<ul>\n<li>1、事先设定好的一组元素，如果在这组元素外部点击的话，就会触发外部点击事件，这组元素暂记为 nodes ；</li>\n<li>2、用户点击一个元素，可以从 event.target 中获取到当前用户点击的节点，暂记为 nodeClick ；</li>\n<li>3、当用户点击 nodeClick 的时候，需要判断 nodes 中是否存在 nodeClick 的祖先节点，如果不存在的话，则触发外部点击事件。</li>\n</ul>\n<p>按照这个分析，关键点就落在了判断节点父子关系上面了。</p>\n<p>其实早在 IE5 的时候，元素节点上面就有一个方法 <code>contains()</code> ，用于判断父子关系，具体文档可参见： <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Node.contains\">https://developer.mozilla.org/en-US/docs/Web/API/Node.contains</a> 。从文档中，我们可以看见 mobile 部分测试不太充分，所以此处最好保留一个自己实现的版本，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">contains</span>(<span class=\"params\">parentNode, childNode</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> fn = Node.prototype.contains || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">childNode</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (childNode) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (childNode === parentNode) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      childNode = childNode.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fn.call(parentNode, childNode);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isIn</span>(<span class=\"params\">parentNodes, node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, il = parentNodes.length; i &lt; il; i += <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contains(parentNodes[i], node)) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现了这个之后，接下来的事情就是维护回调函数队列了，实现机制可能会有多种，此处给出其中一种。</p>\n<p>给出一个Array，用于记录所有回调函数，其中每一个数组元素的结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  nodes: [node1, node2, ...],      <span class=\"comment\">// 对应上一大步中的nodes变量，即事先设定好的那一组元素</span></span><br><span class=\"line\">  callback: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;          <span class=\"comment\">// 触发本次out click事件的回调函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>暂记这个 Array 变量的名字是 outerCallbacks 。</p>\n<p>接下来，就剩下对外提供 API 了，此处向外部提供两个 API ：</p>\n<ul>\n<li>1、 <code>on()</code> 函数，用于注册回调函数；</li>\n<li>2、 <code>off()</code> 函数，用于取消回调函数。</li>\n</ul>\n<p>on函数的实现非常简单，此处直接上代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">outer</span>(<span class=\"params\">elem, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isFunction(callback)) <span class=\"keyword\">return</span>;            <span class=\"comment\">// isFunction = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Function]';&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  outerCallbacks.push(&#123;</span><br><span class=\"line\">    nodes: (isArray(elem) ? elem : [elem]),     <span class=\"comment\">// isArray = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Array]'&#125;</span></span><br><span class=\"line\">    callback: callback</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现 <code>off()</code> 函数的时候，有一个难点和一个注意点：</p>\n<p>难点：参数处理，条件判断；</p>\n<p>注意点：在外部点击事件回调函数里面调用了 <code>off()</code> 函数怎么办？</p>\n<p>可以参看我的实现： <a href=\"https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js\">https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js</a> 。</p>"},{"title":"使用 CSS background 构造一个棋盘","date":"2015-08-24T16:00:00.000Z","_content":"\n[CSS background 的规范文档](http://www.w3.org/TR/css3-background)。\n\n![](https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/6.png)\n<!-- more -->\n\n使用的 CSS 代码如下：\n\n```css\n    div.demo1 {\n        width: 300px;\n        height: 150px;\n\n        background-color: #eee;\n        background-image:\n            linear-gradient(45deg, #bbb 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, #bbb 0),\n            linear-gradient(45deg, #bbb 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, #bbb 0);\n        background-size: 30px 30px;\n        background-position: 0 0, 15px 15px, 15px 15px, 0 0;\n    }\n```\n\n整个 div 的背景色是 #eee 。\n\n这个背景是由四幅代码“制造”的图片构成的，分别对应于四行 linear-gradient 。\n\n第一幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。\n\n第二幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。\n\n第三幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。\n\n第四幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。\n\n为了更清晰的看到每幅图片代码对应的区域，参考一下一段代码及其效果：\n\n```css\n    div.demo2 {\n        width: 300px;\n        height: 150px;\n\n        background-color: #eee;\n        background-image:\n            linear-gradient(45deg, red 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, blue 0),\n            linear-gradient(45deg, green 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, orange 0);\n        background-size: 30px 30px;\n        background-position: 0 0, 15px 15px, 15px 15px, 0 0;\n    }\n```\n\n![](https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/7.png)\n\n### 结语\n\ncss 的 background 属性现在很强大了，利用背景“图片”的层叠，可以做出很多绚丽的背景效果。\n\n### 更多 CSS background 的效果：\n\n{% iframe /demos/envelope.html 100% 250 %}\n\n{% iframe /demos/css%20background.html 100% 430 %}\n\n{% iframe /demos/marching%20ants%20borders.html 100% 240 %}\n","source":"_posts/使用 CSS background 构造一个棋盘.md","raw":"---\ntitle: 使用 CSS background 构造一个棋盘\ndate: 2015-08-25\n---\n\n[CSS background 的规范文档](http://www.w3.org/TR/css3-background)。\n\n![](https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/6.png)\n<!-- more -->\n\n使用的 CSS 代码如下：\n\n```css\n    div.demo1 {\n        width: 300px;\n        height: 150px;\n\n        background-color: #eee;\n        background-image:\n            linear-gradient(45deg, #bbb 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, #bbb 0),\n            linear-gradient(45deg, #bbb 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, #bbb 0);\n        background-size: 30px 30px;\n        background-position: 0 0, 15px 15px, 15px 15px, 0 0;\n    }\n```\n\n整个 div 的背景色是 #eee 。\n\n这个背景是由四幅代码“制造”的图片构成的，分别对应于四行 linear-gradient 。\n\n第一幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。\n\n第二幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。\n\n第三幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。\n\n第四幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。\n\n为了更清晰的看到每幅图片代码对应的区域，参考一下一段代码及其效果：\n\n```css\n    div.demo2 {\n        width: 300px;\n        height: 150px;\n\n        background-color: #eee;\n        background-image:\n            linear-gradient(45deg, red 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, blue 0),\n            linear-gradient(45deg, green 25%, transparent 0),\n            linear-gradient(45deg, transparent 75%, orange 0);\n        background-size: 30px 30px;\n        background-position: 0 0, 15px 15px, 15px 15px, 0 0;\n    }\n```\n\n![](https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/7.png)\n\n### 结语\n\ncss 的 background 属性现在很强大了，利用背景“图片”的层叠，可以做出很多绚丽的背景效果。\n\n### 更多 CSS background 的效果：\n\n{% iframe /demos/envelope.html 100% 250 %}\n\n{% iframe /demos/css%20background.html 100% 430 %}\n\n{% iframe /demos/marching%20ants%20borders.html 100% 240 %}\n","slug":"使用 CSS background 构造一个棋盘","published":1,"updated":"2016-06-09T03:54:23.000Z","_id":"cip6tkndq0008n407jxywt4l0","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"http://www.w3.org/TR/css3-background\" target=\"_blank\" rel=\"external\">CSS background 的规范文档</a>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/6.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>使用的 CSS 代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, #bbb 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, #bbb 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, #bbb 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, #bbb 0);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">30px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个 div 的背景色是 #eee 。</p>\n<p>这个背景是由四幅代码“制造”的图片构成的，分别对应于四行 linear-gradient 。</p>\n<p>第一幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。</p>\n<p>第二幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。</p>\n<p>第三幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。</p>\n<p>第四幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。</p>\n<p>为了更清晰的看到每幅图片代码对应的区域，参考一下一段代码及其效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, red 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, blue 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, green 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, orange 0);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">30px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/7.png\" alt=\"\"></p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>css 的 background 属性现在很强大了，利用背景“图片”的层叠，可以做出很多绚丽的背景效果。</p>\n<h3 id=\"更多-CSS-background-的效果：\"><a href=\"#更多-CSS-background-的效果：\" class=\"headerlink\" title=\"更多 CSS background 的效果：\"></a>更多 CSS background 的效果：</h3><iframe src=\"/demos/envelope.html\" width=\"100%\" height=\"250\" frameborder=\"0\" allowfullscreen></iframe>\n<iframe src=\"/demos/css%20background.html\" width=\"100%\" height=\"430\" frameborder=\"0\" allowfullscreen></iframe>\n<iframe src=\"/demos/marching%20ants%20borders.html\" width=\"100%\" height=\"240\" frameborder=\"0\" allowfullscreen></iframe>\n","excerpt":"<p><a href=\"http://www.w3.org/TR/css3-background\">CSS background 的规范文档</a>。</p>\n<p><img src=\"https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/6.png\" alt=\"\"><br>","more":"</p>\n<p>使用的 CSS 代码如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.demo1</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, #bbb 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, #bbb 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, #bbb 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, #bbb 0);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">30px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个 div 的背景色是 #eee 。</p>\n<p>这个背景是由四幅代码“制造”的图片构成的，分别对应于四行 linear-gradient 。</p>\n<p>第一幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。</p>\n<p>第二幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。</p>\n<p>第三幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。</p>\n<p>第四幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。</p>\n<p>为了更清晰的看到每幅图片代码对应的区域，参考一下一段代码及其效果：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.demo2</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">150px</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>:</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, red 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, blue 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, green 25%, transparent 0),</span><br><span class=\"line\">        <span class=\"built_in\">linear-gradient</span>(45deg, transparent 75%, orange 0);</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: <span class=\"number\">30px</span> <span class=\"number\">30px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-position</span>: <span class=\"number\">0</span> <span class=\"number\">0</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">15px</span> <span class=\"number\">15px</span>, <span class=\"number\">0</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://raw.githubusercontent.com/yibuyisheng/blogs/master/imgs/7.png\" alt=\"\"></p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>css 的 background 属性现在很强大了，利用背景“图片”的层叠，可以做出很多绚丽的背景效果。</p>\n<h3 id=\"更多-CSS-background-的效果：\"><a href=\"#更多-CSS-background-的效果：\" class=\"headerlink\" title=\"更多 CSS background 的效果：\"></a>更多 CSS background 的效果：</h3><iframe src=\"/demos/envelope.html\" width=\"100%\" height=\"250\" frameborder=\"0\" allowfullscreen></iframe>\n<iframe src=\"/demos/css%20background.html\" width=\"100%\" height=\"430\" frameborder=\"0\" allowfullscreen></iframe>\n<iframe src=\"/demos/marching%20ants%20borders.html\" width=\"100%\" height=\"240\" frameborder=\"0\" allowfullscreen></iframe>"},{"title":"一个 JavaScript","date":"2015-10-04T16:00:00.000Z","_content":"\nES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。\n\n那么，什么是“版本化”？什么又是“一个 JavaScript”呢？\n<!-- more -->\n\n## 版本化\n\n一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。\n\n如果代码库升级到新的语言版本，就有两种处理方式。\n\n第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。\n\n第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：\n\n```\nContent-Type: application/ecmascript;version=6\n```\n\n也可以利用 `<script>` 标签的 `type` 属性来标记：\n\n```html\n<script type=\"application/ecmascript;version=6\">\n    ···\n</script>\n```\n\n也可以在代码内部标记版本（类似于 `'use strict'` ，放在 JavaScript 文件第一行）：\n\n```js\nuse version 6;\n```\n\n这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。\n\n一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：\n\n* 引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。\n* 开发者需要记住版本之间的不同点。\n* 代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。\n\n因此，应该避免版本化，尤其是 JavaScript 和 web 。\n\n## 一个 JavaScript\n\n既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？\n\n采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。\n\n我们可以增加新的特性，使已有的特性更加强大。\n\n这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“[一个 JavaScript ](http://exploringjs.com/es6/ch_one-javascript.html#one-js_1)”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。\n\n“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 `let` 就是这样干的，它用于声明块级变量，是 `var` 的改进版。但是它并没有替换掉 `var` ，只是作为更好的方案与 `var` 并存。\n\n将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：\n\n* `let` 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：\n\n```js\nlet[x] = arr;\n```\n\n调查发现， web 上没人会在非严格模式下这样使用 `let` 变量，这就使得 TC39 能够将 `let` 引入非严格模式中。\n\n## 严格模式和 ES6\n\nECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式：\n\n```js\n'use strict';\n```\n\n严格模式带来了三种具有破坏性的改变：\n\n* 语法改变：一些之前合法的语法在严格模式下面是不允许的。例如：\n    - 禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。\n    - 删除一个`独立的标识符`（是一个变量，而不是一个属性）是不允许的。\n    - 函数只能在作用域的顶层声明。\n    - 更多的保留字： implements interface let package private protected public static yield 。\n* 更多类型的错误。例如：\n    - 给一个未声明的变量赋值会抛出 `ReferenceError` 。而在非严格模式下，这样做就会创建一个全局变量。\n    - 修改只读的属性（比如字符串的长度属性）会抛出 `TypeError` 。而在非严格模式下，不会产生任何效果。\n* 不同的语义：在严格模式下，一些结构体会表现得不一样。例如：\n    - `arguments` 不再随着当前参数值的改变而改变。\n    - 在非方法的函数中 `this` 为 `undefined` 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。\n\n从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。\n\n## 支持松散（非严格）模式\n\n`一个 JavaScript` 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。\n\n但是很不幸，有两个特性很难引入松散模式： `let` 声明和块级函数声明。让我们看看为什么很难引入和如何引入。\n\n## 松散模式中的 `let` 声明\n\n`let` 使你能够声明块级变量。这很难被引入到松散模式，因为 `let` 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的：\n\n```js\nvar let = [];\nlet[x] = 'abc';\n```\n\n在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 `let` 作为变量名。然后第二行会被解析为一个 `let` 变量声明（使用解构）。\n\n在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 `let` 声明。这种使用 `let` 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 `let` 声明的书写方式不会被误解：\n\n```js\nlet foo = 123;\nlet {x,y} = computeCoordinates();\n```\n\n## 松散模式下的块级函数声明\n\nECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。\n\nECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“[ web 遗留的兼容语义](http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics)”，允许块中的函数声明在函数作用域范围内存在。\n\n## 其它关键字\n\n标识符 `yield` 和 `static` 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用：\n\n* 在松散模式下， `yield` 仅在生成器函数中是保留字。\n* `static` 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。\n\n## 隐式的严格模式\n\n在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 `use strict` 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。\n\n其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。\n\n## 无法修复的东西\n\n`一个 JavaScript `的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。\n\n第一个， `typeof null` 应该返回字符串 `null` 而不是 `object` ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子：\n\n```\n> typeof Symbol.iterator\n'symbol'\n```\n\n第二个，全局对象（浏览器中的 `window` 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 `let` 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。\n\n## 总结\n\n`一个 JavaScript `意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。\n\n在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。\n","source":"_posts/一个 JavaScript.md","raw":"---\ntitle: 一个 JavaScript\ndate: 2015-10-05\n---\n\nES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。\n\n那么，什么是“版本化”？什么又是“一个 JavaScript”呢？\n<!-- more -->\n\n## 版本化\n\n一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。\n\n如果代码库升级到新的语言版本，就有两种处理方式。\n\n第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。\n\n第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：\n\n```\nContent-Type: application/ecmascript;version=6\n```\n\n也可以利用 `<script>` 标签的 `type` 属性来标记：\n\n```html\n<script type=\"application/ecmascript;version=6\">\n    ···\n</script>\n```\n\n也可以在代码内部标记版本（类似于 `'use strict'` ，放在 JavaScript 文件第一行）：\n\n```js\nuse version 6;\n```\n\n这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。\n\n一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：\n\n* 引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。\n* 开发者需要记住版本之间的不同点。\n* 代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。\n\n因此，应该避免版本化，尤其是 JavaScript 和 web 。\n\n## 一个 JavaScript\n\n既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？\n\n采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。\n\n我们可以增加新的特性，使已有的特性更加强大。\n\n这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“[一个 JavaScript ](http://exploringjs.com/es6/ch_one-javascript.html#one-js_1)”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。\n\n“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 `let` 就是这样干的，它用于声明块级变量，是 `var` 的改进版。但是它并没有替换掉 `var` ，只是作为更好的方案与 `var` 并存。\n\n将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：\n\n* `let` 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：\n\n```js\nlet[x] = arr;\n```\n\n调查发现， web 上没人会在非严格模式下这样使用 `let` 变量，这就使得 TC39 能够将 `let` 引入非严格模式中。\n\n## 严格模式和 ES6\n\nECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式：\n\n```js\n'use strict';\n```\n\n严格模式带来了三种具有破坏性的改变：\n\n* 语法改变：一些之前合法的语法在严格模式下面是不允许的。例如：\n    - 禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。\n    - 删除一个`独立的标识符`（是一个变量，而不是一个属性）是不允许的。\n    - 函数只能在作用域的顶层声明。\n    - 更多的保留字： implements interface let package private protected public static yield 。\n* 更多类型的错误。例如：\n    - 给一个未声明的变量赋值会抛出 `ReferenceError` 。而在非严格模式下，这样做就会创建一个全局变量。\n    - 修改只读的属性（比如字符串的长度属性）会抛出 `TypeError` 。而在非严格模式下，不会产生任何效果。\n* 不同的语义：在严格模式下，一些结构体会表现得不一样。例如：\n    - `arguments` 不再随着当前参数值的改变而改变。\n    - 在非方法的函数中 `this` 为 `undefined` 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。\n\n从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。\n\n## 支持松散（非严格）模式\n\n`一个 JavaScript` 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。\n\n但是很不幸，有两个特性很难引入松散模式： `let` 声明和块级函数声明。让我们看看为什么很难引入和如何引入。\n\n## 松散模式中的 `let` 声明\n\n`let` 使你能够声明块级变量。这很难被引入到松散模式，因为 `let` 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的：\n\n```js\nvar let = [];\nlet[x] = 'abc';\n```\n\n在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 `let` 作为变量名。然后第二行会被解析为一个 `let` 变量声明（使用解构）。\n\n在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 `let` 声明。这种使用 `let` 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 `let` 声明的书写方式不会被误解：\n\n```js\nlet foo = 123;\nlet {x,y} = computeCoordinates();\n```\n\n## 松散模式下的块级函数声明\n\nECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。\n\nECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“[ web 遗留的兼容语义](http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics)”，允许块中的函数声明在函数作用域范围内存在。\n\n## 其它关键字\n\n标识符 `yield` 和 `static` 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用：\n\n* 在松散模式下， `yield` 仅在生成器函数中是保留字。\n* `static` 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。\n\n## 隐式的严格模式\n\n在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 `use strict` 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。\n\n其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。\n\n## 无法修复的东西\n\n`一个 JavaScript `的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。\n\n第一个， `typeof null` 应该返回字符串 `null` 而不是 `object` ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子：\n\n```\n> typeof Symbol.iterator\n'symbol'\n```\n\n第二个，全局对象（浏览器中的 `window` 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 `let` 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。\n\n## 总结\n\n`一个 JavaScript `意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。\n\n在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。\n","slug":"一个 JavaScript","published":1,"updated":"2016-06-08T09:50:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndv0009n407yeuk15uu","content":"<p>ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。</p>\n<p>那么，什么是“版本化”？什么又是“一个 JavaScript”呢？<br><a id=\"more\"></a></p>\n<h2 id=\"版本化\"><a href=\"#版本化\" class=\"headerlink\" title=\"版本化\"></a>版本化</h2><p>一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。</p>\n<p>如果代码库升级到新的语言版本，就有两种处理方式。</p>\n<p>第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。</p>\n<p>第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/ecmascript;version=6</span><br></pre></td></tr></table></figure>\n<p>也可以利用 <code>&lt;script&gt;</code> 标签的 <code>type</code> 属性来标记：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"application/ecmascript;version=6\"</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">    ···</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以在代码内部标记版本（类似于 <code>&#39;use strict&#39;</code> ，放在 JavaScript 文件第一行）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use version <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<p>这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。</p>\n<p>一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：</p>\n<ul>\n<li>引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。</li>\n<li>开发者需要记住版本之间的不同点。</li>\n<li>代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。</li>\n</ul>\n<p>因此，应该避免版本化，尤其是 JavaScript 和 web 。</p>\n<h2 id=\"一个-JavaScript\"><a href=\"#一个-JavaScript\" class=\"headerlink\" title=\"一个 JavaScript\"></a>一个 JavaScript</h2><p>既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？</p>\n<p>采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。</p>\n<p>我们可以增加新的特性，使已有的特性更加强大。</p>\n<p>这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“<a href=\"http://exploringjs.com/es6/ch_one-javascript.html#one-js_1\" target=\"_blank\" rel=\"external\">一个 JavaScript </a>”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。</p>\n<p>“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 <code>let</code> 就是这样干的，它用于声明块级变量，是 <code>var</code> 的改进版。但是它并没有替换掉 <code>var</code> ，只是作为更好的方案与 <code>var</code> 并存。</p>\n<p>将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：</p>\n<ul>\n<li><code>let</code> 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span>[x] = arr;</span><br></pre></td></tr></table></figure>\n<p>调查发现， web 上没人会在非严格模式下这样使用 <code>let</code> 变量，这就使得 TC39 能够将 <code>let</code> 引入非严格模式中。</p>\n<h2 id=\"严格模式和-ES6\"><a href=\"#严格模式和-ES6\" class=\"headerlink\" title=\"严格模式和 ES6\"></a>严格模式和 ES6</h2><p>ECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>严格模式带来了三种具有破坏性的改变：</p>\n<ul>\n<li>语法改变：一些之前合法的语法在严格模式下面是不允许的。例如：<ul>\n<li>禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。</li>\n<li>删除一个<code>独立的标识符</code>（是一个变量，而不是一个属性）是不允许的。</li>\n<li>函数只能在作用域的顶层声明。</li>\n<li>更多的保留字： implements interface let package private protected public static yield 。</li>\n</ul>\n</li>\n<li>更多类型的错误。例如：<ul>\n<li>给一个未声明的变量赋值会抛出 <code>ReferenceError</code> 。而在非严格模式下，这样做就会创建一个全局变量。</li>\n<li>修改只读的属性（比如字符串的长度属性）会抛出 <code>TypeError</code> 。而在非严格模式下，不会产生任何效果。</li>\n</ul>\n</li>\n<li>不同的语义：在严格模式下，一些结构体会表现得不一样。例如：<ul>\n<li><code>arguments</code> 不再随着当前参数值的改变而改变。</li>\n<li>在非方法的函数中 <code>this</code> 为 <code>undefined</code> 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。</li>\n</ul>\n</li>\n</ul>\n<p>从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。</p>\n<h2 id=\"支持松散（非严格）模式\"><a href=\"#支持松散（非严格）模式\" class=\"headerlink\" title=\"支持松散（非严格）模式\"></a>支持松散（非严格）模式</h2><p><code>一个 JavaScript</code> 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。</p>\n<p>但是很不幸，有两个特性很难引入松散模式： <code>let</code> 声明和块级函数声明。让我们看看为什么很难引入和如何引入。</p>\n<h2 id=\"松散模式中的-let-声明\"><a href=\"#松散模式中的-let-声明\" class=\"headerlink\" title=\"松散模式中的 let 声明\"></a>松散模式中的 <code>let</code> 声明</h2><p><code>let</code> 使你能够声明块级变量。这很难被引入到松散模式，因为 <code>let</code> 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">let</span> = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span>[x] = <span class=\"string\">'abc'</span>;</span><br></pre></td></tr></table></figure>\n<p>在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 <code>let</code> 作为变量名。然后第二行会被解析为一个 <code>let</code> 变量声明（使用解构）。</p>\n<p>在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 <code>let</code> 声明。这种使用 <code>let</code> 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 <code>let</code> 声明的书写方式不会被误解：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;x,y&#125; = computeCoordinates();</span><br></pre></td></tr></table></figure>\n<h2 id=\"松散模式下的块级函数声明\"><a href=\"#松散模式下的块级函数声明\" class=\"headerlink\" title=\"松散模式下的块级函数声明\"></a>松散模式下的块级函数声明</h2><p>ECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。</p>\n<p>ECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics\" target=\"_blank\" rel=\"external\"> web 遗留的兼容语义</a>”，允许块中的函数声明在函数作用域范围内存在。</p>\n<h2 id=\"其它关键字\"><a href=\"#其它关键字\" class=\"headerlink\" title=\"其它关键字\"></a>其它关键字</h2><p>标识符 <code>yield</code> 和 <code>static</code> 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用：</p>\n<ul>\n<li>在松散模式下， <code>yield</code> 仅在生成器函数中是保留字。</li>\n<li><code>static</code> 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。</li>\n</ul>\n<h2 id=\"隐式的严格模式\"><a href=\"#隐式的严格模式\" class=\"headerlink\" title=\"隐式的严格模式\"></a>隐式的严格模式</h2><p>在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 <code>use strict</code> 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。</p>\n<p>其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。</p>\n<h2 id=\"无法修复的东西\"><a href=\"#无法修复的东西\" class=\"headerlink\" title=\"无法修复的东西\"></a>无法修复的东西</h2><p><code>一个 JavaScript</code>的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。</p>\n<p>第一个， <code>typeof null</code> 应该返回字符串 <code>null</code> 而不是 <code>object</code> ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; typeof Symbol.iterator</span><br><span class=\"line\">&apos;symbol&apos;</span><br></pre></td></tr></table></figure>\n<p>第二个，全局对象（浏览器中的 <code>window</code> 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 <code>let</code> 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>一个 JavaScript</code>意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。</p>\n<p>在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。</p>\n","excerpt":"<p>ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。</p>\n<p>那么，什么是“版本化”？什么又是“一个 JavaScript”呢？<br>","more":"</p>\n<h2 id=\"版本化\"><a href=\"#版本化\" class=\"headerlink\" title=\"版本化\"></a>版本化</h2><p>一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。</p>\n<p>如果代码库升级到新的语言版本，就有两种处理方式。</p>\n<p>第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。</p>\n<p>第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: application/ecmascript;version=6</span><br></pre></td></tr></table></figure>\n<p>也可以利用 <code>&lt;script&gt;</code> 标签的 <code>type</code> 属性来标记：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"application/ecmascript;version=6\"</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">    ···</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>也可以在代码内部标记版本（类似于 <code>&#39;use strict&#39;</code> ，放在 JavaScript 文件第一行）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use version <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n<p>这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。</p>\n<p>一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：</p>\n<ul>\n<li>引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。</li>\n<li>开发者需要记住版本之间的不同点。</li>\n<li>代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。</li>\n</ul>\n<p>因此，应该避免版本化，尤其是 JavaScript 和 web 。</p>\n<h2 id=\"一个-JavaScript\"><a href=\"#一个-JavaScript\" class=\"headerlink\" title=\"一个 JavaScript\"></a>一个 JavaScript</h2><p>既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？</p>\n<p>采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。</p>\n<p>我们可以增加新的特性，使已有的特性更加强大。</p>\n<p>这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“<a href=\"http://exploringjs.com/es6/ch_one-javascript.html#one-js_1\">一个 JavaScript </a>”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。</p>\n<p>“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 <code>let</code> 就是这样干的，它用于声明块级变量，是 <code>var</code> 的改进版。但是它并没有替换掉 <code>var</code> ，只是作为更好的方案与 <code>var</code> 并存。</p>\n<p>将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：</p>\n<ul>\n<li><code>let</code> 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span>[x] = arr;</span><br></pre></td></tr></table></figure>\n<p>调查发现， web 上没人会在非严格模式下这样使用 <code>let</code> 变量，这就使得 TC39 能够将 <code>let</code> 引入非严格模式中。</p>\n<h2 id=\"严格模式和-ES6\"><a href=\"#严格模式和-ES6\" class=\"headerlink\" title=\"严格模式和 ES6\"></a>严格模式和 ES6</h2><p>ECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br></pre></td></tr></table></figure>\n<p>严格模式带来了三种具有破坏性的改变：</p>\n<ul>\n<li>语法改变：一些之前合法的语法在严格模式下面是不允许的。例如：<ul>\n<li>禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。</li>\n<li>删除一个<code>独立的标识符</code>（是一个变量，而不是一个属性）是不允许的。</li>\n<li>函数只能在作用域的顶层声明。</li>\n<li>更多的保留字： implements interface let package private protected public static yield 。</li>\n</ul>\n</li>\n<li>更多类型的错误。例如：<ul>\n<li>给一个未声明的变量赋值会抛出 <code>ReferenceError</code> 。而在非严格模式下，这样做就会创建一个全局变量。</li>\n<li>修改只读的属性（比如字符串的长度属性）会抛出 <code>TypeError</code> 。而在非严格模式下，不会产生任何效果。</li>\n</ul>\n</li>\n<li>不同的语义：在严格模式下，一些结构体会表现得不一样。例如：<ul>\n<li><code>arguments</code> 不再随着当前参数值的改变而改变。</li>\n<li>在非方法的函数中 <code>this</code> 为 <code>undefined</code> 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。</li>\n</ul>\n</li>\n</ul>\n<p>从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。</p>\n<h2 id=\"支持松散（非严格）模式\"><a href=\"#支持松散（非严格）模式\" class=\"headerlink\" title=\"支持松散（非严格）模式\"></a>支持松散（非严格）模式</h2><p><code>一个 JavaScript</code> 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。</p>\n<p>但是很不幸，有两个特性很难引入松散模式： <code>let</code> 声明和块级函数声明。让我们看看为什么很难引入和如何引入。</p>\n<h2 id=\"松散模式中的-let-声明\"><a href=\"#松散模式中的-let-声明\" class=\"headerlink\" title=\"松散模式中的 let 声明\"></a>松散模式中的 <code>let</code> 声明</h2><p><code>let</code> 使你能够声明块级变量。这很难被引入到松散模式，因为 <code>let</code> 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">let</span> = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span>[x] = <span class=\"string\">'abc'</span>;</span><br></pre></td></tr></table></figure>\n<p>在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 <code>let</code> 作为变量名。然后第二行会被解析为一个 <code>let</code> 变量声明（使用解构）。</p>\n<p>在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 <code>let</code> 声明。这种使用 <code>let</code> 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 <code>let</code> 声明的书写方式不会被误解：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123;x,y&#125; = computeCoordinates();</span><br></pre></td></tr></table></figure>\n<h2 id=\"松散模式下的块级函数声明\"><a href=\"#松散模式下的块级函数声明\" class=\"headerlink\" title=\"松散模式下的块级函数声明\"></a>松散模式下的块级函数声明</h2><p>ECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。</p>\n<p>ECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics\"> web 遗留的兼容语义</a>”，允许块中的函数声明在函数作用域范围内存在。</p>\n<h2 id=\"其它关键字\"><a href=\"#其它关键字\" class=\"headerlink\" title=\"其它关键字\"></a>其它关键字</h2><p>标识符 <code>yield</code> 和 <code>static</code> 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用：</p>\n<ul>\n<li>在松散模式下， <code>yield</code> 仅在生成器函数中是保留字。</li>\n<li><code>static</code> 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。</li>\n</ul>\n<h2 id=\"隐式的严格模式\"><a href=\"#隐式的严格模式\" class=\"headerlink\" title=\"隐式的严格模式\"></a>隐式的严格模式</h2><p>在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 <code>use strict</code> 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。</p>\n<p>其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。</p>\n<h2 id=\"无法修复的东西\"><a href=\"#无法修复的东西\" class=\"headerlink\" title=\"无法修复的东西\"></a>无法修复的东西</h2><p><code>一个 JavaScript</code>的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。</p>\n<p>第一个， <code>typeof null</code> 应该返回字符串 <code>null</code> 而不是 <code>object</code> ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; typeof Symbol.iterator</span><br><span class=\"line\">&apos;symbol&apos;</span><br></pre></td></tr></table></figure>\n<p>第二个，全局对象（浏览器中的 <code>window</code> 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 <code>let</code> 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><code>一个 JavaScript</code>意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。</p>\n<p>在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。</p>"},{"title":"oracle 安装","date":"2016-05-23T04:13:00.000Z","excerpt":"<p>这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。</p>\n<p>本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。<br>","_content":"\n这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。\n\n本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。\n<!-- more -->\n\n## 基本环境和工具\n\n- 基于 Parallels Desktop 10 的 windows 10 操作系统；\n- JDK 1.8；\n- Oracle 11g。\n\n其中， Oracle 11g 的下载地址是 [win64_11gR2_database_1of2.zip](http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html) 、 [win64_11gR2_database_2of2.zip](http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html)。\n\n## 第一次安装\n\n第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 `jdbc:oracle:thin:@10.211.55.4:1521:orcl` （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。\n\n后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。\n\n如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑：\n\n- client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！\n- 在 OS X 下面要手动配置各种环境变量。\n\n## 第二次安装（卸载重装）\n\n某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。\n\n网上搜了一些资料，没找到正确的处理方式，于是决定重装。\n\n重装的第一步是卸载。\n\n### 卸载\n\n很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。\n\n于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。\n\n后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 `sc delete serviceName` 命令删除服务。\n\n这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用`鼠标右键->删除`的方式，结果发现被占用了，无法删除，此时可以到`资源监视器 -> cpu 标签 -> 关联的句柄`里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。\n\n这样卸载完之后，就开始安装了。\n\n### 重装\n\n按照第一次的安装流程来，一步一步的，比较顺利。\n\n但是，在创建数据库的时候，老是说 `local_listener=LISTENER_ORCL` 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。\n\n后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。\n\n## 总结\n\n- 这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。\n- 相对于 MySQL ，Oracle 入门配置真特么麻烦。\n- 做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。\n","source":"_posts/oracle安装.md","raw":"---\ntitle: oracle 安装\ndate: 2016-05-23 12:13\nexcerpt: 本文记录了 oracle 的安装探索过程。\ntags:\n- oracle\n- 数据库\n---\n\n这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。\n\n本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。\n<!-- more -->\n\n## 基本环境和工具\n\n- 基于 Parallels Desktop 10 的 windows 10 操作系统；\n- JDK 1.8；\n- Oracle 11g。\n\n其中， Oracle 11g 的下载地址是 [win64_11gR2_database_1of2.zip](http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html) 、 [win64_11gR2_database_2of2.zip](http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html)。\n\n## 第一次安装\n\n第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 `jdbc:oracle:thin:@10.211.55.4:1521:orcl` （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。\n\n后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。\n\n如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑：\n\n- client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！\n- 在 OS X 下面要手动配置各种环境变量。\n\n## 第二次安装（卸载重装）\n\n某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。\n\n网上搜了一些资料，没找到正确的处理方式，于是决定重装。\n\n重装的第一步是卸载。\n\n### 卸载\n\n很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。\n\n于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。\n\n后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 `sc delete serviceName` 命令删除服务。\n\n这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用`鼠标右键->删除`的方式，结果发现被占用了，无法删除，此时可以到`资源监视器 -> cpu 标签 -> 关联的句柄`里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。\n\n这样卸载完之后，就开始安装了。\n\n### 重装\n\n按照第一次的安装流程来，一步一步的，比较顺利。\n\n但是，在创建数据库的时候，老是说 `local_listener=LISTENER_ORCL` 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。\n\n后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。\n\n## 总结\n\n- 这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。\n- 相对于 MySQL ，Oracle 入门配置真特么麻烦。\n- 做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。\n","slug":"oracle安装","published":1,"updated":"2016-06-08T10:35:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndw000an407g6fzxnz4","content":"<p>这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。</p>\n<p>本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。<br><a id=\"more\"></a></p>\n<h2 id=\"基本环境和工具\"><a href=\"#基本环境和工具\" class=\"headerlink\" title=\"基本环境和工具\"></a>基本环境和工具</h2><ul>\n<li>基于 Parallels Desktop 10 的 windows 10 操作系统；</li>\n<li>JDK 1.8；</li>\n<li>Oracle 11g。</li>\n</ul>\n<p>其中， Oracle 11g 的下载地址是 <a href=\"http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html\" target=\"_blank\" rel=\"external\">win64_11gR2_database_1of2.zip</a> 、 <a href=\"http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html\" target=\"_blank\" rel=\"external\">win64_11gR2_database_2of2.zip</a>。</p>\n<h2 id=\"第一次安装\"><a href=\"#第一次安装\" class=\"headerlink\" title=\"第一次安装\"></a>第一次安装</h2><p>第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 <code>jdbc:oracle:thin:@10.211.55.4:1521:orcl</code> （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。</p>\n<p>后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。</p>\n<p>如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑：</p>\n<ul>\n<li>client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！</li>\n<li>在 OS X 下面要手动配置各种环境变量。</li>\n</ul>\n<h2 id=\"第二次安装（卸载重装）\"><a href=\"#第二次安装（卸载重装）\" class=\"headerlink\" title=\"第二次安装（卸载重装）\"></a>第二次安装（卸载重装）</h2><p>某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。</p>\n<p>网上搜了一些资料，没找到正确的处理方式，于是决定重装。</p>\n<p>重装的第一步是卸载。</p>\n<h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><p>很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。</p>\n<p>于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。</p>\n<p>后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 <code>sc delete serviceName</code> 命令删除服务。</p>\n<p>这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用<code>鼠标右键-&gt;删除</code>的方式，结果发现被占用了，无法删除，此时可以到<code>资源监视器 -&gt; cpu 标签 -&gt; 关联的句柄</code>里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。</p>\n<p>这样卸载完之后，就开始安装了。</p>\n<h3 id=\"重装\"><a href=\"#重装\" class=\"headerlink\" title=\"重装\"></a>重装</h3><p>按照第一次的安装流程来，一步一步的，比较顺利。</p>\n<p>但是，在创建数据库的时候，老是说 <code>local_listener=LISTENER_ORCL</code> 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。</p>\n<p>后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。</li>\n<li>相对于 MySQL ，Oracle 入门配置真特么麻烦。</li>\n<li>做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。</li>\n</ul>\n","more":"</p>\n<h2 id=\"基本环境和工具\"><a href=\"#基本环境和工具\" class=\"headerlink\" title=\"基本环境和工具\"></a>基本环境和工具</h2><ul>\n<li>基于 Parallels Desktop 10 的 windows 10 操作系统；</li>\n<li>JDK 1.8；</li>\n<li>Oracle 11g。</li>\n</ul>\n<p>其中， Oracle 11g 的下载地址是 <a href=\"http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html\">win64_11gR2_database_1of2.zip</a> 、 <a href=\"http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html\">win64_11gR2_database_2of2.zip</a>。</p>\n<h2 id=\"第一次安装\"><a href=\"#第一次安装\" class=\"headerlink\" title=\"第一次安装\"></a>第一次安装</h2><p>第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 <code>jdbc:oracle:thin:@10.211.55.4:1521:orcl</code> （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。</p>\n<p>后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。</p>\n<p>如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑：</p>\n<ul>\n<li>client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！</li>\n<li>在 OS X 下面要手动配置各种环境变量。</li>\n</ul>\n<h2 id=\"第二次安装（卸载重装）\"><a href=\"#第二次安装（卸载重装）\" class=\"headerlink\" title=\"第二次安装（卸载重装）\"></a>第二次安装（卸载重装）</h2><p>某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。</p>\n<p>网上搜了一些资料，没找到正确的处理方式，于是决定重装。</p>\n<p>重装的第一步是卸载。</p>\n<h3 id=\"卸载\"><a href=\"#卸载\" class=\"headerlink\" title=\"卸载\"></a>卸载</h3><p>很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。</p>\n<p>于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。</p>\n<p>后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 <code>sc delete serviceName</code> 命令删除服务。</p>\n<p>这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用<code>鼠标右键-&gt;删除</code>的方式，结果发现被占用了，无法删除，此时可以到<code>资源监视器 -&gt; cpu 标签 -&gt; 关联的句柄</code>里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。</p>\n<p>这样卸载完之后，就开始安装了。</p>\n<h3 id=\"重装\"><a href=\"#重装\" class=\"headerlink\" title=\"重装\"></a>重装</h3><p>按照第一次的安装流程来，一步一步的，比较顺利。</p>\n<p>但是，在创建数据库的时候，老是说 <code>local_listener=LISTENER_ORCL</code> 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。</p>\n<p>后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。</li>\n<li>相对于 MySQL ，Oracle 入门配置真特么麻烦。</li>\n<li>做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。</li>\n</ul>"},{"title":"一些 core javascript 的基础知识","date":"2014-10-22T14:13:00.000Z","_content":"\n### 一、 setTimeout\n\n```js\nsetTimtout(function(){\n   alert(2);                           // 后弹出\n},0);\nalert(1);                              // 先弹出\n```\n\n对于如上代码，包含原理如下：\n\n* 1、首先 jsvm 只会执行一个线程；\n* 2、当这个线程遇到 `setTimout()` 的时候，就会将这个 function 放到某个队列里面；\n* 3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。\n<!-- more -->\n\n比较简单典型的一个应用场景就是：\n\n```js\n$(elem).html(xxxxxx);\n\nsetTimeout(function() {\n  // 内部DOM操作很复杂，此处setTimeout用于保证在内部DOM操作结束并且相关内存被释放掉后执行后续代码\n}, 0);\n```\n\n### 二、 eval\n\njs 中除了全局作用域和函数作用域之外，还存在一个 eval 作用域。\n\neval 函数执行的时候，会根据当前执行上下文创建一个作用域。\n\n此处有如下代码：\n\n```js\nfunction a() {\n  var b = new SomeThing();\n  return function() {\n    eval('');\n  };\n}\n```\n\n### 三、预编译\n\n先分别上如下几个片段的代码：\n\n```html\n<html>\n<head>\n<script>\na();\nfunction a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n```html\n<html>\n<head>\n<script>\na();\n</script>\n\n<script>\nfunction a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n```html\n<html>\n<head>\n<script>\na();\nvar b = function a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n执行结果分别是：\n\n* 第一段代码：弹出1；\n* 第二段代码：第一个script片段报错，a不存在；\n* 第三段代码：报错，a不存在；\n\n原因：\n\n* 第一段代码中，jsvm会预编译，构造好a函数，所以访问a函数的顺序是不重要的；\n* 第二段代码中，预编译是会分代码块执行的，每个script都会形成一个代码块，即便script是通过src引入js的；\n* 第三段代码中，a函数的定义由于放在了一个表达式当中，因此jsvm不会预编译。\n\n但是，此处还可以继续深入，第三段代码改成如下所示：\n\n```html\n<html>\n<head>\n<script>\nvar b = function a(){\n  alert(1);\n}\na();\n</script>\n</head>\n<body></body>\n</html>\n```\n\n这段代码也同样会报错， a 不存在。为什么呢？原因就是 a 函数放在了表达式当中， jsvm 会把 a 函数看作一个匿名函数，因此在当前语句执行完， a 就被释放掉了。\n\n但是，请注意，上面讨论的都是根据 w3c 标准得出的结果，在第三段和第四段代码中，IE 6、7、8还是会预编译的，并且不会释放掉a，因此不会报错。\n\n### 四、自执行函数\n\n自执行函数的几种形式：\n\n```js\n(function() {})();\n(function() {}());\n!function(){}();\nvoid function(){}();\n```\n\n其中第三种写法会造成额外的运算，因为要对返回的内容做“非”操作。\n\n### 五、预编译中的变量声明\n\n如下代码：\n\n```js\nfunction a(x){\n  return x*2;\n}\nvar a;\nalert(a);\n```\n\n`var a` 只是声明，并不会干啥， `var a` 只会让当前作用域的 `alert(a)` 不会报 a 不存在的错误， a 实际上是什么，需要显示赋值；如果 `var a` 之前已经存在 a 了，则啥也不干。\n\n### 六、 function 传参\n\n如下代码：\n\n```js\nfunction fn1(a, b, c){\n   a = 1.2;\n   b = 2.2;\n   c.c = 3.2;\n}\n\nvar a = 1;\nvar b = 2;\nvar c = {c:3};\n\nfn1(a,b,c);\n\nalert(a);\nalert(b);\nalert(c.c);\n```\n\n原理不难理解，注意值类型和引用类型的区别。\n\n### 七、作用域链\n\n有如下几点：\n\n* 1、作用域链是在定义的时候就确定下来了的；\n* 2、隐式对象模型：对于一个作用域， jsvm 会创建一个隐式对象，然后在这个对象上面绑定当前作用域的各种变量。多个函数的嵌套定义也就会形成一条作用域链了。如果在某个作用域中要访问一个 a 变量，则会首先在当前作用域中查找是否存在 a 变量，如果不存在，则向上找父作用域隐式对象中是否存在 a 变量，依次类推，如果到了根作用域还找不到 a 变量的话，就会报错了。\n\n### 八、类数组结构\n\n第一个问题，如何构造类数组结构？思路简单，不赘述。\n\njquery 选择器构造出来的就是一个类数组结构。\n\n### 九、工厂模式\n\n```js\nfunction factory() {\n  return new ThisIsAClass();\n}\n```\n","source":"_posts/一些 core javascript 的基础知识.md","raw":"---\ntitle: 一些 core javascript 的基础知识\ndate: 2014-10-22 22:13\n---\n\n### 一、 setTimeout\n\n```js\nsetTimtout(function(){\n   alert(2);                           // 后弹出\n},0);\nalert(1);                              // 先弹出\n```\n\n对于如上代码，包含原理如下：\n\n* 1、首先 jsvm 只会执行一个线程；\n* 2、当这个线程遇到 `setTimout()` 的时候，就会将这个 function 放到某个队列里面；\n* 3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。\n<!-- more -->\n\n比较简单典型的一个应用场景就是：\n\n```js\n$(elem).html(xxxxxx);\n\nsetTimeout(function() {\n  // 内部DOM操作很复杂，此处setTimeout用于保证在内部DOM操作结束并且相关内存被释放掉后执行后续代码\n}, 0);\n```\n\n### 二、 eval\n\njs 中除了全局作用域和函数作用域之外，还存在一个 eval 作用域。\n\neval 函数执行的时候，会根据当前执行上下文创建一个作用域。\n\n此处有如下代码：\n\n```js\nfunction a() {\n  var b = new SomeThing();\n  return function() {\n    eval('');\n  };\n}\n```\n\n### 三、预编译\n\n先分别上如下几个片段的代码：\n\n```html\n<html>\n<head>\n<script>\na();\nfunction a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n```html\n<html>\n<head>\n<script>\na();\n</script>\n\n<script>\nfunction a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n```html\n<html>\n<head>\n<script>\na();\nvar b = function a(){\n  alert(1);\n}\n</script>\n</head>\n<body></body>\n</html>\n```\n\n执行结果分别是：\n\n* 第一段代码：弹出1；\n* 第二段代码：第一个script片段报错，a不存在；\n* 第三段代码：报错，a不存在；\n\n原因：\n\n* 第一段代码中，jsvm会预编译，构造好a函数，所以访问a函数的顺序是不重要的；\n* 第二段代码中，预编译是会分代码块执行的，每个script都会形成一个代码块，即便script是通过src引入js的；\n* 第三段代码中，a函数的定义由于放在了一个表达式当中，因此jsvm不会预编译。\n\n但是，此处还可以继续深入，第三段代码改成如下所示：\n\n```html\n<html>\n<head>\n<script>\nvar b = function a(){\n  alert(1);\n}\na();\n</script>\n</head>\n<body></body>\n</html>\n```\n\n这段代码也同样会报错， a 不存在。为什么呢？原因就是 a 函数放在了表达式当中， jsvm 会把 a 函数看作一个匿名函数，因此在当前语句执行完， a 就被释放掉了。\n\n但是，请注意，上面讨论的都是根据 w3c 标准得出的结果，在第三段和第四段代码中，IE 6、7、8还是会预编译的，并且不会释放掉a，因此不会报错。\n\n### 四、自执行函数\n\n自执行函数的几种形式：\n\n```js\n(function() {})();\n(function() {}());\n!function(){}();\nvoid function(){}();\n```\n\n其中第三种写法会造成额外的运算，因为要对返回的内容做“非”操作。\n\n### 五、预编译中的变量声明\n\n如下代码：\n\n```js\nfunction a(x){\n  return x*2;\n}\nvar a;\nalert(a);\n```\n\n`var a` 只是声明，并不会干啥， `var a` 只会让当前作用域的 `alert(a)` 不会报 a 不存在的错误， a 实际上是什么，需要显示赋值；如果 `var a` 之前已经存在 a 了，则啥也不干。\n\n### 六、 function 传参\n\n如下代码：\n\n```js\nfunction fn1(a, b, c){\n   a = 1.2;\n   b = 2.2;\n   c.c = 3.2;\n}\n\nvar a = 1;\nvar b = 2;\nvar c = {c:3};\n\nfn1(a,b,c);\n\nalert(a);\nalert(b);\nalert(c.c);\n```\n\n原理不难理解，注意值类型和引用类型的区别。\n\n### 七、作用域链\n\n有如下几点：\n\n* 1、作用域链是在定义的时候就确定下来了的；\n* 2、隐式对象模型：对于一个作用域， jsvm 会创建一个隐式对象，然后在这个对象上面绑定当前作用域的各种变量。多个函数的嵌套定义也就会形成一条作用域链了。如果在某个作用域中要访问一个 a 变量，则会首先在当前作用域中查找是否存在 a 变量，如果不存在，则向上找父作用域隐式对象中是否存在 a 变量，依次类推，如果到了根作用域还找不到 a 变量的话，就会报错了。\n\n### 八、类数组结构\n\n第一个问题，如何构造类数组结构？思路简单，不赘述。\n\njquery 选择器构造出来的就是一个类数组结构。\n\n### 九、工厂模式\n\n```js\nfunction factory() {\n  return new ThisIsAClass();\n}\n```\n","slug":"一些 core javascript 的基础知识","published":1,"updated":"2016-06-08T09:51:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkndy000bn407w7avukbs","content":"<h3 id=\"一、-setTimeout\"><a href=\"#一、-setTimeout\" class=\"headerlink\" title=\"一、 setTimeout\"></a>一、 setTimeout</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimtout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"number\">2</span>);                           <span class=\"comment\">// 后弹出</span></span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">alert(<span class=\"number\">1</span>);                              <span class=\"comment\">// 先弹出</span></span><br></pre></td></tr></table></figure>\n<p>对于如上代码，包含原理如下：</p>\n<ul>\n<li>1、首先 jsvm 只会执行一个线程；</li>\n<li>2、当这个线程遇到 <code>setTimout()</code> 的时候，就会将这个 function 放到某个队列里面；</li>\n<li>3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。<a id=\"more\"></a>\n</li>\n</ul>\n<p>比较简单典型的一个应用场景就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(elem).html(xxxxxx);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 内部DOM操作很复杂，此处setTimeout用于保证在内部DOM操作结束并且相关内存被释放掉后执行后续代码</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、-eval\"><a href=\"#二、-eval\" class=\"headerlink\" title=\"二、 eval\"></a>二、 eval</h3><p>js 中除了全局作用域和函数作用域之外，还存在一个 eval 作用域。</p>\n<p>eval 函数执行的时候，会根据当前执行上下文创建一个作用域。</p>\n<p>此处有如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> SomeThing();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、预编译\"><a href=\"#三、预编译\" class=\"headerlink\" title=\"三、预编译\"></a>三、预编译</h3><p>先分别上如下几个片段的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行结果分别是：</p>\n<ul>\n<li>第一段代码：弹出1；</li>\n<li>第二段代码：第一个script片段报错，a不存在；</li>\n<li>第三段代码：报错，a不存在；</li>\n</ul>\n<p>原因：</p>\n<ul>\n<li>第一段代码中，jsvm会预编译，构造好a函数，所以访问a函数的顺序是不重要的；</li>\n<li>第二段代码中，预编译是会分代码块执行的，每个script都会形成一个代码块，即便script是通过src引入js的；</li>\n<li>第三段代码中，a函数的定义由于放在了一个表达式当中，因此jsvm不会预编译。</li>\n</ul>\n<p>但是，此处还可以继续深入，第三段代码改成如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码也同样会报错， a 不存在。为什么呢？原因就是 a 函数放在了表达式当中， jsvm 会把 a 函数看作一个匿名函数，因此在当前语句执行完， a 就被释放掉了。</p>\n<p>但是，请注意，上面讨论的都是根据 w3c 标准得出的结果，在第三段和第四段代码中，IE 6、7、8还是会预编译的，并且不会释放掉a，因此不会报错。</p>\n<h3 id=\"四、自执行函数\"><a href=\"#四、自执行函数\" class=\"headerlink\" title=\"四、自执行函数\"></a>四、自执行函数</h3><p>自执行函数的几种形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;());</span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;();</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;();</span><br></pre></td></tr></table></figure>\n<p>其中第三种写法会造成额外的运算，因为要对返回的内容做“非”操作。</p>\n<h3 id=\"五、预编译中的变量声明\"><a href=\"#五、预编译中的变量声明\" class=\"headerlink\" title=\"五、预编译中的变量声明\"></a>五、预编译中的变量声明</h3><p>如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure>\n<p><code>var a</code> 只是声明，并不会干啥， <code>var a</code> 只会让当前作用域的 <code>alert(a)</code> 不会报 a 不存在的错误， a 实际上是什么，需要显示赋值；如果 <code>var a</code> 之前已经存在 a 了，则啥也不干。</p>\n<h3 id=\"六、-function-传参\"><a href=\"#六、-function-传参\" class=\"headerlink\" title=\"六、 function 传参\"></a>六、 function 传参</h3><p>如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">   a = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">   b = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">   c.c = <span class=\"number\">3.2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;c:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fn1(a,b,c);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(a);</span><br><span class=\"line\">alert(b);</span><br><span class=\"line\">alert(c.c);</span><br></pre></td></tr></table></figure>\n<p>原理不难理解，注意值类型和引用类型的区别。</p>\n<h3 id=\"七、作用域链\"><a href=\"#七、作用域链\" class=\"headerlink\" title=\"七、作用域链\"></a>七、作用域链</h3><p>有如下几点：</p>\n<ul>\n<li>1、作用域链是在定义的时候就确定下来了的；</li>\n<li>2、隐式对象模型：对于一个作用域， jsvm 会创建一个隐式对象，然后在这个对象上面绑定当前作用域的各种变量。多个函数的嵌套定义也就会形成一条作用域链了。如果在某个作用域中要访问一个 a 变量，则会首先在当前作用域中查找是否存在 a 变量，如果不存在，则向上找父作用域隐式对象中是否存在 a 变量，依次类推，如果到了根作用域还找不到 a 变量的话，就会报错了。</li>\n</ul>\n<h3 id=\"八、类数组结构\"><a href=\"#八、类数组结构\" class=\"headerlink\" title=\"八、类数组结构\"></a>八、类数组结构</h3><p>第一个问题，如何构造类数组结构？思路简单，不赘述。</p>\n<p>jquery 选择器构造出来的就是一个类数组结构。</p>\n<h3 id=\"九、工厂模式\"><a href=\"#九、工厂模式\" class=\"headerlink\" title=\"九、工厂模式\"></a>九、工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThisIsAClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"一、-setTimeout\"><a href=\"#一、-setTimeout\" class=\"headerlink\" title=\"一、 setTimeout\"></a>一、 setTimeout</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimtout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   alert(<span class=\"number\">2</span>);                           <span class=\"comment\">// 后弹出</span></span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\">alert(<span class=\"number\">1</span>);                              <span class=\"comment\">// 先弹出</span></span><br></pre></td></tr></table></figure>\n<p>对于如上代码，包含原理如下：</p>\n<ul>\n<li>1、首先 jsvm 只会执行一个线程；</li>\n<li>2、当这个线程遇到 <code>setTimout()</code> 的时候，就会将这个 function 放到某个队列里面；</li>\n<li>3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。","more":"</li>\n</ul>\n<p>比较简单典型的一个应用场景就是：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(elem).html(xxxxxx);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 内部DOM操作很复杂，此处setTimeout用于保证在内部DOM操作结束并且相关内存被释放掉后执行后续代码</span></span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二、-eval\"><a href=\"#二、-eval\" class=\"headerlink\" title=\"二、 eval\"></a>二、 eval</h3><p>js 中除了全局作用域和函数作用域之外，还存在一个 eval 作用域。</p>\n<p>eval 函数执行的时候，会根据当前执行上下文创建一个作用域。</p>\n<p>此处有如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> SomeThing();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三、预编译\"><a href=\"#三、预编译\" class=\"headerlink\" title=\"三、预编译\"></a>三、预编译</h3><p>先分别上如下几个片段的代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\">a();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>执行结果分别是：</p>\n<ul>\n<li>第一段代码：弹出1；</li>\n<li>第二段代码：第一个script片段报错，a不存在；</li>\n<li>第三段代码：报错，a不存在；</li>\n</ul>\n<p>原因：</p>\n<ul>\n<li>第一段代码中，jsvm会预编译，构造好a函数，所以访问a函数的顺序是不重要的；</li>\n<li>第二段代码中，预编译是会分代码块执行的，每个script都会形成一个代码块，即便script是通过src引入js的；</li>\n<li>第三段代码中，a函数的定义由于放在了一个表达式当中，因此jsvm不会预编译。</li>\n</ul>\n<p>但是，此处还可以继续深入，第三段代码改成如下所示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这段代码也同样会报错， a 不存在。为什么呢？原因就是 a 函数放在了表达式当中， jsvm 会把 a 函数看作一个匿名函数，因此在当前语句执行完， a 就被释放掉了。</p>\n<p>但是，请注意，上面讨论的都是根据 w3c 标准得出的结果，在第三段和第四段代码中，IE 6、7、8还是会预编译的，并且不会释放掉a，因此不会报错。</p>\n<h3 id=\"四、自执行函数\"><a href=\"#四、自执行函数\" class=\"headerlink\" title=\"四、自执行函数\"></a>四、自执行函数</h3><p>自执行函数的几种形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;)();</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;());</span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;();</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;();</span><br></pre></td></tr></table></figure>\n<p>其中第三种写法会造成额外的运算，因为要对返回的内容做“非”操作。</p>\n<h3 id=\"五、预编译中的变量声明\"><a href=\"#五、预编译中的变量声明\" class=\"headerlink\" title=\"五、预编译中的变量声明\"></a>五、预编译中的变量声明</h3><p>如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">alert(a);</span><br></pre></td></tr></table></figure>\n<p><code>var a</code> 只是声明，并不会干啥， <code>var a</code> 只会让当前作用域的 <code>alert(a)</code> 不会报 a 不存在的错误， a 实际上是什么，需要显示赋值；如果 <code>var a</code> 之前已经存在 a 了，则啥也不干。</p>\n<h3 id=\"六、-function-传参\"><a href=\"#六、-function-传参\" class=\"headerlink\" title=\"六、 function 传参\"></a>六、 function 传参</h3><p>如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\">a, b, c</span>)</span>&#123;</span><br><span class=\"line\">   a = <span class=\"number\">1.2</span>;</span><br><span class=\"line\">   b = <span class=\"number\">2.2</span>;</span><br><span class=\"line\">   c.c = <span class=\"number\">3.2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c = &#123;c:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">fn1(a,b,c);</span><br><span class=\"line\"></span><br><span class=\"line\">alert(a);</span><br><span class=\"line\">alert(b);</span><br><span class=\"line\">alert(c.c);</span><br></pre></td></tr></table></figure>\n<p>原理不难理解，注意值类型和引用类型的区别。</p>\n<h3 id=\"七、作用域链\"><a href=\"#七、作用域链\" class=\"headerlink\" title=\"七、作用域链\"></a>七、作用域链</h3><p>有如下几点：</p>\n<ul>\n<li>1、作用域链是在定义的时候就确定下来了的；</li>\n<li>2、隐式对象模型：对于一个作用域， jsvm 会创建一个隐式对象，然后在这个对象上面绑定当前作用域的各种变量。多个函数的嵌套定义也就会形成一条作用域链了。如果在某个作用域中要访问一个 a 变量，则会首先在当前作用域中查找是否存在 a 变量，如果不存在，则向上找父作用域隐式对象中是否存在 a 变量，依次类推，如果到了根作用域还找不到 a 变量的话，就会报错了。</li>\n</ul>\n<h3 id=\"八、类数组结构\"><a href=\"#八、类数组结构\" class=\"headerlink\" title=\"八、类数组结构\"></a>八、类数组结构</h3><p>第一个问题，如何构造类数组结构？思路简单，不赘述。</p>\n<p>jquery 选择器构造出来的就是一个类数组结构。</p>\n<h3 id=\"九、工厂模式\"><a href=\"#九、工厂模式\" class=\"headerlink\" title=\"九、工厂模式\"></a>九、工厂模式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factory</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThisIsAClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"使用 marked 解析 markdown","date":"2016-05-20T05:49:00.000Z","_content":"\n[marked](https://github.com/chjj/marked) 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。\n\n最简单直接的一种使用方式：\n\n```js\nvar marked = require('marked');\nconsole.log(marked('I am using __markdown__.'));\n// Outputs: <p>I am using <strong>markdown</strong>.</p>\n```\n<!-- more -->\n\nmarked 库主要提供了一个 marked 函数，该函数声明为：\n\n```\ntype OptionsType = {\n    highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=,\n    renderer: marked.Renderer=,\n    gfm: boolean=,\n    tables: boolean=,\n    breaks: boolean=,\n    pedantic: boolean=,\n    sanitize: boolean=,\n    smartLists: boolean=\n};\nmarked(markdownString: string, options: OptionsType=, callback: Function=): string;\n```\n\n其中，marked 可以通过 renderer 配置提供了自定义解析途径。\n\nrenderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法：\n\n- code(string code, string language)\n- blockquote(string quote)\n- html(string html)\n- heading(string text, number level)\n- hr()\n- list(string body, boolean ordered)\n- listitem(string text)\n- paragraph(string text)\n- table(string header, string body)\n- tablerow(string content)\n- tablecell(string content, object flags)\n- strong(string text)\n- em(string text)\n- codespan(string code)\n- br()\n- del(string text)\n- link(string href, string title, string text)\n- image(string href, string title, string text)\n\n所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。\n\nmarked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。\n\n以上就是 marked 最基本最核心的用法了。\n\n其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。\n\n## markdown 缩进问题\n\n在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。\n\n现在前端开发，经常会使用一些模板引擎，比如 [ETPL](https://github.com/ecomfe/etpl) ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    return marked(source);\n});\n```\n\n此时在对应的模板中，就可以使用该过滤器了：\n\n```html\n<div>\n    <!-- filter: markdown() -->\n    ### 标题\n\n    内容\n    <!-- /filter -->\n</div>\n```\n\n此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。\n\n为什么会这样呢？\n\n如果打印一下 markdown 过滤器处理函数中的 source 参数：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    console.log(source);\n    return marked(source);\n});\n```\n\n可以发现，打印出来的内容会是这个样子：\n\n```\n\"\n    ### 标题\n\n    内容\n    \"\n```\n\n第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。\n\n这明显跟 markdown 语法有冲突，必须要进行如下处理：\n\n* 1、第一行和最后一行没啥实际内容，可以去掉；\n* 2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 `n` ；\n* 3、将每一行前面的 `n` 个空格去掉。\n\n具体的代码实现如下：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    source = source.replace(/(^\\n+|\\n+$)/g, '');\n    var uselessSpaceCount = source.match(/^\\s*/)[0].length;\n    source = source.replace(new RegExp('^ {' + uselessSpaceCount + '}', 'gm'), '');\n    return marked(source);\n});\n```\n\n## HTML 标签\n\n有的时候，可能想给 markdown 标记的某一块加上背景色，比如：\n\n```html\n<!-- filter: markdown() -->\n<div class=\"background-red\">\n### 标题\n\n内容\n</div>\n<!-- /filter -->\n```\n\n这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！\n\n解决方法就是把 div 放过滤器外边吧：\n\n```html\n<div class=\"background-red\">\n<!-- filter: markdown() -->\n### 标题\n\n内容\n<!-- /filter -->\n</div>\n```\n","source":"_posts/使用marked解析markdown.md","raw":"---\ntitle: 使用 marked 解析 markdown\ndate: 2016-05-20 13:49:00\n---\n\n[marked](https://github.com/chjj/marked) 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。\n\n最简单直接的一种使用方式：\n\n```js\nvar marked = require('marked');\nconsole.log(marked('I am using __markdown__.'));\n// Outputs: <p>I am using <strong>markdown</strong>.</p>\n```\n<!-- more -->\n\nmarked 库主要提供了一个 marked 函数，该函数声明为：\n\n```\ntype OptionsType = {\n    highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=,\n    renderer: marked.Renderer=,\n    gfm: boolean=,\n    tables: boolean=,\n    breaks: boolean=,\n    pedantic: boolean=,\n    sanitize: boolean=,\n    smartLists: boolean=\n};\nmarked(markdownString: string, options: OptionsType=, callback: Function=): string;\n```\n\n其中，marked 可以通过 renderer 配置提供了自定义解析途径。\n\nrenderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法：\n\n- code(string code, string language)\n- blockquote(string quote)\n- html(string html)\n- heading(string text, number level)\n- hr()\n- list(string body, boolean ordered)\n- listitem(string text)\n- paragraph(string text)\n- table(string header, string body)\n- tablerow(string content)\n- tablecell(string content, object flags)\n- strong(string text)\n- em(string text)\n- codespan(string code)\n- br()\n- del(string text)\n- link(string href, string title, string text)\n- image(string href, string title, string text)\n\n所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。\n\nmarked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。\n\n以上就是 marked 最基本最核心的用法了。\n\n其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。\n\n## markdown 缩进问题\n\n在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。\n\n现在前端开发，经常会使用一些模板引擎，比如 [ETPL](https://github.com/ecomfe/etpl) ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    return marked(source);\n});\n```\n\n此时在对应的模板中，就可以使用该过滤器了：\n\n```html\n<div>\n    <!-- filter: markdown() -->\n    ### 标题\n\n    内容\n    <!-- /filter -->\n</div>\n```\n\n此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。\n\n为什么会这样呢？\n\n如果打印一下 markdown 过滤器处理函数中的 source 参数：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    console.log(source);\n    return marked(source);\n});\n```\n\n可以发现，打印出来的内容会是这个样子：\n\n```\n\"\n    ### 标题\n\n    内容\n    \"\n```\n\n第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。\n\n这明显跟 markdown 语法有冲突，必须要进行如下处理：\n\n* 1、第一行和最后一行没啥实际内容，可以去掉；\n* 2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 `n` ；\n* 3、将每一行前面的 `n` 个空格去掉。\n\n具体的代码实现如下：\n\n```js\nvar etpl = require('etpl');\nvar marked = require('marked');\netpl.addFilter('markdown', function (source, useExtra) {\n    source = source.replace(/(^\\n+|\\n+$)/g, '');\n    var uselessSpaceCount = source.match(/^\\s*/)[0].length;\n    source = source.replace(new RegExp('^ {' + uselessSpaceCount + '}', 'gm'), '');\n    return marked(source);\n});\n```\n\n## HTML 标签\n\n有的时候，可能想给 markdown 标记的某一块加上背景色，比如：\n\n```html\n<!-- filter: markdown() -->\n<div class=\"background-red\">\n### 标题\n\n内容\n</div>\n<!-- /filter -->\n```\n\n这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！\n\n解决方法就是把 div 放过滤器外边吧：\n\n```html\n<div class=\"background-red\">\n<!-- filter: markdown() -->\n### 标题\n\n内容\n<!-- /filter -->\n</div>\n```\n","slug":"使用marked解析markdown","published":1,"updated":"2016-06-08T09:51:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkneb000dn4070xu06ztv","content":"<p><a href=\"https://github.com/chjj/marked\" target=\"_blank\" rel=\"external\">marked</a> 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。</p>\n<p>最简单直接的一种使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(marked(<span class=\"string\">'I am using __markdown__.'</span>));</span><br><span class=\"line\"><span class=\"comment\">// Outputs: &lt;p&gt;I am using &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>marked 库主要提供了一个 marked 函数，该函数声明为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type OptionsType = &#123;</span><br><span class=\"line\">    highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=,</span><br><span class=\"line\">    renderer: marked.Renderer=,</span><br><span class=\"line\">    gfm: boolean=,</span><br><span class=\"line\">    tables: boolean=,</span><br><span class=\"line\">    breaks: boolean=,</span><br><span class=\"line\">    pedantic: boolean=,</span><br><span class=\"line\">    sanitize: boolean=,</span><br><span class=\"line\">    smartLists: boolean=</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">marked(markdownString: string, options: OptionsType=, callback: Function=): string;</span><br></pre></td></tr></table></figure>\n<p>其中，marked 可以通过 renderer 配置提供了自定义解析途径。</p>\n<p>renderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法：</p>\n<ul>\n<li>code(string code, string language)</li>\n<li>blockquote(string quote)</li>\n<li>html(string html)</li>\n<li>heading(string text, number level)</li>\n<li>hr()</li>\n<li>list(string body, boolean ordered)</li>\n<li>listitem(string text)</li>\n<li>paragraph(string text)</li>\n<li>table(string header, string body)</li>\n<li>tablerow(string content)</li>\n<li>tablecell(string content, object flags)</li>\n<li>strong(string text)</li>\n<li>em(string text)</li>\n<li>codespan(string code)</li>\n<li>br()</li>\n<li>del(string text)</li>\n<li>link(string href, string title, string text)</li>\n<li>image(string href, string title, string text)</li>\n</ul>\n<p>所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。</p>\n<p>marked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。</p>\n<p>以上就是 marked 最基本最核心的用法了。</p>\n<p>其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。</p>\n<h2 id=\"markdown-缩进问题\"><a href=\"#markdown-缩进问题\" class=\"headerlink\" title=\"markdown 缩进问题\"></a>markdown 缩进问题</h2><p>在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。</p>\n<p>现在前端开发，经常会使用一些模板引擎，比如 <a href=\"https://github.com/ecomfe/etpl\" target=\"_blank\" rel=\"external\">ETPL</a> ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时在对应的模板中，就可以使用该过滤器了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\">    ### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">    内容</span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。</p>\n<p>为什么会这样呢？</p>\n<p>如果打印一下 markdown 过滤器处理函数中的 source 参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(source);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以发现，打印出来的内容会是这个样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;</span><br><span class=\"line\">    ### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">    内容</span><br><span class=\"line\">    &quot;</span><br></pre></td></tr></table></figure>\n<p>第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。</p>\n<p>这明显跟 markdown 语法有冲突，必须要进行如下处理：</p>\n<ul>\n<li>1、第一行和最后一行没啥实际内容，可以去掉；</li>\n<li>2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 <code>n</code> ；</li>\n<li>3、将每一行前面的 <code>n</code> 个空格去掉。</li>\n</ul>\n<p>具体的代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    source = source.replace(<span class=\"regexp\">/(^\\n+|\\n+$)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> uselessSpaceCount = source.match(<span class=\"regexp\">/^\\s*/</span>)[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">    source = source.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'^ &#123;'</span> + uselessSpaceCount + <span class=\"string\">'&#125;'</span>, <span class=\"string\">'gm'</span>), <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML-标签\"><a href=\"#HTML-标签\" class=\"headerlink\" title=\"HTML 标签\"></a>HTML 标签</h2><p>有的时候，可能想给 markdown 标记的某一块加上背景色，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"background-red\"</span>&gt;</span></span><br><span class=\"line\">### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！</p>\n<p>解决方法就是把 div 放过滤器外边吧：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"background-red\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\">### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">内容</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","excerpt":"<p><a href=\"https://github.com/chjj/marked\">marked</a> 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。</p>\n<p>最简单直接的一种使用方式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(marked(<span class=\"string\">'I am using __markdown__.'</span>));</span><br><span class=\"line\"><span class=\"comment\">// Outputs: &lt;p&gt;I am using &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>","more":"<p>marked 库主要提供了一个 marked 函数，该函数声明为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type OptionsType = &#123;</span><br><span class=\"line\">    highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=,</span><br><span class=\"line\">    renderer: marked.Renderer=,</span><br><span class=\"line\">    gfm: boolean=,</span><br><span class=\"line\">    tables: boolean=,</span><br><span class=\"line\">    breaks: boolean=,</span><br><span class=\"line\">    pedantic: boolean=,</span><br><span class=\"line\">    sanitize: boolean=,</span><br><span class=\"line\">    smartLists: boolean=</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">marked(markdownString: string, options: OptionsType=, callback: Function=): string;</span><br></pre></td></tr></table></figure>\n<p>其中，marked 可以通过 renderer 配置提供了自定义解析途径。</p>\n<p>renderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法：</p>\n<ul>\n<li>code(string code, string language)</li>\n<li>blockquote(string quote)</li>\n<li>html(string html)</li>\n<li>heading(string text, number level)</li>\n<li>hr()</li>\n<li>list(string body, boolean ordered)</li>\n<li>listitem(string text)</li>\n<li>paragraph(string text)</li>\n<li>table(string header, string body)</li>\n<li>tablerow(string content)</li>\n<li>tablecell(string content, object flags)</li>\n<li>strong(string text)</li>\n<li>em(string text)</li>\n<li>codespan(string code)</li>\n<li>br()</li>\n<li>del(string text)</li>\n<li>link(string href, string title, string text)</li>\n<li>image(string href, string title, string text)</li>\n</ul>\n<p>所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。</p>\n<p>marked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。</p>\n<p>以上就是 marked 最基本最核心的用法了。</p>\n<p>其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。</p>\n<h2 id=\"markdown-缩进问题\"><a href=\"#markdown-缩进问题\" class=\"headerlink\" title=\"markdown 缩进问题\"></a>markdown 缩进问题</h2><p>在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。</p>\n<p>现在前端开发，经常会使用一些模板引擎，比如 <a href=\"https://github.com/ecomfe/etpl\">ETPL</a> ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>此时在对应的模板中，就可以使用该过滤器了：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\">    ### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">    内容</span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。</p>\n<p>为什么会这样呢？</p>\n<p>如果打印一下 markdown 过滤器处理函数中的 source 参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(source);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>可以发现，打印出来的内容会是这个样子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;</span><br><span class=\"line\">    ### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">    内容</span><br><span class=\"line\">    &quot;</span><br></pre></td></tr></table></figure>\n<p>第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。</p>\n<p>这明显跟 markdown 语法有冲突，必须要进行如下处理：</p>\n<ul>\n<li>1、第一行和最后一行没啥实际内容，可以去掉；</li>\n<li>2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 <code>n</code> ；</li>\n<li>3、将每一行前面的 <code>n</code> 个空格去掉。</li>\n</ul>\n<p>具体的代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> etpl = <span class=\"built_in\">require</span>(<span class=\"string\">'etpl'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> marked = <span class=\"built_in\">require</span>(<span class=\"string\">'marked'</span>);</span><br><span class=\"line\">etpl.addFilter(<span class=\"string\">'markdown'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">source, useExtra</span>) </span>&#123;</span><br><span class=\"line\">    source = source.replace(<span class=\"regexp\">/(^\\n+|\\n+$)/g</span>, <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> uselessSpaceCount = source.match(<span class=\"regexp\">/^\\s*/</span>)[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">    source = source.replace(<span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(<span class=\"string\">'^ &#123;'</span> + uselessSpaceCount + <span class=\"string\">'&#125;'</span>, <span class=\"string\">'gm'</span>), <span class=\"string\">''</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> marked(source);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"HTML-标签\"><a href=\"#HTML-标签\" class=\"headerlink\" title=\"HTML 标签\"></a>HTML 标签</h2><p>有的时候，可能想给 markdown 标记的某一块加上背景色，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"background-red\"</span>&gt;</span></span><br><span class=\"line\">### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">内容</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！</p>\n<p>解决方法就是把 div 放过滤器外边吧：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"background-red\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- filter: markdown() --&gt;</span></span><br><span class=\"line\">### 标题</span><br><span class=\"line\"></span><br><span class=\"line\">内容</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- /filter --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"实现第一个 vscode 扩展","date":"2016-01-10T10:20:00.000Z","_content":"\n\n> 提前声明：<br>\n> 此处使用的 vscode 版本是0.10.6\n\nvscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。\n\n个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。\n<!-- more -->\n\n但是我个人很看重 vscode 的这些点：\n\n* 1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ；\n* 2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。\n\n目前个人感觉的小缺点有：\n\n* 1、无法代码折叠；\n* 2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。\n\n废话不对说，走一个插件先。\n\n### 插件功能\n\n对 JavaScript 代码进行检查，基于的检查规则是 `fecs` 。\n\n### 安装必要的东西\n\n> npm install -g yo generator-code\n\n### 生成扩展项目\n\n执行下面的代码：\n\n> yo code\n\n然后会出现这样的选择界面：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/13.png?raw=true)\n\n选择：\n\n> New Extension (JavaScript)\n\n这样就会生成使用 JavaScript 进行插件开发的项目结构。\n\n后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 `npm install` ，安装好 vscode 模块。\n\n一切结束之后，你会发现在当前目录下生成了一个叫 `test` 的目录，进入这个目录，下面就有了一堆文件。\n\n### 修改 package.json 文件\n\n更改 `activationEvents` 配置项，设为：\n\n```js\n[\n    \"onLanguage:javascript\"\n]\n```\n\n意思就是在打开 JavaScript 文件的时候会激活这个扩展。\n\n删掉 `contributes` 配置项，此处用不上这个配置。\n\n### 修改 extension.js 文件\n\n这个文件是 package.json 里面 `main` 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。\n\n对于该扩展，其执行流程为：\n\n* 1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法；\n* 2、在用户保存文件的时候，执行 fecs 检查；\n* 3、将第二步中检查出的错误和警告等信息显示到编辑器中。\n\n#### 开发过程\n\n在开发扩展的时候，要使用到 `vscode` 和 `fecs` 两个模块：\n\n```js\nvar vscode = require('vscode');\nvar fecs = require('fecs');\n```\n\n然后注册文件保存的回调函数：\n\n```js\nvar disposable = vscode.workspace.onDidSaveTextDocument(function (event) {\n    // do something while saving\n});\ncontext.subscriptions.push(diagnosticCollection);\n```\n\n> **注意：**<br>\n> 此处 `onDidSaveTextDocument` 返回了一个 disposable 对象，这个对象有一个 `dispose` 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 `context.subscriptions` ，`context` 是 `activate` 方法调用的时候传入的上下文对象。\n\n在这个回调函数里面就可以执行 fecs 检查了：\n\n```js\nfecs.check(\n    {\n        type: 'js',\n        name: 'FECS JS',\n        _: [event.uri.path],\n        stream: false\n    },\n    function (hasNoError, errors) {\n        // the result of check\n    }\n);\n```\n\n`hasNoError` 和 `errors` 表明了检查结果。此处可以忽略 `hasNoError` ，直接将 errors 转换成 vscode 能够展示的错误。\n\nvscode 提供了 `DiagnosticCollection` ，用于向界面上展示错误信息。那么如何操作呢？\n\n首先要拿到一个 `DiagnosticCollection` 对象：\n\n```js\nvar diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs');\n```\n\n然后往这个对象里面塞错误信息：\n\n```js\ndiagnosticCollection.set(someErrorObject);\n```\n\n#### 整合所有代码之后的样子\n\n整个 `extension.js` 的代码整合起来如下：\n\n```js\nvar path = require('path');\nvar vscode = require('vscode');\nvar fecs = require('fecs');\n\nfecs.leadName = 'fecs';\n\nexports.activate = function activate(context) {\n    var diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs');\n    context.subscriptions.push(diagnosticCollection);\n\n    vscode.workspace.onDidSaveTextDocument(function (event) {\n        diagnosticCollection.clear();\n        fecs.check(\n            {\n                type: 'js',\n                name: 'FECS JS',\n                _: [event.uri.path],\n                stream: false\n            },\n            function (hasNoError, errors) {\n                diagnosticCollection.set(convertErrors(errors));\n            }\n        );\n    });\n};\n\nfunction convertErrors(fecsErrors) {\n    return fecsErrors.map(function (error) {\n        return [\n            vscode.Uri.file(error.path),\n            error.errors.map(function (fileError) {\n                // fecs的行号和列号与vscode有差异。。。。\n                var line = fileError.line - 1;\n                var column = fileError.column - 1;\n\n                return new vscode.Diagnostic(\n                    new vscode.Range(line, column, line, column + 1),\n                    `[FECS]: ${fileError.message}  (${fileError.rule})`,\n                    {\n                        1: vscode.DiagnosticSeverity.Warning,\n                        2: vscode.DiagnosticSeverity.Error\n                    }[fileError.severity]\n                );\n            })\n        ];\n    });\n}\n```\n\n> **注：** [fecs 是什么？](http://fecs.baidu.com/)","source":"_posts/实现第一个 vscode 扩展.md","raw":"---\ntitle: 实现第一个 vscode 扩展\ndate: 2016-01-10 18:20\n---\n\n\n> 提前声明：<br>\n> 此处使用的 vscode 版本是0.10.6\n\nvscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。\n\n个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。\n<!-- more -->\n\n但是我个人很看重 vscode 的这些点：\n\n* 1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ；\n* 2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。\n\n目前个人感觉的小缺点有：\n\n* 1、无法代码折叠；\n* 2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。\n\n废话不对说，走一个插件先。\n\n### 插件功能\n\n对 JavaScript 代码进行检查，基于的检查规则是 `fecs` 。\n\n### 安装必要的东西\n\n> npm install -g yo generator-code\n\n### 生成扩展项目\n\n执行下面的代码：\n\n> yo code\n\n然后会出现这样的选择界面：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/13.png?raw=true)\n\n选择：\n\n> New Extension (JavaScript)\n\n这样就会生成使用 JavaScript 进行插件开发的项目结构。\n\n后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 `npm install` ，安装好 vscode 模块。\n\n一切结束之后，你会发现在当前目录下生成了一个叫 `test` 的目录，进入这个目录，下面就有了一堆文件。\n\n### 修改 package.json 文件\n\n更改 `activationEvents` 配置项，设为：\n\n```js\n[\n    \"onLanguage:javascript\"\n]\n```\n\n意思就是在打开 JavaScript 文件的时候会激活这个扩展。\n\n删掉 `contributes` 配置项，此处用不上这个配置。\n\n### 修改 extension.js 文件\n\n这个文件是 package.json 里面 `main` 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。\n\n对于该扩展，其执行流程为：\n\n* 1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法；\n* 2、在用户保存文件的时候，执行 fecs 检查；\n* 3、将第二步中检查出的错误和警告等信息显示到编辑器中。\n\n#### 开发过程\n\n在开发扩展的时候，要使用到 `vscode` 和 `fecs` 两个模块：\n\n```js\nvar vscode = require('vscode');\nvar fecs = require('fecs');\n```\n\n然后注册文件保存的回调函数：\n\n```js\nvar disposable = vscode.workspace.onDidSaveTextDocument(function (event) {\n    // do something while saving\n});\ncontext.subscriptions.push(diagnosticCollection);\n```\n\n> **注意：**<br>\n> 此处 `onDidSaveTextDocument` 返回了一个 disposable 对象，这个对象有一个 `dispose` 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 `context.subscriptions` ，`context` 是 `activate` 方法调用的时候传入的上下文对象。\n\n在这个回调函数里面就可以执行 fecs 检查了：\n\n```js\nfecs.check(\n    {\n        type: 'js',\n        name: 'FECS JS',\n        _: [event.uri.path],\n        stream: false\n    },\n    function (hasNoError, errors) {\n        // the result of check\n    }\n);\n```\n\n`hasNoError` 和 `errors` 表明了检查结果。此处可以忽略 `hasNoError` ，直接将 errors 转换成 vscode 能够展示的错误。\n\nvscode 提供了 `DiagnosticCollection` ，用于向界面上展示错误信息。那么如何操作呢？\n\n首先要拿到一个 `DiagnosticCollection` 对象：\n\n```js\nvar diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs');\n```\n\n然后往这个对象里面塞错误信息：\n\n```js\ndiagnosticCollection.set(someErrorObject);\n```\n\n#### 整合所有代码之后的样子\n\n整个 `extension.js` 的代码整合起来如下：\n\n```js\nvar path = require('path');\nvar vscode = require('vscode');\nvar fecs = require('fecs');\n\nfecs.leadName = 'fecs';\n\nexports.activate = function activate(context) {\n    var diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs');\n    context.subscriptions.push(diagnosticCollection);\n\n    vscode.workspace.onDidSaveTextDocument(function (event) {\n        diagnosticCollection.clear();\n        fecs.check(\n            {\n                type: 'js',\n                name: 'FECS JS',\n                _: [event.uri.path],\n                stream: false\n            },\n            function (hasNoError, errors) {\n                diagnosticCollection.set(convertErrors(errors));\n            }\n        );\n    });\n};\n\nfunction convertErrors(fecsErrors) {\n    return fecsErrors.map(function (error) {\n        return [\n            vscode.Uri.file(error.path),\n            error.errors.map(function (fileError) {\n                // fecs的行号和列号与vscode有差异。。。。\n                var line = fileError.line - 1;\n                var column = fileError.column - 1;\n\n                return new vscode.Diagnostic(\n                    new vscode.Range(line, column, line, column + 1),\n                    `[FECS]: ${fileError.message}  (${fileError.rule})`,\n                    {\n                        1: vscode.DiagnosticSeverity.Warning,\n                        2: vscode.DiagnosticSeverity.Error\n                    }[fileError.severity]\n                );\n            })\n        ];\n    });\n}\n```\n\n> **注：** [fecs 是什么？](http://fecs.baidu.com/)","slug":"实现第一个 vscode 扩展","published":1,"updated":"2016-06-08T09:52:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tknee000en4075et6g4jc","content":"<blockquote>\n<p>提前声明：<br><br>此处使用的 vscode 版本是0.10.6</p>\n</blockquote>\n<p>vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。</p>\n<p>个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。<br><a id=\"more\"></a></p>\n<p>但是我个人很看重 vscode 的这些点：</p>\n<ul>\n<li>1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ；</li>\n<li>2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。</li>\n</ul>\n<p>目前个人感觉的小缺点有：</p>\n<ul>\n<li>1、无法代码折叠；</li>\n<li>2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。</li>\n</ul>\n<p>废话不对说，走一个插件先。</p>\n<h3 id=\"插件功能\"><a href=\"#插件功能\" class=\"headerlink\" title=\"插件功能\"></a>插件功能</h3><p>对 JavaScript 代码进行检查，基于的检查规则是 <code>fecs</code> 。</p>\n<h3 id=\"安装必要的东西\"><a href=\"#安装必要的东西\" class=\"headerlink\" title=\"安装必要的东西\"></a>安装必要的东西</h3><blockquote>\n<p>npm install -g yo generator-code</p>\n</blockquote>\n<h3 id=\"生成扩展项目\"><a href=\"#生成扩展项目\" class=\"headerlink\" title=\"生成扩展项目\"></a>生成扩展项目</h3><p>执行下面的代码：</p>\n<blockquote>\n<p>yo code</p>\n</blockquote>\n<p>然后会出现这样的选择界面：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/13.png?raw=true\" alt=\"\"></p>\n<p>选择：</p>\n<blockquote>\n<p>New Extension (JavaScript)</p>\n</blockquote>\n<p>这样就会生成使用 JavaScript 进行插件开发的项目结构。</p>\n<p>后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 <code>npm install</code> ，安装好 vscode 模块。</p>\n<p>一切结束之后，你会发现在当前目录下生成了一个叫 <code>test</code> 的目录，进入这个目录，下面就有了一堆文件。</p>\n<h3 id=\"修改-package-json-文件\"><a href=\"#修改-package-json-文件\" class=\"headerlink\" title=\"修改 package.json 文件\"></a>修改 package.json 文件</h3><p>更改 <code>activationEvents</code> 配置项，设为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"onLanguage:javascript\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>意思就是在打开 JavaScript 文件的时候会激活这个扩展。</p>\n<p>删掉 <code>contributes</code> 配置项，此处用不上这个配置。</p>\n<h3 id=\"修改-extension-js-文件\"><a href=\"#修改-extension-js-文件\" class=\"headerlink\" title=\"修改 extension.js 文件\"></a>修改 extension.js 文件</h3><p>这个文件是 package.json 里面 <code>main</code> 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。</p>\n<p>对于该扩展，其执行流程为：</p>\n<ul>\n<li>1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法；</li>\n<li>2、在用户保存文件的时候，执行 fecs 检查；</li>\n<li>3、将第二步中检查出的错误和警告等信息显示到编辑器中。</li>\n</ul>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>在开发扩展的时候，要使用到 <code>vscode</code> 和 <code>fecs</code> 两个模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vscode = <span class=\"built_in\">require</span>(<span class=\"string\">'vscode'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fecs = <span class=\"built_in\">require</span>(<span class=\"string\">'fecs'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后注册文件保存的回调函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> disposable = vscode.workspace.onDidSaveTextDocument(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something while saving</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">context.subscriptions.push(diagnosticCollection);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br><br>此处 <code>onDidSaveTextDocument</code> 返回了一个 disposable 对象，这个对象有一个 <code>dispose</code> 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 <code>context.subscriptions</code> ，<code>context</code> 是 <code>activate</code> 方法调用的时候传入的上下文对象。</p>\n</blockquote>\n<p>在这个回调函数里面就可以执行 fecs 检查了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fecs.check(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'FECS JS'</span>,</span><br><span class=\"line\">        _: [event.uri.path],</span><br><span class=\"line\">        stream: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">hasNoError, errors</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the result of check</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>hasNoError</code> 和 <code>errors</code> 表明了检查结果。此处可以忽略 <code>hasNoError</code> ，直接将 errors 转换成 vscode 能够展示的错误。</p>\n<p>vscode 提供了 <code>DiagnosticCollection</code> ，用于向界面上展示错误信息。那么如何操作呢？</p>\n<p>首先要拿到一个 <code>DiagnosticCollection</code> 对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class=\"string\">'fecs'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后往这个对象里面塞错误信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diagnosticCollection.set(someErrorObject);</span><br></pre></td></tr></table></figure>\n<h4 id=\"整合所有代码之后的样子\"><a href=\"#整合所有代码之后的样子\" class=\"headerlink\" title=\"整合所有代码之后的样子\"></a>整合所有代码之后的样子</h4><p>整个 <code>extension.js</code> 的代码整合起来如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> vscode = <span class=\"built_in\">require</span>(<span class=\"string\">'vscode'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fecs = <span class=\"built_in\">require</span>(<span class=\"string\">'fecs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fecs.leadName = <span class=\"string\">'fecs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.activate = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activate</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class=\"string\">'fecs'</span>);</span><br><span class=\"line\">    context.subscriptions.push(diagnosticCollection);</span><br><span class=\"line\"></span><br><span class=\"line\">    vscode.workspace.onDidSaveTextDocument(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        diagnosticCollection.clear();</span><br><span class=\"line\">        fecs.check(</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                type: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">                name: <span class=\"string\">'FECS JS'</span>,</span><br><span class=\"line\">                _: [event.uri.path],</span><br><span class=\"line\">                stream: <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">hasNoError, errors</span>) </span>&#123;</span><br><span class=\"line\">                diagnosticCollection.set(convertErrors(errors));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convertErrors</span>(<span class=\"params\">fecsErrors</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fecsErrors.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">            vscode.Uri.file(error.path),</span><br><span class=\"line\">            error.errors.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileError</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// fecs的行号和列号与vscode有差异。。。。</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = fileError.line - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> column = fileError.column - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> vscode.Diagnostic(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> vscode.Range(line, column, line, column + <span class=\"number\">1</span>),</span><br><span class=\"line\">                    <span class=\"string\">`[FECS]: <span class=\"subst\">$&#123;fileError.message&#125;</span>  (<span class=\"subst\">$&#123;fileError.rule&#125;</span>)`</span>,</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"number\">1</span>: vscode.DiagnosticSeverity.Warning,</span><br><span class=\"line\">                        <span class=\"number\">2</span>: vscode.DiagnosticSeverity.Error</span><br><span class=\"line\">                    &#125;[fileError.severity]</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注：</strong> <a href=\"http://fecs.baidu.com/\" target=\"_blank\" rel=\"external\">fecs 是什么？</a></p>\n</blockquote>\n","excerpt":"<blockquote>\n<p>提前声明：<br><br>此处使用的 vscode 版本是0.10.6</p>\n</blockquote>\n<p>vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。</p>\n<p>个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。<br>","more":"</p>\n<p>但是我个人很看重 vscode 的这些点：</p>\n<ul>\n<li>1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ；</li>\n<li>2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。</li>\n</ul>\n<p>目前个人感觉的小缺点有：</p>\n<ul>\n<li>1、无法代码折叠；</li>\n<li>2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。</li>\n</ul>\n<p>废话不对说，走一个插件先。</p>\n<h3 id=\"插件功能\"><a href=\"#插件功能\" class=\"headerlink\" title=\"插件功能\"></a>插件功能</h3><p>对 JavaScript 代码进行检查，基于的检查规则是 <code>fecs</code> 。</p>\n<h3 id=\"安装必要的东西\"><a href=\"#安装必要的东西\" class=\"headerlink\" title=\"安装必要的东西\"></a>安装必要的东西</h3><blockquote>\n<p>npm install -g yo generator-code</p>\n</blockquote>\n<h3 id=\"生成扩展项目\"><a href=\"#生成扩展项目\" class=\"headerlink\" title=\"生成扩展项目\"></a>生成扩展项目</h3><p>执行下面的代码：</p>\n<blockquote>\n<p>yo code</p>\n</blockquote>\n<p>然后会出现这样的选择界面：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/13.png?raw=true\" alt=\"\"></p>\n<p>选择：</p>\n<blockquote>\n<p>New Extension (JavaScript)</p>\n</blockquote>\n<p>这样就会生成使用 JavaScript 进行插件开发的项目结构。</p>\n<p>后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 <code>npm install</code> ，安装好 vscode 模块。</p>\n<p>一切结束之后，你会发现在当前目录下生成了一个叫 <code>test</code> 的目录，进入这个目录，下面就有了一堆文件。</p>\n<h3 id=\"修改-package-json-文件\"><a href=\"#修改-package-json-文件\" class=\"headerlink\" title=\"修改 package.json 文件\"></a>修改 package.json 文件</h3><p>更改 <code>activationEvents</code> 配置项，设为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"onLanguage:javascript\"</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>意思就是在打开 JavaScript 文件的时候会激活这个扩展。</p>\n<p>删掉 <code>contributes</code> 配置项，此处用不上这个配置。</p>\n<h3 id=\"修改-extension-js-文件\"><a href=\"#修改-extension-js-文件\" class=\"headerlink\" title=\"修改 extension.js 文件\"></a>修改 extension.js 文件</h3><p>这个文件是 package.json 里面 <code>main</code> 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。</p>\n<p>对于该扩展，其执行流程为：</p>\n<ul>\n<li>1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法；</li>\n<li>2、在用户保存文件的时候，执行 fecs 检查；</li>\n<li>3、将第二步中检查出的错误和警告等信息显示到编辑器中。</li>\n</ul>\n<h4 id=\"开发过程\"><a href=\"#开发过程\" class=\"headerlink\" title=\"开发过程\"></a>开发过程</h4><p>在开发扩展的时候，要使用到 <code>vscode</code> 和 <code>fecs</code> 两个模块：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> vscode = <span class=\"built_in\">require</span>(<span class=\"string\">'vscode'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fecs = <span class=\"built_in\">require</span>(<span class=\"string\">'fecs'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后注册文件保存的回调函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> disposable = vscode.workspace.onDidSaveTextDocument(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something while saving</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">context.subscriptions.push(diagnosticCollection);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意：</strong><br><br>此处 <code>onDidSaveTextDocument</code> 返回了一个 disposable 对象，这个对象有一个 <code>dispose</code> 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 <code>context.subscriptions</code> ，<code>context</code> 是 <code>activate</code> 方法调用的时候传入的上下文对象。</p>\n</blockquote>\n<p>在这个回调函数里面就可以执行 fecs 检查了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fecs.check(</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        type: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">        name: <span class=\"string\">'FECS JS'</span>,</span><br><span class=\"line\">        _: [event.uri.path],</span><br><span class=\"line\">        stream: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">hasNoError, errors</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// the result of check</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p><code>hasNoError</code> 和 <code>errors</code> 表明了检查结果。此处可以忽略 <code>hasNoError</code> ，直接将 errors 转换成 vscode 能够展示的错误。</p>\n<p>vscode 提供了 <code>DiagnosticCollection</code> ，用于向界面上展示错误信息。那么如何操作呢？</p>\n<p>首先要拿到一个 <code>DiagnosticCollection</code> 对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class=\"string\">'fecs'</span>);</span><br></pre></td></tr></table></figure>\n<p>然后往这个对象里面塞错误信息：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diagnosticCollection.set(someErrorObject);</span><br></pre></td></tr></table></figure>\n<h4 id=\"整合所有代码之后的样子\"><a href=\"#整合所有代码之后的样子\" class=\"headerlink\" title=\"整合所有代码之后的样子\"></a>整合所有代码之后的样子</h4><p>整个 <code>extension.js</code> 的代码整合起来如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> vscode = <span class=\"built_in\">require</span>(<span class=\"string\">'vscode'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> fecs = <span class=\"built_in\">require</span>(<span class=\"string\">'fecs'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">fecs.leadName = <span class=\"string\">'fecs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">exports.activate = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">activate</span>(<span class=\"params\">context</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class=\"string\">'fecs'</span>);</span><br><span class=\"line\">    context.subscriptions.push(diagnosticCollection);</span><br><span class=\"line\"></span><br><span class=\"line\">    vscode.workspace.onDidSaveTextDocument(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">        diagnosticCollection.clear();</span><br><span class=\"line\">        fecs.check(</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                type: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">                name: <span class=\"string\">'FECS JS'</span>,</span><br><span class=\"line\">                _: [event.uri.path],</span><br><span class=\"line\">                stream: <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">hasNoError, errors</span>) </span>&#123;</span><br><span class=\"line\">                diagnosticCollection.set(convertErrors(errors));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">convertErrors</span>(<span class=\"params\">fecsErrors</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fecsErrors.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> [</span><br><span class=\"line\">            vscode.Uri.file(error.path),</span><br><span class=\"line\">            error.errors.map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileError</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">// fecs的行号和列号与vscode有差异。。。。</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> line = fileError.line - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> column = fileError.column - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> vscode.Diagnostic(</span><br><span class=\"line\">                    <span class=\"keyword\">new</span> vscode.Range(line, column, line, column + <span class=\"number\">1</span>),</span><br><span class=\"line\">                    <span class=\"string\">`[FECS]: <span class=\"subst\">$&#123;fileError.message&#125;</span>  (<span class=\"subst\">$&#123;fileError.rule&#125;</span>)`</span>,</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        <span class=\"number\">1</span>: vscode.DiagnosticSeverity.Warning,</span><br><span class=\"line\">                        <span class=\"number\">2</span>: vscode.DiagnosticSeverity.Error</span><br><span class=\"line\">                    &#125;[fileError.severity]</span><br><span class=\"line\">                );</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ];</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注：</strong> <a href=\"http://fecs.baidu.com/\">fecs 是什么？</a></p>\n</blockquote>"},{"title":"爬虫与编码","date":"2016-01-09T05:23:00.000Z","_content":"\n作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。\n<!-- more -->\n\n其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。\n\n于是，一些网站就会采取一些措施来阻止非正常访问：\n\n* 某某关键接口只能每分钟调用若干次；\n* 某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。\n\n当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。\n\n从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的：\n\n* 如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理；\n* 在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了；\n* 对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。\n\n**等等，有点偏题了！下面进入正轨：**\n\n在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/12.png?raw=true)\n\n面对这些乱码，如何解决呢？\n\n### 注意 HTTP 响应的头部\n\n留意一下 HTTP 响应的头部是否有用 gzip 压缩过：\n\n```\nContent-Encoding:gzip\n```\n\n如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。\n\nNode.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做：\n\n```js\n// `res` 是响应对象，http.IncommingMessage 类型的\n\nvar buffers = [];// 暂存 gzip 解压过后的 buffer\nvar size = 0;// 记录整个响应体解压后的数据大小\nvar gunzipStream = zlib.createGunzip();\nres.pipe(gunzipStream);\ngunzipStream.on('data', function (buffer) {\n    buffers.push(buffer);\n    size += buffer.length;\n});\ngunzipStream.on('error', function (error) {\n    // 发生了错误，处理下吧！\n});\ngunzipStream.on('end', function () {\n    var unzipedBuffer = Buffer.concat(buffers, size); // unzipedBuffer 就是解压过后的数据\n});\n```\n\n### 注意文本编码\n\n拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？\n\nNode.js 里面默认字符串是 `utf-8` 编码的，如果 gzip 解压出来的数据不是 `utf-8` 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。\n\n怎么办呢？\n\n留意一下响应头当中的 `Content-Type` 部分，如果 charset 是非 `utf-8` 的话，那就要考虑继续对数据进行解码了。\n\n对于中文网站，可能会使用 `GBK` 或者 `GB2312` 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 `iconv-lite` 。解码过程如下：\n\n```js\nvar finallyResponseText = require('iconv-lite').decode(unzipedBuffer, 'gbk');\n```\n\n这样，就拿到了最终想要的文本数据。\n","source":"_posts/爬虫与编码.md","raw":"---\ntitle: 爬虫与编码\ndate: 2016-01-09 13:23\n---\n\n作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。\n<!-- more -->\n\n其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。\n\n于是，一些网站就会采取一些措施来阻止非正常访问：\n\n* 某某关键接口只能每分钟调用若干次；\n* 某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。\n\n当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。\n\n从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的：\n\n* 如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理；\n* 在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了；\n* 对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。\n\n**等等，有点偏题了！下面进入正轨：**\n\n在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/12.png?raw=true)\n\n面对这些乱码，如何解决呢？\n\n### 注意 HTTP 响应的头部\n\n留意一下 HTTP 响应的头部是否有用 gzip 压缩过：\n\n```\nContent-Encoding:gzip\n```\n\n如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。\n\nNode.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做：\n\n```js\n// `res` 是响应对象，http.IncommingMessage 类型的\n\nvar buffers = [];// 暂存 gzip 解压过后的 buffer\nvar size = 0;// 记录整个响应体解压后的数据大小\nvar gunzipStream = zlib.createGunzip();\nres.pipe(gunzipStream);\ngunzipStream.on('data', function (buffer) {\n    buffers.push(buffer);\n    size += buffer.length;\n});\ngunzipStream.on('error', function (error) {\n    // 发生了错误，处理下吧！\n});\ngunzipStream.on('end', function () {\n    var unzipedBuffer = Buffer.concat(buffers, size); // unzipedBuffer 就是解压过后的数据\n});\n```\n\n### 注意文本编码\n\n拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？\n\nNode.js 里面默认字符串是 `utf-8` 编码的，如果 gzip 解压出来的数据不是 `utf-8` 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。\n\n怎么办呢？\n\n留意一下响应头当中的 `Content-Type` 部分，如果 charset 是非 `utf-8` 的话，那就要考虑继续对数据进行解码了。\n\n对于中文网站，可能会使用 `GBK` 或者 `GB2312` 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 `iconv-lite` 。解码过程如下：\n\n```js\nvar finallyResponseText = require('iconv-lite').decode(unzipedBuffer, 'gbk');\n```\n\n这样，就拿到了最终想要的文本数据。\n","slug":"爬虫与编码","published":1,"updated":"2016-06-08T09:52:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tkneg000gn407tyyanrfw","content":"<p>作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。<br><a id=\"more\"></a></p>\n<p>其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。</p>\n<p>于是，一些网站就会采取一些措施来阻止非正常访问：</p>\n<ul>\n<li>某某关键接口只能每分钟调用若干次；</li>\n<li>某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。</li>\n</ul>\n<p>当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。</p>\n<p>从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的：</p>\n<ul>\n<li>如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理；</li>\n<li>在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了；</li>\n<li>对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。</li>\n</ul>\n<p><strong>等等，有点偏题了！下面进入正轨：</strong></p>\n<p>在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/12.png?raw=true\" alt=\"\"></p>\n<p>面对这些乱码，如何解决呢？</p>\n<h3 id=\"注意-HTTP-响应的头部\"><a href=\"#注意-HTTP-响应的头部\" class=\"headerlink\" title=\"注意 HTTP 响应的头部\"></a>注意 HTTP 响应的头部</h3><p>留意一下 HTTP 响应的头部是否有用 gzip 压缩过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Encoding:gzip</span><br></pre></td></tr></table></figure>\n<p>如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。</p>\n<p>Node.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `res` 是响应对象，http.IncommingMessage 类型的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> buffers = [];<span class=\"comment\">// 暂存 gzip 解压过后的 buffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size = <span class=\"number\">0</span>;<span class=\"comment\">// 记录整个响应体解压后的数据大小</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gunzipStream = zlib.createGunzip();</span><br><span class=\"line\">res.pipe(gunzipStream);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">buffer</span>) </span>&#123;</span><br><span class=\"line\">    buffers.push(buffer);</span><br><span class=\"line\">    size += buffer.length;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发生了错误，处理下吧！</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> unzipedBuffer = Buffer.concat(buffers, size); <span class=\"comment\">// unzipedBuffer 就是解压过后的数据</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意文本编码\"><a href=\"#注意文本编码\" class=\"headerlink\" title=\"注意文本编码\"></a>注意文本编码</h3><p>拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？</p>\n<p>Node.js 里面默认字符串是 <code>utf-8</code> 编码的，如果 gzip 解压出来的数据不是 <code>utf-8</code> 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。</p>\n<p>怎么办呢？</p>\n<p>留意一下响应头当中的 <code>Content-Type</code> 部分，如果 charset 是非 <code>utf-8</code> 的话，那就要考虑继续对数据进行解码了。</p>\n<p>对于中文网站，可能会使用 <code>GBK</code> 或者 <code>GB2312</code> 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 <code>iconv-lite</code> 。解码过程如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> finallyResponseText = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>).decode(unzipedBuffer, <span class=\"string\">'gbk'</span>);</span><br></pre></td></tr></table></figure>\n<p>这样，就拿到了最终想要的文本数据。</p>\n","excerpt":"<p>作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。<br>","more":"</p>\n<p>其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。</p>\n<p>于是，一些网站就会采取一些措施来阻止非正常访问：</p>\n<ul>\n<li>某某关键接口只能每分钟调用若干次；</li>\n<li>某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。</li>\n</ul>\n<p>当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。</p>\n<p>从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的：</p>\n<ul>\n<li>如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理；</li>\n<li>在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了；</li>\n<li>对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。</li>\n</ul>\n<p><strong>等等，有点偏题了！下面进入正轨：</strong></p>\n<p>在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/12.png?raw=true\" alt=\"\"></p>\n<p>面对这些乱码，如何解决呢？</p>\n<h3 id=\"注意-HTTP-响应的头部\"><a href=\"#注意-HTTP-响应的头部\" class=\"headerlink\" title=\"注意 HTTP 响应的头部\"></a>注意 HTTP 响应的头部</h3><p>留意一下 HTTP 响应的头部是否有用 gzip 压缩过：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Encoding:gzip</span><br></pre></td></tr></table></figure>\n<p>如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。</p>\n<p>Node.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `res` 是响应对象，http.IncommingMessage 类型的</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> buffers = [];<span class=\"comment\">// 暂存 gzip 解压过后的 buffer</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> size = <span class=\"number\">0</span>;<span class=\"comment\">// 记录整个响应体解压后的数据大小</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> gunzipStream = zlib.createGunzip();</span><br><span class=\"line\">res.pipe(gunzipStream);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'data'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">buffer</span>) </span>&#123;</span><br><span class=\"line\">    buffers.push(buffer);</span><br><span class=\"line\">    size += buffer.length;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'error'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 发生了错误，处理下吧！</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gunzipStream.on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> unzipedBuffer = Buffer.concat(buffers, size); <span class=\"comment\">// unzipedBuffer 就是解压过后的数据</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"注意文本编码\"><a href=\"#注意文本编码\" class=\"headerlink\" title=\"注意文本编码\"></a>注意文本编码</h3><p>拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？</p>\n<p>Node.js 里面默认字符串是 <code>utf-8</code> 编码的，如果 gzip 解压出来的数据不是 <code>utf-8</code> 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。</p>\n<p>怎么办呢？</p>\n<p>留意一下响应头当中的 <code>Content-Type</code> 部分，如果 charset 是非 <code>utf-8</code> 的话，那就要考虑继续对数据进行解码了。</p>\n<p>对于中文网站，可能会使用 <code>GBK</code> 或者 <code>GB2312</code> 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 <code>iconv-lite</code> 。解码过程如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> finallyResponseText = <span class=\"built_in\">require</span>(<span class=\"string\">'iconv-lite'</span>).decode(unzipedBuffer, <span class=\"string\">'gbk'</span>);</span><br></pre></td></tr></table></figure>\n<p>这样，就拿到了最终想要的文本数据。</p>"},{"title":"生成器（ generator ）","date":"2015-07-12T16:00:00.000Z","_content":"\n### 什么是 generator ？\n\n可以暂停（ pause ）和唤醒（ resume ）的函数。\n<!-- more -->\n\n### 实现一个迭代器\n\n```js\nfunction* gen() {\n    for (let a of [1, 2, 3]) {\n        yield a + 1;\n    }\n\n    return 5;\n}\n\n// 下面的 for 循环输出：\n// 2\n// 3\n// 4\nfor (let b of gen()) {\n    print(JSON.stringify(b));\n}\n\nlet it = gen();\nprint(JSON.stringify(it.next())); // 输出： {value: 2, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 3, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 4, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 5, done: true}\n\nprint(JSON.stringify([...gen()])); // 输出： [2, 3, 4]\n```\n\n### 创建 generator 的方式\n\n```js\n// 第一种\nfunction* genFunc() { ··· }\nlet genObj = genFunc();\n\n// 第二种\nconst genFunc = function* () { ··· };\nlet genObj = genFunc();\n\n// 第三种\nlet obj = {\n    * generatorMethod() {\n        ···\n    }\n};\nlet genObj = obj.generatorMethod();\n\n// 第四种\nclass MyClass {\n    * generatorMethod() {\n        ···\n    }\n}\nlet myInst = new MyClass();\nlet genObj = myInst.generatorMethod();\n```\n\n### generator 嵌套： yield*\n\n```js\nfunction* gen1() {\n    yield 2;\n    yield 3;\n    return 'result of gen1';\n}\nfunction* gen2() {\n    yield 1;\n\n    // `yield* gen1()` 类似于\n    // for (let x of gen1()) {\n    //      yield x;\n    // }\n    print(JSON.stringify(yield* gen1()));\n\n    yield 4;\n}\n// 输出：\n// 'result of gen1'\n// [1, 2, 3, 4]\nprint(JSON.stringify([...gen2()]));\n\nfunction* gen3() {\n    yield 1;\n    yield* [2, 3];\n    yield 4;\n}\nprint(JSON.stringify([...gen3()])); // 输出： [1, 2, 3, 4]\n```\n\n### next 传值\n\n```js\nfunction* gen1() {\n    print(JSON.stringify(yield));\n}\nlet it = gen1();\n// 输出：\n// {value: undefined, done: false}\n// outer value\n// {value: undefined, done: true}\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.next('outer value')));\n```\n\n### `return()` 外部终止 generator\n\n```js\nfunction* gen1() {\n    print('a');\n    yield 1;\n    print('b');\n    yield 2;\n    print('c');\n}\n// 输出：\n// a\n// {value: 1, done: false}\n// {value: 'result', done: true}\nlet it = gen1();\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.return('result')));\n```\n\n### `throw()` 抛出异常\n\n```js\nfunction* gen() {\n    try {\n        print('Started');\n        yield;\n    } catch (error) {\n        print('Caught: ' + error.message);\n    }\n    return 'return result';\n}\n// 输出：\n// Started\n// {value: undefined, done: false}\n// Caught: error\n// {value: 'return result', done: true}\nlet it = gen();\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.throw(new Error('error'))));\n```\n\n### 很有有趣也有用的例子\n\n```js\n// for 循环延迟执行\nfunction* fn1(iterable) {\n    for (let x of iterable) {\n        if (x === 0) {\n            continue;\n        }\n        yield x;\n    }\n}\nfunction* fn2(iterable) {\n    for (let x of iterable) {\n        yield x + 1;\n    }\n}\nfunction* fn3(iterable) {\n    for (let x of iterable) {\n        yield x / 2;\n    }\n}\nlet newArr = [...fn3(fn2(fn1([1, 2, 3])))];\nprint(JSON.stringify(newArr)); // [1, 1.5, 2]\n```\n\n### generator 类图\n\n规范里面有一张[很大的图](http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects)，有点复杂。所以，看一张小图：\n\n![](./imgs/9.jpg)\n\n说明：\n\n* 空心箭头表示两个对象的继承关系。换句话说，从 x 指向 y 的箭头意味着 `Object.getPrototypeOf(x) === y` 。\n* 圆括号表示当前被包起来的对象是存在的，但是不能通过全局变量来访问。\n* 带有 `instanceof` 字眼的箭头如果从 x 指向 y ，就表明 `x instanceof y` 。\n    * `o instanceof C` 实际上就相当于 `C.prototype.isPrototypeOf(o)`\n* 带有 `prototype` 字眼的箭头如果从 x 指向 y ，就表明 `x.prototype === y` 。\n\n此图看完可能没有直观的感受，看两个例子先。\n\n第一个， generator 函数表现得很像一个构造函数，因为通过 `new` 调用和直接调用，两者的效果是一样的，都返回 generator 对象，如下所示：\n\n```\n> function* g() {}\n> g.prototype.hello = function () { return 'hi!'};\n> let obj = g();\n> obj instanceof g\ntrue\n> obj.hello()\n'hi!'\n```\n\n第二个，如果想给所有的 generator 对象添加一个方法，就可以放在 `(Generator).prototype` 上面，如下所示：\n\n```\n> let Generator_prototype = Object.getPrototypeOf(function* () {}).prototype;\n> Generator_prototype.hello = function () { return 'hi!'};\n> let generatorObject = (function* () {})();\n> generatorObject.hello()\n'hi!'\n```\n\ngenerator 内部的 `this` 是有一些猫腻的：\n\n```js\nfunction* gen1() {\n    'use strict'; // just in case\n    yield this;\n}\n\n// Retrieve the yielded value via destructuring\nlet [functionThis] = gen1();\nconsole.log(functionThis); // undefined\n\nlet obj = { method: gen1 };\nlet [methodThis] = obj.method();\nconsole.log(methodThis === obj); // true\n\nfunction* gen2() {\n    console.log(this); // ReferenceError\n}\nnew gen2();\n```\n\n### 一个简单的类似于 tj co 库的东西\n\n```js\n// 此段代码使用 node --harmony 执行\nexecuteGeneratorFn(function* () {\n    var result = yield request.bind(null, 'http://www.baidu.com', {userId: 1});\n    console.log(result);\n});\n\nexecuteGeneratorFn(function* () {\n    var userList = [];\n    for (var param of [{userId: 1}, {userId: 2}]) {\n        userList.push(yield request.bind(null, 'http://www.baidu.com', param));\n    }\n    console.log(userList);\n});\n\nfunction request(url, params, callback) {\n    setTimeout(() => callback('request result: ' + Math.random()), 3000);\n}\n\nfunction executeGeneratorFn(genFn, callback) {\n    var iterator = genFn();\n    next();\n\n    function next() {\n        try {\n            execute(iterator.next(arguments));\n        } catch (e) {\n            callback instanceof Function && callback(e);\n        }\n    }\n\n    function execute(nextValue) {\n        if (!nextValue.done) {\n            nextValue.value(next);\n        } else {\n            callback instanceof Function && callback(null, nextValue.value);\n        }\n    }\n}\n```\n","source":"_posts/生成器（ generator ）.md","raw":"---\ntitle: 生成器（ generator ）\ndate: 2015-07-13\n---\n\n### 什么是 generator ？\n\n可以暂停（ pause ）和唤醒（ resume ）的函数。\n<!-- more -->\n\n### 实现一个迭代器\n\n```js\nfunction* gen() {\n    for (let a of [1, 2, 3]) {\n        yield a + 1;\n    }\n\n    return 5;\n}\n\n// 下面的 for 循环输出：\n// 2\n// 3\n// 4\nfor (let b of gen()) {\n    print(JSON.stringify(b));\n}\n\nlet it = gen();\nprint(JSON.stringify(it.next())); // 输出： {value: 2, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 3, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 4, done: false}\nprint(JSON.stringify(it.next())); // 输出： {value: 5, done: true}\n\nprint(JSON.stringify([...gen()])); // 输出： [2, 3, 4]\n```\n\n### 创建 generator 的方式\n\n```js\n// 第一种\nfunction* genFunc() { ··· }\nlet genObj = genFunc();\n\n// 第二种\nconst genFunc = function* () { ··· };\nlet genObj = genFunc();\n\n// 第三种\nlet obj = {\n    * generatorMethod() {\n        ···\n    }\n};\nlet genObj = obj.generatorMethod();\n\n// 第四种\nclass MyClass {\n    * generatorMethod() {\n        ···\n    }\n}\nlet myInst = new MyClass();\nlet genObj = myInst.generatorMethod();\n```\n\n### generator 嵌套： yield*\n\n```js\nfunction* gen1() {\n    yield 2;\n    yield 3;\n    return 'result of gen1';\n}\nfunction* gen2() {\n    yield 1;\n\n    // `yield* gen1()` 类似于\n    // for (let x of gen1()) {\n    //      yield x;\n    // }\n    print(JSON.stringify(yield* gen1()));\n\n    yield 4;\n}\n// 输出：\n// 'result of gen1'\n// [1, 2, 3, 4]\nprint(JSON.stringify([...gen2()]));\n\nfunction* gen3() {\n    yield 1;\n    yield* [2, 3];\n    yield 4;\n}\nprint(JSON.stringify([...gen3()])); // 输出： [1, 2, 3, 4]\n```\n\n### next 传值\n\n```js\nfunction* gen1() {\n    print(JSON.stringify(yield));\n}\nlet it = gen1();\n// 输出：\n// {value: undefined, done: false}\n// outer value\n// {value: undefined, done: true}\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.next('outer value')));\n```\n\n### `return()` 外部终止 generator\n\n```js\nfunction* gen1() {\n    print('a');\n    yield 1;\n    print('b');\n    yield 2;\n    print('c');\n}\n// 输出：\n// a\n// {value: 1, done: false}\n// {value: 'result', done: true}\nlet it = gen1();\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.return('result')));\n```\n\n### `throw()` 抛出异常\n\n```js\nfunction* gen() {\n    try {\n        print('Started');\n        yield;\n    } catch (error) {\n        print('Caught: ' + error.message);\n    }\n    return 'return result';\n}\n// 输出：\n// Started\n// {value: undefined, done: false}\n// Caught: error\n// {value: 'return result', done: true}\nlet it = gen();\nprint(JSON.stringify(it.next()));\nprint(JSON.stringify(it.throw(new Error('error'))));\n```\n\n### 很有有趣也有用的例子\n\n```js\n// for 循环延迟执行\nfunction* fn1(iterable) {\n    for (let x of iterable) {\n        if (x === 0) {\n            continue;\n        }\n        yield x;\n    }\n}\nfunction* fn2(iterable) {\n    for (let x of iterable) {\n        yield x + 1;\n    }\n}\nfunction* fn3(iterable) {\n    for (let x of iterable) {\n        yield x / 2;\n    }\n}\nlet newArr = [...fn3(fn2(fn1([1, 2, 3])))];\nprint(JSON.stringify(newArr)); // [1, 1.5, 2]\n```\n\n### generator 类图\n\n规范里面有一张[很大的图](http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects)，有点复杂。所以，看一张小图：\n\n![](./imgs/9.jpg)\n\n说明：\n\n* 空心箭头表示两个对象的继承关系。换句话说，从 x 指向 y 的箭头意味着 `Object.getPrototypeOf(x) === y` 。\n* 圆括号表示当前被包起来的对象是存在的，但是不能通过全局变量来访问。\n* 带有 `instanceof` 字眼的箭头如果从 x 指向 y ，就表明 `x instanceof y` 。\n    * `o instanceof C` 实际上就相当于 `C.prototype.isPrototypeOf(o)`\n* 带有 `prototype` 字眼的箭头如果从 x 指向 y ，就表明 `x.prototype === y` 。\n\n此图看完可能没有直观的感受，看两个例子先。\n\n第一个， generator 函数表现得很像一个构造函数，因为通过 `new` 调用和直接调用，两者的效果是一样的，都返回 generator 对象，如下所示：\n\n```\n> function* g() {}\n> g.prototype.hello = function () { return 'hi!'};\n> let obj = g();\n> obj instanceof g\ntrue\n> obj.hello()\n'hi!'\n```\n\n第二个，如果想给所有的 generator 对象添加一个方法，就可以放在 `(Generator).prototype` 上面，如下所示：\n\n```\n> let Generator_prototype = Object.getPrototypeOf(function* () {}).prototype;\n> Generator_prototype.hello = function () { return 'hi!'};\n> let generatorObject = (function* () {})();\n> generatorObject.hello()\n'hi!'\n```\n\ngenerator 内部的 `this` 是有一些猫腻的：\n\n```js\nfunction* gen1() {\n    'use strict'; // just in case\n    yield this;\n}\n\n// Retrieve the yielded value via destructuring\nlet [functionThis] = gen1();\nconsole.log(functionThis); // undefined\n\nlet obj = { method: gen1 };\nlet [methodThis] = obj.method();\nconsole.log(methodThis === obj); // true\n\nfunction* gen2() {\n    console.log(this); // ReferenceError\n}\nnew gen2();\n```\n\n### 一个简单的类似于 tj co 库的东西\n\n```js\n// 此段代码使用 node --harmony 执行\nexecuteGeneratorFn(function* () {\n    var result = yield request.bind(null, 'http://www.baidu.com', {userId: 1});\n    console.log(result);\n});\n\nexecuteGeneratorFn(function* () {\n    var userList = [];\n    for (var param of [{userId: 1}, {userId: 2}]) {\n        userList.push(yield request.bind(null, 'http://www.baidu.com', param));\n    }\n    console.log(userList);\n});\n\nfunction request(url, params, callback) {\n    setTimeout(() => callback('request result: ' + Math.random()), 3000);\n}\n\nfunction executeGeneratorFn(genFn, callback) {\n    var iterator = genFn();\n    next();\n\n    function next() {\n        try {\n            execute(iterator.next(arguments));\n        } catch (e) {\n            callback instanceof Function && callback(e);\n        }\n    }\n\n    function execute(nextValue) {\n        if (!nextValue.done) {\n            nextValue.value(next);\n        } else {\n            callback instanceof Function && callback(null, nextValue.value);\n        }\n    }\n}\n```\n","slug":"生成器（ generator ）","published":1,"updated":"2016-06-08T09:52:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tknei000hn4072hb6gl0t","content":"<h3 id=\"什么是-generator-？\"><a href=\"#什么是-generator-？\" class=\"headerlink\" title=\"什么是 generator ？\"></a>什么是 generator ？</h3><p>可以暂停（ pause ）和唤醒（ resume ）的函数。<br><a id=\"more\"></a></p>\n<h3 id=\"实现一个迭代器\"><a href=\"#实现一个迭代器\" class=\"headerlink\" title=\"实现一个迭代器\"></a>实现一个迭代器</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的 for 循环输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> b <span class=\"keyword\">of</span> gen()) &#123;</span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 2, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 3, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 4, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 5, done: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen()])); <span class=\"comment\">// 输出： [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-generator-的方式\"><a href=\"#创建-generator-的方式\" class=\"headerlink\" title=\"创建 generator 的方式\"></a>创建 generator 的方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">genFunc</span>(<span class=\"params\"></span>) </span>&#123; ··· &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = genFunc();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> genFunc = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123; ··· &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = genFunc();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    * generatorMethod() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = obj.generatorMethod();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四种</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    * generatorMethod() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myInst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = myInst.generatorMethod();</span><br></pre></td></tr></table></figure>\n<h3 id=\"generator-嵌套：-yield\"><a href=\"#generator-嵌套：-yield\" class=\"headerlink\" title=\"generator 嵌套： yield*\"></a>generator 嵌套： yield*</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result of gen1'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `yield* gen1()` 类似于</span></span><br><span class=\"line\">    <span class=\"comment\">// for (let x of gen1()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      yield x;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">yield</span>* gen1()));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 'result of gen1'</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen2()]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* [<span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen3()])); <span class=\"comment\">// 输出： [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"next-传值\"><a href=\"#next-传值\" class=\"headerlink\" title=\"next 传值\"></a>next 传值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">yield</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen1();</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// outer value</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: true&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next(<span class=\"string\">'outer value'</span>)));</span><br></pre></td></tr></table></figure>\n<h3 id=\"return-外部终止-generator\"><a href=\"#return-外部终止-generator\" class=\"headerlink\" title=\"return() 外部终止 generator\"></a><code>return()</code> 外部终止 generator</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    print(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    print(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    print(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 'result', done: true&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen1();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.return(<span class=\"string\">'result'</span>)));</span><br></pre></td></tr></table></figure>\n<h3 id=\"throw-抛出异常\"><a href=\"#throw-抛出异常\" class=\"headerlink\" title=\"throw() 抛出异常\"></a><code>throw()</code> 抛出异常</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        print(<span class=\"string\">'Started'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        print(<span class=\"string\">'Caught: '</span> + error.message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'return result'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// Started</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// Caught: error</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 'return result', done: true&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.throw(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>))));</span><br></pre></td></tr></table></figure>\n<h3 id=\"很有有趣也有用的例子\"><a href=\"#很有有趣也有用的例子\" class=\"headerlink\" title=\"很有有趣也有用的例子\"></a>很有有趣也有用的例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 循环延迟执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn1</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn2</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn3</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x / <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newArr = [...fn3(fn2(fn1([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])))];</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(newArr)); <span class=\"comment\">// [1, 1.5, 2]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"generator-类图\"><a href=\"#generator-类图\" class=\"headerlink\" title=\"generator 类图\"></a>generator 类图</h3><p>规范里面有一张<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects\" target=\"_blank\" rel=\"external\">很大的图</a>，有点复杂。所以，看一张小图：</p>\n<p><img src=\"./imgs/9.jpg\" alt=\"\"></p>\n<p>说明：</p>\n<ul>\n<li>空心箭头表示两个对象的继承关系。换句话说，从 x 指向 y 的箭头意味着 <code>Object.getPrototypeOf(x) === y</code> 。</li>\n<li>圆括号表示当前被包起来的对象是存在的，但是不能通过全局变量来访问。</li>\n<li>带有 <code>instanceof</code> 字眼的箭头如果从 x 指向 y ，就表明 <code>x instanceof y</code> 。<ul>\n<li><code>o instanceof C</code> 实际上就相当于 <code>C.prototype.isPrototypeOf(o)</code></li>\n</ul>\n</li>\n<li>带有 <code>prototype</code> 字眼的箭头如果从 x 指向 y ，就表明 <code>x.prototype === y</code> 。</li>\n</ul>\n<p>此图看完可能没有直观的感受，看两个例子先。</p>\n<p>第一个， generator 函数表现得很像一个构造函数，因为通过 <code>new</code> 调用和直接调用，两者的效果是一样的，都返回 generator 对象，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function* g() &#123;&#125;</span><br><span class=\"line\">&gt; g.prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;</span><br><span class=\"line\">&gt; let obj = g();</span><br><span class=\"line\">&gt; obj instanceof g</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; obj.hello()</span><br><span class=\"line\">&apos;hi!&apos;</span><br></pre></td></tr></table></figure>\n<p>第二个，如果想给所有的 generator 对象添加一个方法，就可以放在 <code>(Generator).prototype</code> 上面，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; let Generator_prototype = Object.getPrototypeOf(function* () &#123;&#125;).prototype;</span><br><span class=\"line\">&gt; Generator_prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;</span><br><span class=\"line\">&gt; let generatorObject = (function* () &#123;&#125;)();</span><br><span class=\"line\">&gt; generatorObject.hello()</span><br><span class=\"line\">&apos;hi!&apos;</span><br></pre></td></tr></table></figure>\n<p>generator 内部的 <code>this</code> 是有一些猫腻的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>; <span class=\"comment\">// just in case</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve the yielded value via destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [functionThis] = gen1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(functionThis); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; method: gen1 &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [methodThis] = obj.method();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(methodThis === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> gen2();</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个简单的类似于-tj-co-库的东西\"><a href=\"#一个简单的类似于-tj-co-库的东西\" class=\"headerlink\" title=\"一个简单的类似于 tj co 库的东西\"></a>一个简单的类似于 tj co 库的东西</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此段代码使用 node --harmony 执行</span></span><br><span class=\"line\">executeGeneratorFn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request.bind(<span class=\"literal\">null</span>, <span class=\"string\">'http://www.baidu.com'</span>, &#123;userId: <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">executeGeneratorFn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> userList = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> param <span class=\"keyword\">of</span> [&#123;userId: <span class=\"number\">1</span>&#125;, &#123;userId: <span class=\"number\">2</span>&#125;]) &#123;</span><br><span class=\"line\">        userList.push(<span class=\"keyword\">yield</span> request.bind(<span class=\"literal\">null</span>, <span class=\"string\">'http://www.baidu.com'</span>, param));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(userList);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url, params, callback</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; callback(<span class=\"string\">'request result: '</span> + <span class=\"built_in\">Math</span>.random()), <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeGeneratorFn</span>(<span class=\"params\">genFn, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> iterator = genFn();</span><br><span class=\"line\">    next();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            execute(iterator.next(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            callback <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> &amp;&amp; callback(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">nextValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!nextValue.done) &#123;</span><br><span class=\"line\">            nextValue.value(next);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            callback <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> &amp;&amp; callback(<span class=\"literal\">null</span>, nextValue.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"<h3 id=\"什么是-generator-？\"><a href=\"#什么是-generator-？\" class=\"headerlink\" title=\"什么是 generator ？\"></a>什么是 generator ？</h3><p>可以暂停（ pause ）和唤醒（ resume ）的函数。<br>","more":"</p>\n<h3 id=\"实现一个迭代器\"><a href=\"#实现一个迭代器\" class=\"headerlink\" title=\"实现一个迭代器\"></a>实现一个迭代器</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> a <span class=\"keyword\">of</span> [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> a + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面的 for 循环输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> b <span class=\"keyword\">of</span> gen()) &#123;</span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 2, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 3, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 4, done: false&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next())); <span class=\"comment\">// 输出： &#123;value: 5, done: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen()])); <span class=\"comment\">// 输出： [2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"创建-generator-的方式\"><a href=\"#创建-generator-的方式\" class=\"headerlink\" title=\"创建 generator 的方式\"></a>创建 generator 的方式</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一种</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">genFunc</span>(<span class=\"params\"></span>) </span>&#123; ··· &#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = genFunc();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二种</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> genFunc = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123; ··· &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = genFunc();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第三种</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123;</span><br><span class=\"line\">    * generatorMethod() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = obj.generatorMethod();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四种</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">    * generatorMethod() &#123;</span><br><span class=\"line\">        ···</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myInst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"><span class=\"keyword\">let</span> genObj = myInst.generatorMethod();</span><br></pre></td></tr></table></figure>\n<h3 id=\"generator-嵌套：-yield\"><a href=\"#generator-嵌套：-yield\" class=\"headerlink\" title=\"generator 嵌套： yield*\"></a>generator 嵌套： yield*</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result of gen1'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// `yield* gen1()` 类似于</span></span><br><span class=\"line\">    <span class=\"comment\">// for (let x of gen1()) &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//      yield x;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">yield</span>* gen1()));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 'result of gen1'</span></span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen2()]));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span>* [<span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify([...gen3()])); <span class=\"comment\">// 输出： [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"next-传值\"><a href=\"#next-传值\" class=\"headerlink\" title=\"next 传值\"></a>next 传值</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    print(<span class=\"built_in\">JSON</span>.stringify(<span class=\"keyword\">yield</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen1();</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// outer value</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: true&#125;</span></span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next(<span class=\"string\">'outer value'</span>)));</span><br></pre></td></tr></table></figure>\n<h3 id=\"return-外部终止-generator\"><a href=\"#return-外部终止-generator\" class=\"headerlink\" title=\"return() 外部终止 generator\"></a><code>return()</code> 外部终止 generator</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    print(<span class=\"string\">'a'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    print(<span class=\"string\">'b'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">    print(<span class=\"string\">'c'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// a</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 1, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 'result', done: true&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen1();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.return(<span class=\"string\">'result'</span>)));</span><br></pre></td></tr></table></figure>\n<h3 id=\"throw-抛出异常\"><a href=\"#throw-抛出异常\" class=\"headerlink\" title=\"throw() 抛出异常\"></a><code>throw()</code> 抛出异常</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        print(<span class=\"string\">'Started'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">yield</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">        print(<span class=\"string\">'Caught: '</span> + error.message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'return result'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// Started</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: undefined, done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// Caught: error</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;value: 'return result', done: true&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> it = gen();</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.next()));</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(it.throw(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'error'</span>))));</span><br></pre></td></tr></table></figure>\n<h3 id=\"很有有趣也有用的例子\"><a href=\"#很有有趣也有用的例子\" class=\"headerlink\" title=\"很有有趣也有用的例子\"></a>很有有趣也有用的例子</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// for 循环延迟执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn1</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn2</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">fn3</span>(<span class=\"params\">iterable</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> x <span class=\"keyword\">of</span> iterable) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> x / <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> newArr = [...fn3(fn2(fn1([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])))];</span><br><span class=\"line\">print(<span class=\"built_in\">JSON</span>.stringify(newArr)); <span class=\"comment\">// [1, 1.5, 2]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"generator-类图\"><a href=\"#generator-类图\" class=\"headerlink\" title=\"generator 类图\"></a>generator 类图</h3><p>规范里面有一张<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects\">很大的图</a>，有点复杂。所以，看一张小图：</p>\n<p><img src=\"./imgs/9.jpg\" alt=\"\"></p>\n<p>说明：</p>\n<ul>\n<li>空心箭头表示两个对象的继承关系。换句话说，从 x 指向 y 的箭头意味着 <code>Object.getPrototypeOf(x) === y</code> 。</li>\n<li>圆括号表示当前被包起来的对象是存在的，但是不能通过全局变量来访问。</li>\n<li>带有 <code>instanceof</code> 字眼的箭头如果从 x 指向 y ，就表明 <code>x instanceof y</code> 。<ul>\n<li><code>o instanceof C</code> 实际上就相当于 <code>C.prototype.isPrototypeOf(o)</code></li>\n</ul>\n</li>\n<li>带有 <code>prototype</code> 字眼的箭头如果从 x 指向 y ，就表明 <code>x.prototype === y</code> 。</li>\n</ul>\n<p>此图看完可能没有直观的感受，看两个例子先。</p>\n<p>第一个， generator 函数表现得很像一个构造函数，因为通过 <code>new</code> 调用和直接调用，两者的效果是一样的，都返回 generator 对象，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; function* g() &#123;&#125;</span><br><span class=\"line\">&gt; g.prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;</span><br><span class=\"line\">&gt; let obj = g();</span><br><span class=\"line\">&gt; obj instanceof g</span><br><span class=\"line\">true</span><br><span class=\"line\">&gt; obj.hello()</span><br><span class=\"line\">&apos;hi!&apos;</span><br></pre></td></tr></table></figure>\n<p>第二个，如果想给所有的 generator 对象添加一个方法，就可以放在 <code>(Generator).prototype</code> 上面，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; let Generator_prototype = Object.getPrototypeOf(function* () &#123;&#125;).prototype;</span><br><span class=\"line\">&gt; Generator_prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;</span><br><span class=\"line\">&gt; let generatorObject = (function* () &#123;&#125;)();</span><br><span class=\"line\">&gt; generatorObject.hello()</span><br><span class=\"line\">&apos;hi!&apos;</span><br></pre></td></tr></table></figure>\n<p>generator 内部的 <code>this</code> 是有一些猫腻的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">    'use strict'</span>; <span class=\"comment\">// just in case</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Retrieve the yielded value via destructuring</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [functionThis] = gen1();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(functionThis); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; method: gen1 &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> [methodThis] = obj.method();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(methodThis === obj); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> gen2();</span><br></pre></td></tr></table></figure>\n<h3 id=\"一个简单的类似于-tj-co-库的东西\"><a href=\"#一个简单的类似于-tj-co-库的东西\" class=\"headerlink\" title=\"一个简单的类似于 tj co 库的东西\"></a>一个简单的类似于 tj co 库的东西</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此段代码使用 node --harmony 执行</span></span><br><span class=\"line\">executeGeneratorFn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> request.bind(<span class=\"literal\">null</span>, <span class=\"string\">'http://www.baidu.com'</span>, &#123;userId: <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">executeGeneratorFn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> userList = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> param <span class=\"keyword\">of</span> [&#123;userId: <span class=\"number\">1</span>&#125;, &#123;userId: <span class=\"number\">2</span>&#125;]) &#123;</span><br><span class=\"line\">        userList.push(<span class=\"keyword\">yield</span> request.bind(<span class=\"literal\">null</span>, <span class=\"string\">'http://www.baidu.com'</span>, param));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(userList);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">request</span>(<span class=\"params\">url, params, callback</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout(() =&gt; callback(<span class=\"string\">'request result: '</span> + <span class=\"built_in\">Math</span>.random()), <span class=\"number\">3000</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">executeGeneratorFn</span>(<span class=\"params\">genFn, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> iterator = genFn();</span><br><span class=\"line\">    next();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            execute(iterator.next(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            callback <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> &amp;&amp; callback(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\">nextValue</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!nextValue.done) &#123;</span><br><span class=\"line\">            nextValue.value(next);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            callback <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span> &amp;&amp; callback(<span class=\"literal\">null</span>, nextValue.value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"百度（EFE）前端框架学习笔记（ef）","date":"2015-05-31T16:00:00.000Z","_content":"\n官方 EF 学习资料：[ActionPanel](https://github.com/ecomfe/ef/blob/master/doc/ActionPanel.md)、[UIModel](https://github.com/ecomfe/ef/blob/master/doc/UIModel.md)、[UIView](https://github.com/ecomfe/ef/blob/master/doc/UIView.md)。\n<!-- more -->\n\n### UIView.js\n\n与 ESUI 结合的 `View` 基类。该类有一个主入口方法 enterDocument()，该函数在容器渲染完毕后触发，用于控制元素可见性及绑定事件等 DOM 操作。\n\n是 ESUI 中 View 类的子类。\n\n该类对应的实例上会有一个视图上下文对象（ view.viewContext ），此上下文对象会传递给每个子控件，也就是说每个子控件都会有一个 viewContext 属性。此上下文对象的详细信息参看[百度 EFE 前端框架学习笔记（esui）](https://github.com/yibuyisheng/blogs/issues/4)的 `ViewContext.js` 部分。\n\nenterDocument() 方法会调用 ESUI 的 main.init() 方法，初始化当前 UIView 实例所管辖的 container 部分，生成各种各样的控件等等。\n\n此类生成的实例上有一个很重要的事件属性 uiView.uiEvents，该属性有2种方式：\n\n* 以 `id:eventName` 为键，以处理函数为值，比如 `{'someId:click': function() {/* do something */}}`。\n* 以 `id` 为键，值为一个对象，对象中以 `eventName` 为键，处理函数为值，比如 `{someId: {eventName: function() {/* do something */}}}`。\n\n在此处声明的事件，运行时的 `this` 对象均是 `View` 实例，而非控件的实例。同时，在运行期，`UIView` 会克隆该属性，将其中所有的处理函数都进行一次 `bind`，将 `this` 指向自身，因此运行时的 `uiEvents` 与类声明时的不会相同。\n\n此类上的 bindEvents() 方法就会根据 uiEvents 指定的事件配置来给子控件绑定事件。\n\n### UIModel.js\n\n处理 ESUI 场景的 `Model` 实现。 UIModel 继承自 er 的 Model。\n\nUIModel 添加了 formatter 属性，用于对日期进行格式化。同时增加了一些操作数据的方法：set() 、 fill() 、 getPart()。\n\n### ActionPanel.js\n\n用于加载子Action的面板控件。继承自 esui 的 Panel 类，不过没有 setContent() 方法。\n\n### 小技巧\n\n```js\nfunction getControl(node) {\n    var controls = require('er/controller').currentAction.view.viewContext.getControls();\n    for (var k in controls) {\n        var control = controls[k];\n        if (control.main === node) {\n            return control;\n        }\n    }\n}\n```\n\n该函数可以根据节点找到这个节点对应的控件对象，对debug有一定帮助。","source":"_posts/百度 EFE 前端框架学习笔记（ef）.md","raw":"---\ntitle: 百度（EFE）前端框架学习笔记（ef）\ndate: 2015-06-01\n---\n\n官方 EF 学习资料：[ActionPanel](https://github.com/ecomfe/ef/blob/master/doc/ActionPanel.md)、[UIModel](https://github.com/ecomfe/ef/blob/master/doc/UIModel.md)、[UIView](https://github.com/ecomfe/ef/blob/master/doc/UIView.md)。\n<!-- more -->\n\n### UIView.js\n\n与 ESUI 结合的 `View` 基类。该类有一个主入口方法 enterDocument()，该函数在容器渲染完毕后触发，用于控制元素可见性及绑定事件等 DOM 操作。\n\n是 ESUI 中 View 类的子类。\n\n该类对应的实例上会有一个视图上下文对象（ view.viewContext ），此上下文对象会传递给每个子控件，也就是说每个子控件都会有一个 viewContext 属性。此上下文对象的详细信息参看[百度 EFE 前端框架学习笔记（esui）](https://github.com/yibuyisheng/blogs/issues/4)的 `ViewContext.js` 部分。\n\nenterDocument() 方法会调用 ESUI 的 main.init() 方法，初始化当前 UIView 实例所管辖的 container 部分，生成各种各样的控件等等。\n\n此类生成的实例上有一个很重要的事件属性 uiView.uiEvents，该属性有2种方式：\n\n* 以 `id:eventName` 为键，以处理函数为值，比如 `{'someId:click': function() {/* do something */}}`。\n* 以 `id` 为键，值为一个对象，对象中以 `eventName` 为键，处理函数为值，比如 `{someId: {eventName: function() {/* do something */}}}`。\n\n在此处声明的事件，运行时的 `this` 对象均是 `View` 实例，而非控件的实例。同时，在运行期，`UIView` 会克隆该属性，将其中所有的处理函数都进行一次 `bind`，将 `this` 指向自身，因此运行时的 `uiEvents` 与类声明时的不会相同。\n\n此类上的 bindEvents() 方法就会根据 uiEvents 指定的事件配置来给子控件绑定事件。\n\n### UIModel.js\n\n处理 ESUI 场景的 `Model` 实现。 UIModel 继承自 er 的 Model。\n\nUIModel 添加了 formatter 属性，用于对日期进行格式化。同时增加了一些操作数据的方法：set() 、 fill() 、 getPart()。\n\n### ActionPanel.js\n\n用于加载子Action的面板控件。继承自 esui 的 Panel 类，不过没有 setContent() 方法。\n\n### 小技巧\n\n```js\nfunction getControl(node) {\n    var controls = require('er/controller').currentAction.view.viewContext.getControls();\n    for (var k in controls) {\n        var control = controls[k];\n        if (control.main === node) {\n            return control;\n        }\n    }\n}\n```\n\n该函数可以根据节点找到这个节点对应的控件对象，对debug有一定帮助。","slug":"百度 EFE 前端框架学习笔记（ef）","published":1,"updated":"2016-06-08T09:52:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tknek000in4075ah3twaw","content":"<p>官方 EF 学习资料：<a href=\"https://github.com/ecomfe/ef/blob/master/doc/ActionPanel.md\" target=\"_blank\" rel=\"external\">ActionPanel</a>、<a href=\"https://github.com/ecomfe/ef/blob/master/doc/UIModel.md\" target=\"_blank\" rel=\"external\">UIModel</a>、<a href=\"https://github.com/ecomfe/ef/blob/master/doc/UIView.md\" target=\"_blank\" rel=\"external\">UIView</a>。<br><a id=\"more\"></a></p>\n<h3 id=\"UIView-js\"><a href=\"#UIView-js\" class=\"headerlink\" title=\"UIView.js\"></a>UIView.js</h3><p>与 ESUI 结合的 <code>View</code> 基类。该类有一个主入口方法 enterDocument()，该函数在容器渲染完毕后触发，用于控制元素可见性及绑定事件等 DOM 操作。</p>\n<p>是 ESUI 中 View 类的子类。</p>\n<p>该类对应的实例上会有一个视图上下文对象（ view.viewContext ），此上下文对象会传递给每个子控件，也就是说每个子控件都会有一个 viewContext 属性。此上下文对象的详细信息参看<a href=\"https://github.com/yibuyisheng/blogs/issues/4\" target=\"_blank\" rel=\"external\">百度 EFE 前端框架学习笔记（esui）</a>的 <code>ViewContext.js</code> 部分。</p>\n<p>enterDocument() 方法会调用 ESUI 的 main.init() 方法，初始化当前 UIView 实例所管辖的 container 部分，生成各种各样的控件等等。</p>\n<p>此类生成的实例上有一个很重要的事件属性 uiView.uiEvents，该属性有2种方式：</p>\n<ul>\n<li>以 <code>id:eventName</code> 为键，以处理函数为值，比如 <code>{&#39;someId:click&#39;: function() {/* do something */}}</code>。</li>\n<li>以 <code>id</code> 为键，值为一个对象，对象中以 <code>eventName</code> 为键，处理函数为值，比如 <code>{someId: {eventName: function() {/* do something */}}}</code>。</li>\n</ul>\n<p>在此处声明的事件，运行时的 <code>this</code> 对象均是 <code>View</code> 实例，而非控件的实例。同时，在运行期，<code>UIView</code> 会克隆该属性，将其中所有的处理函数都进行一次 <code>bind</code>，将 <code>this</code> 指向自身，因此运行时的 <code>uiEvents</code> 与类声明时的不会相同。</p>\n<p>此类上的 bindEvents() 方法就会根据 uiEvents 指定的事件配置来给子控件绑定事件。</p>\n<h3 id=\"UIModel-js\"><a href=\"#UIModel-js\" class=\"headerlink\" title=\"UIModel.js\"></a>UIModel.js</h3><p>处理 ESUI 场景的 <code>Model</code> 实现。 UIModel 继承自 er 的 Model。</p>\n<p>UIModel 添加了 formatter 属性，用于对日期进行格式化。同时增加了一些操作数据的方法：set() 、 fill() 、 getPart()。</p>\n<h3 id=\"ActionPanel-js\"><a href=\"#ActionPanel-js\" class=\"headerlink\" title=\"ActionPanel.js\"></a>ActionPanel.js</h3><p>用于加载子Action的面板控件。继承自 esui 的 Panel 类，不过没有 setContent() 方法。</p>\n<h3 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getControl</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> controls = <span class=\"built_in\">require</span>(<span class=\"string\">'er/controller'</span>).currentAction.view.viewContext.getControls();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> controls) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> control = controls[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (control.main === node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> control;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数可以根据节点找到这个节点对应的控件对象，对debug有一定帮助。</p>\n","excerpt":"<p>官方 EF 学习资料：<a href=\"https://github.com/ecomfe/ef/blob/master/doc/ActionPanel.md\">ActionPanel</a>、<a href=\"https://github.com/ecomfe/ef/blob/master/doc/UIModel.md\">UIModel</a>、<a href=\"https://github.com/ecomfe/ef/blob/master/doc/UIView.md\">UIView</a>。<br>","more":"</p>\n<h3 id=\"UIView-js\"><a href=\"#UIView-js\" class=\"headerlink\" title=\"UIView.js\"></a>UIView.js</h3><p>与 ESUI 结合的 <code>View</code> 基类。该类有一个主入口方法 enterDocument()，该函数在容器渲染完毕后触发，用于控制元素可见性及绑定事件等 DOM 操作。</p>\n<p>是 ESUI 中 View 类的子类。</p>\n<p>该类对应的实例上会有一个视图上下文对象（ view.viewContext ），此上下文对象会传递给每个子控件，也就是说每个子控件都会有一个 viewContext 属性。此上下文对象的详细信息参看<a href=\"https://github.com/yibuyisheng/blogs/issues/4\">百度 EFE 前端框架学习笔记（esui）</a>的 <code>ViewContext.js</code> 部分。</p>\n<p>enterDocument() 方法会调用 ESUI 的 main.init() 方法，初始化当前 UIView 实例所管辖的 container 部分，生成各种各样的控件等等。</p>\n<p>此类生成的实例上有一个很重要的事件属性 uiView.uiEvents，该属性有2种方式：</p>\n<ul>\n<li>以 <code>id:eventName</code> 为键，以处理函数为值，比如 <code>{&#39;someId:click&#39;: function() {/* do something */}}</code>。</li>\n<li>以 <code>id</code> 为键，值为一个对象，对象中以 <code>eventName</code> 为键，处理函数为值，比如 <code>{someId: {eventName: function() {/* do something */}}}</code>。</li>\n</ul>\n<p>在此处声明的事件，运行时的 <code>this</code> 对象均是 <code>View</code> 实例，而非控件的实例。同时，在运行期，<code>UIView</code> 会克隆该属性，将其中所有的处理函数都进行一次 <code>bind</code>，将 <code>this</code> 指向自身，因此运行时的 <code>uiEvents</code> 与类声明时的不会相同。</p>\n<p>此类上的 bindEvents() 方法就会根据 uiEvents 指定的事件配置来给子控件绑定事件。</p>\n<h3 id=\"UIModel-js\"><a href=\"#UIModel-js\" class=\"headerlink\" title=\"UIModel.js\"></a>UIModel.js</h3><p>处理 ESUI 场景的 <code>Model</code> 实现。 UIModel 继承自 er 的 Model。</p>\n<p>UIModel 添加了 formatter 属性，用于对日期进行格式化。同时增加了一些操作数据的方法：set() 、 fill() 、 getPart()。</p>\n<h3 id=\"ActionPanel-js\"><a href=\"#ActionPanel-js\" class=\"headerlink\" title=\"ActionPanel.js\"></a>ActionPanel.js</h3><p>用于加载子Action的面板控件。继承自 esui 的 Panel 类，不过没有 setContent() 方法。</p>\n<h3 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getControl</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> controls = <span class=\"built_in\">require</span>(<span class=\"string\">'er/controller'</span>).currentAction.view.viewContext.getControls();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> controls) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> control = controls[k];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (control.main === node) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> control;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数可以根据节点找到这个节点对应的控件对象，对debug有一定帮助。</p>"},{"title":"百度 EFE 前端框架学习笔记（er）","date":"2015-05-28T16:00:00.000Z","_content":"\n首先上一张图：\n\n![](https://raw.githubusercontent.com/ecomfe/er/master/doc/asset/er-overview.png)\n<!-- more -->\n\n### ajax.js\n\n此模块返回一个 ajax 对象，用于发送 ajax 请求，最主要的就是 request 方法。同时该对象上也会挂载 Ajax 构造函数。\n\n返回的 ajax 对象上会带有一个钩子属性（ hooks ），钩子属性上包含的类容可能有：\n\n* serializeData()： 将数据序列化为适合发送 http 请求的格式\n* serializeArray()：序列化一组数据，以便发送 http 请求\n* beforeExecute()：在请求发送之前调用\n* beforeCreate()：在创建 XMLHttpRequest 对象之前调用，如果该函数返回 true，则会返回一个假的 promise 对象\n* afterReceive()：在接受到响应的时候调用，此时，返回的数据都还未做解析处理\n* afterParse()：响应的数据已经经过解析处理了\n* beforeSend()：在 xhr 对象的 open() 调用之后，send 调用之前调用\n\nrequest() 函数只有一个 options 对象参数，其属性如下：\n\n* url：请求 url\n* method：请求方法，POST 、 GET\n* data：请求附带的数据对象\n* xhrFields：给 xhr 对象上混入的属性\n* dataType：返回的数据类型，比如，如果是 `json` 的话，则会对 xhr.responseText 做 JSON 解析\n* contentType：请求 MIME 类型，默认是 application/x-www-form-urlencoded，仅在 method 为非 GET 方式的时候有效\n\nrequest() 函数的 options 参数上还可能混入其他一些参数，这些参数都是通过 xhr.config 来配置的，是 ajax 对象的全局配置，这些属性包括：\n\n* cache：如果为 false，则会在请求的 url 后面加上时间戳参数\n* timeout：如果 timeout 大于0，则会有请求超时。如果发生了超时，则会触发 ajax 对象的 timeout 事件\n* charset：跟在 http contentType 后面的 charset，例如：application/x-www-form-urlencoded;charset=UTF-8\n\najax 对象上除了 request 方法，还有如下一些方法：\n\n* get()：发送 GET 请求的简短方法\n* getJSON()：用 GET 请求获取 JSON 数据\n* post()：发送 post 请求\n* log()：发送前端日志信息，不保证成功，没有回调\n\n### Action.js\n\nAction 类，用于构造 action 对象。action 代表一种动作，比如页面跳转、鼠标事件、键盘事件等，都可以产生一个 action。\n\naction 上会附着 model 和 view，进入 action 的时候，会先去加载 model 指定的数据，然后根据拿到的数据来渲染 view 指定的视图。\n\n任何一个有 enter() 方法的对象都可作为 action 对象。\n\nenter() 方法开启了 action 的生命周期，在 action 的生命周期中，会触发如下事件：\n\n* enter：action 生命周期开始了\n* beforemodelload：action 上的 model（ action.model ） 加载之前触发\n* modelloaded：model 加载完成\n* beforerender：视图渲染之前\n* rendered：视图渲染完成\n* entercomplete：action 完成启动\n* beforeleave：离开 action 之前\n* leave：离开 action 之后，销毁注册在 action 上所有事件之前触发\n\naction 生命周期相关的一些方法：\n\n* enter()：action 入口函数\n* forwardToView()：转入 view 处理流程\n* leave()：离开 action，销毁 action 上的所有事件\n* reload()：重加载当前 action\n\n### Model.js\n\nMVC 中的 Model，主要用于从后端取数据，然后提供一些方法管理取到的数据。其中 load() 方法用于取数据，该方法会根据当前 model 对象上的数据源对象（ model.datasource ）去后端取数据。\n\n数据源是对数据一系列配置，其中保存了多个数据的获取函数，有以下方式：\n\n* 单一数据源配置\n\n    如果`datasource`是一个函数，则认为该函数是一个数据获取函数，\n    执行该函数，并把返回值按照一个对象放到当前 model 中\n    ```js\n    // 配置从指定的URL获取数据\n    datasource = require('./datasource').remote('/model/list')\n    ```\n\n* 并发请求数据\n\n    通过一个对象配置并发的数据获取。对象中每一个属性对应一个获取函数，\n    当数据获取后，会调用 `this.set(name, result)`，以属性名为键值添加\n    ```js\n    // 并发请求多个URL\n    datasource = {\n        'list': require('./datasource').remote('/model/list'),\n        'config': require('./datasource').constant('listConfig')\n    };\n    ```\n\n* 串行请求数据\n\n    通过一个数组配置并发的数据获取，数组中包含对象。将按照数组的顺序，\n    依次加载每一个对象（对象中的各属性是并发）\n    ```js\n    // 串行请求几个URL\n    datasource = [\n        { 'config': require('./datasource').constant('config') },\n        { 'list': require('./datasource').remote('/model/list') }\n    ];\n    ```\n    注意使用该方案时，各对象中的键**不要相同** ，否则会造成数据的覆盖\n\n* 嵌套配置\n\n    数组和对象可以相互嵌套，但有一个限制：\n\n    > 当一个对象中某个属性的值为普通对象（非数据加载配置项）或数组时，\n    > 该属性名将不起作用，即不会在 model 对象中存在以该属性名为键的值。\n\n    以下为一个串行和并行混杂的数据源配置：\n\n    ```js\n    datasource = {\n        'one': [getX, getY, getZ],\n        'two': getA,\n        'three': [\n            { 'four': getB },\n            { 'five': getC }\n        ]\n    };\n    ```\n\n    以上对象将在最终的 model 对象中生成 `two` 、 `four` 和 `five` 属性，而 `one` 、 `two` 和 `three` 因为属性值为普通对象或数组，将被忽略，其中`one`对应3个函数，将会把函数的返回值展开后添加到当前 model 同样，注意在嵌套的同时，各属性名**不要相同**，除非该属性名称没用，以避免出现数据相互覆盖的情况。\n\n* 通过数据获取配置项\n\n    上面所述的各种方案，均是数据获取配置项的简写，一个数据获取配置项的结构请参考 meta/DatasourceOption.js。因此，可以使用数据获取配置项来处理一些例外情况，比如并行加载2个对象，且2个对象均无对应的键值，需要完整添加到 `Model` 对象：\n\n    ```js\n    // 并行加载对象并完整添加到`Model`对象\n    datasource = [\n        {\n            retrieve: require('./datasource').remote('/model/list'),\n            dump: true\n        },\n        {\n            retrieve: require('./datasource').remote('/user/info'),\n            dump: true\n        }\n    ];\n    ```\n\n    对于不同的简写，其与数据获取配置项的对应关系如下：\n\n    - 普通的函数，映射为 `{ retrieve: {fn}, dump: true }`\n    - 对象中的一个属性，映射为 `{ retrieve: {fn}, name: {name} }`\n\n### View.js\n\n在 aciton 的生命周期中，加载完 model 数据之后，就会渲染视图了，此时调用的是 view.render() 方法，也就是说 view.render() 就是 view 的入口函数。er 的视图默认使用 [etpl](https://github.com/ecomfe/etpl) 模版引擎渲染。\n\n在指定容器内渲染出 html 结构之后，就会调用 view.enterDocument() 方法，用于控制元素可见性及绑定事件等DOM操作。比如利用 [esui](https://github.com/ecomfe/esui) 来初始化各种控件等等。\n\n### controller.js\n\n控制器类，负责 URL 与 Action 的调度，将 URL 映射到具体的一个 action 的执行上。\n\n可以使用 controller.registerAction() 方法来注册 action 配置，配置数据放在 controller.actionPathMapping 属性上（ path 到配置对象的映射 ）。每一个配置对象包含以下属性（ actionConfig ）：\n\n* path：该 action 对应的 url path\n* type：如果是一个字符串，则认为是此 action 的模块路径，否则认为就是一个模块对象，直接使用\n* movedTo：如果此属性存在，则会定向到此属性指定的 URL，类似于302\n* childActionOnly：如果为 true，就说明这个配置仅用于子 action\n* authority：权限配置，参考 meta.ActionConfig#authority 属性的说明\n* title：\n* documentTitle\n\n当路径改变时，会调用 controller.renderAction() 方法，此处渲染的是主 Action。渲染之前，会去 controller.actionPathMapping 上查找相应的 action 配置，如果找不到，则会跳转到404 url（404 url 可以通过 controller.setNotFoundLocation() 来设置）；如果没有找到404对应的 action 配置，则会 reject。判断完 action 配置是否存在之后，会检查是否有权限访问这个 url，如果没有权限，则会跳转到没有权限的页面（此页面可以通过 controller.setNoAuthorityLocation() 设置）。\n\n在 action 的渲染过程中，会伴随一个 actionContext 对象，里面包含如下属性：\n\n* url：此 action 对应的 url，是一个 URL 类的对象\n* container：容器元素的 id\n* isChildAction：是否是子 action\n* originalURL：之前的 url，在重定向、404、未授权的情况下，此属性会被设置，指代原始的那个 url\n* title：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）\n* args：有 actionContext 对象的所有属性（除 args 属性之外）\n* documentTitle：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）。此属性比 title 属性优先级低\n\ncontroller 对象有一个 eventBus 属性，该属性是 mini-event.EventBus 的实例。在此实例上，会有如下一系列事件触发：\n\n* forwardaction：加载 action 之前\n* actionmoved：action 重定向，类似于302过程\n* actionnotfound：没有找到当前 url 对应的 action 配置\n* permissiondenied：没有权限访问当前的 url\n* actionabort\n* actionfail：当前 url 没有对应的 action 模块实现，或者创建 action 失败\n* actionloaded：action 加载完成\n* leaveaction：之前的主 action 销毁\n* enteraction：进入 action 之前触发\n\n对于当前 url 加载到的 action 模块对象，如果是一个函数，则认为是一个 Action 构造函数，直接实例化；如果是一个包含 createRuntimeAction() 的对象，则认为这个 createRuntimeAction() 函数就是一个 Action 工厂函数，调用该工厂函数就可以创建出 action 对象；否则认为这个模块对象就是 action 实例。\n\n找到了当前 url 对应的主 action 之后，就要开始进入这个 action 了。在进入之前，需要销毁之前的主 action（调用 action.leave() 方法）。销毁之后，调用 action.enter()，进入当前 action。\n\n\n\n\n","source":"_posts/百度 EFE 前端框架学习笔记（er）.md","raw":"---\ntitle: 百度 EFE 前端框架学习笔记（er）\ndate: 2015-05-29\n---\n\n首先上一张图：\n\n![](https://raw.githubusercontent.com/ecomfe/er/master/doc/asset/er-overview.png)\n<!-- more -->\n\n### ajax.js\n\n此模块返回一个 ajax 对象，用于发送 ajax 请求，最主要的就是 request 方法。同时该对象上也会挂载 Ajax 构造函数。\n\n返回的 ajax 对象上会带有一个钩子属性（ hooks ），钩子属性上包含的类容可能有：\n\n* serializeData()： 将数据序列化为适合发送 http 请求的格式\n* serializeArray()：序列化一组数据，以便发送 http 请求\n* beforeExecute()：在请求发送之前调用\n* beforeCreate()：在创建 XMLHttpRequest 对象之前调用，如果该函数返回 true，则会返回一个假的 promise 对象\n* afterReceive()：在接受到响应的时候调用，此时，返回的数据都还未做解析处理\n* afterParse()：响应的数据已经经过解析处理了\n* beforeSend()：在 xhr 对象的 open() 调用之后，send 调用之前调用\n\nrequest() 函数只有一个 options 对象参数，其属性如下：\n\n* url：请求 url\n* method：请求方法，POST 、 GET\n* data：请求附带的数据对象\n* xhrFields：给 xhr 对象上混入的属性\n* dataType：返回的数据类型，比如，如果是 `json` 的话，则会对 xhr.responseText 做 JSON 解析\n* contentType：请求 MIME 类型，默认是 application/x-www-form-urlencoded，仅在 method 为非 GET 方式的时候有效\n\nrequest() 函数的 options 参数上还可能混入其他一些参数，这些参数都是通过 xhr.config 来配置的，是 ajax 对象的全局配置，这些属性包括：\n\n* cache：如果为 false，则会在请求的 url 后面加上时间戳参数\n* timeout：如果 timeout 大于0，则会有请求超时。如果发生了超时，则会触发 ajax 对象的 timeout 事件\n* charset：跟在 http contentType 后面的 charset，例如：application/x-www-form-urlencoded;charset=UTF-8\n\najax 对象上除了 request 方法，还有如下一些方法：\n\n* get()：发送 GET 请求的简短方法\n* getJSON()：用 GET 请求获取 JSON 数据\n* post()：发送 post 请求\n* log()：发送前端日志信息，不保证成功，没有回调\n\n### Action.js\n\nAction 类，用于构造 action 对象。action 代表一种动作，比如页面跳转、鼠标事件、键盘事件等，都可以产生一个 action。\n\naction 上会附着 model 和 view，进入 action 的时候，会先去加载 model 指定的数据，然后根据拿到的数据来渲染 view 指定的视图。\n\n任何一个有 enter() 方法的对象都可作为 action 对象。\n\nenter() 方法开启了 action 的生命周期，在 action 的生命周期中，会触发如下事件：\n\n* enter：action 生命周期开始了\n* beforemodelload：action 上的 model（ action.model ） 加载之前触发\n* modelloaded：model 加载完成\n* beforerender：视图渲染之前\n* rendered：视图渲染完成\n* entercomplete：action 完成启动\n* beforeleave：离开 action 之前\n* leave：离开 action 之后，销毁注册在 action 上所有事件之前触发\n\naction 生命周期相关的一些方法：\n\n* enter()：action 入口函数\n* forwardToView()：转入 view 处理流程\n* leave()：离开 action，销毁 action 上的所有事件\n* reload()：重加载当前 action\n\n### Model.js\n\nMVC 中的 Model，主要用于从后端取数据，然后提供一些方法管理取到的数据。其中 load() 方法用于取数据，该方法会根据当前 model 对象上的数据源对象（ model.datasource ）去后端取数据。\n\n数据源是对数据一系列配置，其中保存了多个数据的获取函数，有以下方式：\n\n* 单一数据源配置\n\n    如果`datasource`是一个函数，则认为该函数是一个数据获取函数，\n    执行该函数，并把返回值按照一个对象放到当前 model 中\n    ```js\n    // 配置从指定的URL获取数据\n    datasource = require('./datasource').remote('/model/list')\n    ```\n\n* 并发请求数据\n\n    通过一个对象配置并发的数据获取。对象中每一个属性对应一个获取函数，\n    当数据获取后，会调用 `this.set(name, result)`，以属性名为键值添加\n    ```js\n    // 并发请求多个URL\n    datasource = {\n        'list': require('./datasource').remote('/model/list'),\n        'config': require('./datasource').constant('listConfig')\n    };\n    ```\n\n* 串行请求数据\n\n    通过一个数组配置并发的数据获取，数组中包含对象。将按照数组的顺序，\n    依次加载每一个对象（对象中的各属性是并发）\n    ```js\n    // 串行请求几个URL\n    datasource = [\n        { 'config': require('./datasource').constant('config') },\n        { 'list': require('./datasource').remote('/model/list') }\n    ];\n    ```\n    注意使用该方案时，各对象中的键**不要相同** ，否则会造成数据的覆盖\n\n* 嵌套配置\n\n    数组和对象可以相互嵌套，但有一个限制：\n\n    > 当一个对象中某个属性的值为普通对象（非数据加载配置项）或数组时，\n    > 该属性名将不起作用，即不会在 model 对象中存在以该属性名为键的值。\n\n    以下为一个串行和并行混杂的数据源配置：\n\n    ```js\n    datasource = {\n        'one': [getX, getY, getZ],\n        'two': getA,\n        'three': [\n            { 'four': getB },\n            { 'five': getC }\n        ]\n    };\n    ```\n\n    以上对象将在最终的 model 对象中生成 `two` 、 `four` 和 `five` 属性，而 `one` 、 `two` 和 `three` 因为属性值为普通对象或数组，将被忽略，其中`one`对应3个函数，将会把函数的返回值展开后添加到当前 model 同样，注意在嵌套的同时，各属性名**不要相同**，除非该属性名称没用，以避免出现数据相互覆盖的情况。\n\n* 通过数据获取配置项\n\n    上面所述的各种方案，均是数据获取配置项的简写，一个数据获取配置项的结构请参考 meta/DatasourceOption.js。因此，可以使用数据获取配置项来处理一些例外情况，比如并行加载2个对象，且2个对象均无对应的键值，需要完整添加到 `Model` 对象：\n\n    ```js\n    // 并行加载对象并完整添加到`Model`对象\n    datasource = [\n        {\n            retrieve: require('./datasource').remote('/model/list'),\n            dump: true\n        },\n        {\n            retrieve: require('./datasource').remote('/user/info'),\n            dump: true\n        }\n    ];\n    ```\n\n    对于不同的简写，其与数据获取配置项的对应关系如下：\n\n    - 普通的函数，映射为 `{ retrieve: {fn}, dump: true }`\n    - 对象中的一个属性，映射为 `{ retrieve: {fn}, name: {name} }`\n\n### View.js\n\n在 aciton 的生命周期中，加载完 model 数据之后，就会渲染视图了，此时调用的是 view.render() 方法，也就是说 view.render() 就是 view 的入口函数。er 的视图默认使用 [etpl](https://github.com/ecomfe/etpl) 模版引擎渲染。\n\n在指定容器内渲染出 html 结构之后，就会调用 view.enterDocument() 方法，用于控制元素可见性及绑定事件等DOM操作。比如利用 [esui](https://github.com/ecomfe/esui) 来初始化各种控件等等。\n\n### controller.js\n\n控制器类，负责 URL 与 Action 的调度，将 URL 映射到具体的一个 action 的执行上。\n\n可以使用 controller.registerAction() 方法来注册 action 配置，配置数据放在 controller.actionPathMapping 属性上（ path 到配置对象的映射 ）。每一个配置对象包含以下属性（ actionConfig ）：\n\n* path：该 action 对应的 url path\n* type：如果是一个字符串，则认为是此 action 的模块路径，否则认为就是一个模块对象，直接使用\n* movedTo：如果此属性存在，则会定向到此属性指定的 URL，类似于302\n* childActionOnly：如果为 true，就说明这个配置仅用于子 action\n* authority：权限配置，参考 meta.ActionConfig#authority 属性的说明\n* title：\n* documentTitle\n\n当路径改变时，会调用 controller.renderAction() 方法，此处渲染的是主 Action。渲染之前，会去 controller.actionPathMapping 上查找相应的 action 配置，如果找不到，则会跳转到404 url（404 url 可以通过 controller.setNotFoundLocation() 来设置）；如果没有找到404对应的 action 配置，则会 reject。判断完 action 配置是否存在之后，会检查是否有权限访问这个 url，如果没有权限，则会跳转到没有权限的页面（此页面可以通过 controller.setNoAuthorityLocation() 设置）。\n\n在 action 的渲染过程中，会伴随一个 actionContext 对象，里面包含如下属性：\n\n* url：此 action 对应的 url，是一个 URL 类的对象\n* container：容器元素的 id\n* isChildAction：是否是子 action\n* originalURL：之前的 url，在重定向、404、未授权的情况下，此属性会被设置，指代原始的那个 url\n* title：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）\n* args：有 actionContext 对象的所有属性（除 args 属性之外）\n* documentTitle：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）。此属性比 title 属性优先级低\n\ncontroller 对象有一个 eventBus 属性，该属性是 mini-event.EventBus 的实例。在此实例上，会有如下一系列事件触发：\n\n* forwardaction：加载 action 之前\n* actionmoved：action 重定向，类似于302过程\n* actionnotfound：没有找到当前 url 对应的 action 配置\n* permissiondenied：没有权限访问当前的 url\n* actionabort\n* actionfail：当前 url 没有对应的 action 模块实现，或者创建 action 失败\n* actionloaded：action 加载完成\n* leaveaction：之前的主 action 销毁\n* enteraction：进入 action 之前触发\n\n对于当前 url 加载到的 action 模块对象，如果是一个函数，则认为是一个 Action 构造函数，直接实例化；如果是一个包含 createRuntimeAction() 的对象，则认为这个 createRuntimeAction() 函数就是一个 Action 工厂函数，调用该工厂函数就可以创建出 action 对象；否则认为这个模块对象就是 action 实例。\n\n找到了当前 url 对应的主 action 之后，就要开始进入这个 action 了。在进入之前，需要销毁之前的主 action（调用 action.leave() 方法）。销毁之后，调用 action.enter()，进入当前 action。\n\n\n\n\n","slug":"百度 EFE 前端框架学习笔记（er）","published":1,"updated":"2016-06-08T09:52:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tknel000kn407u3fvbns5","content":"<p>首先上一张图：</p>\n<p><img src=\"https://raw.githubusercontent.com/ecomfe/er/master/doc/asset/er-overview.png\" alt=\"\"><br><a id=\"more\"></a></p>\n<h3 id=\"ajax-js\"><a href=\"#ajax-js\" class=\"headerlink\" title=\"ajax.js\"></a>ajax.js</h3><p>此模块返回一个 ajax 对象，用于发送 ajax 请求，最主要的就是 request 方法。同时该对象上也会挂载 Ajax 构造函数。</p>\n<p>返回的 ajax 对象上会带有一个钩子属性（ hooks ），钩子属性上包含的类容可能有：</p>\n<ul>\n<li>serializeData()： 将数据序列化为适合发送 http 请求的格式</li>\n<li>serializeArray()：序列化一组数据，以便发送 http 请求</li>\n<li>beforeExecute()：在请求发送之前调用</li>\n<li>beforeCreate()：在创建 XMLHttpRequest 对象之前调用，如果该函数返回 true，则会返回一个假的 promise 对象</li>\n<li>afterReceive()：在接受到响应的时候调用，此时，返回的数据都还未做解析处理</li>\n<li>afterParse()：响应的数据已经经过解析处理了</li>\n<li>beforeSend()：在 xhr 对象的 open() 调用之后，send 调用之前调用</li>\n</ul>\n<p>request() 函数只有一个 options 对象参数，其属性如下：</p>\n<ul>\n<li>url：请求 url</li>\n<li>method：请求方法，POST 、 GET</li>\n<li>data：请求附带的数据对象</li>\n<li>xhrFields：给 xhr 对象上混入的属性</li>\n<li>dataType：返回的数据类型，比如，如果是 <code>json</code> 的话，则会对 xhr.responseText 做 JSON 解析</li>\n<li>contentType：请求 MIME 类型，默认是 application/x-www-form-urlencoded，仅在 method 为非 GET 方式的时候有效</li>\n</ul>\n<p>request() 函数的 options 参数上还可能混入其他一些参数，这些参数都是通过 xhr.config 来配置的，是 ajax 对象的全局配置，这些属性包括：</p>\n<ul>\n<li>cache：如果为 false，则会在请求的 url 后面加上时间戳参数</li>\n<li>timeout：如果 timeout 大于0，则会有请求超时。如果发生了超时，则会触发 ajax 对象的 timeout 事件</li>\n<li>charset：跟在 http contentType 后面的 charset，例如：application/x-www-form-urlencoded;charset=UTF-8</li>\n</ul>\n<p>ajax 对象上除了 request 方法，还有如下一些方法：</p>\n<ul>\n<li>get()：发送 GET 请求的简短方法</li>\n<li>getJSON()：用 GET 请求获取 JSON 数据</li>\n<li>post()：发送 post 请求</li>\n<li>log()：发送前端日志信息，不保证成功，没有回调</li>\n</ul>\n<h3 id=\"Action-js\"><a href=\"#Action-js\" class=\"headerlink\" title=\"Action.js\"></a>Action.js</h3><p>Action 类，用于构造 action 对象。action 代表一种动作，比如页面跳转、鼠标事件、键盘事件等，都可以产生一个 action。</p>\n<p>action 上会附着 model 和 view，进入 action 的时候，会先去加载 model 指定的数据，然后根据拿到的数据来渲染 view 指定的视图。</p>\n<p>任何一个有 enter() 方法的对象都可作为 action 对象。</p>\n<p>enter() 方法开启了 action 的生命周期，在 action 的生命周期中，会触发如下事件：</p>\n<ul>\n<li>enter：action 生命周期开始了</li>\n<li>beforemodelload：action 上的 model（ action.model ） 加载之前触发</li>\n<li>modelloaded：model 加载完成</li>\n<li>beforerender：视图渲染之前</li>\n<li>rendered：视图渲染完成</li>\n<li>entercomplete：action 完成启动</li>\n<li>beforeleave：离开 action 之前</li>\n<li>leave：离开 action 之后，销毁注册在 action 上所有事件之前触发</li>\n</ul>\n<p>action 生命周期相关的一些方法：</p>\n<ul>\n<li>enter()：action 入口函数</li>\n<li>forwardToView()：转入 view 处理流程</li>\n<li>leave()：离开 action，销毁 action 上的所有事件</li>\n<li>reload()：重加载当前 action</li>\n</ul>\n<h3 id=\"Model-js\"><a href=\"#Model-js\" class=\"headerlink\" title=\"Model.js\"></a>Model.js</h3><p>MVC 中的 Model，主要用于从后端取数据，然后提供一些方法管理取到的数据。其中 load() 方法用于取数据，该方法会根据当前 model 对象上的数据源对象（ model.datasource ）去后端取数据。</p>\n<p>数据源是对数据一系列配置，其中保存了多个数据的获取函数，有以下方式：</p>\n<ul>\n<li><p>单一数据源配置</p>\n<p>  如果<code>datasource</code>是一个函数，则认为该函数是一个数据获取函数，<br>  执行该函数，并把返回值按照一个对象放到当前 model 中</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置从指定的URL获取数据</span></span><br><span class=\"line\">datasource = <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并发请求数据</p>\n<p>  通过一个对象配置并发的数据获取。对象中每一个属性对应一个获取函数，<br>  当数据获取后，会调用 <code>this.set(name, result)</code>，以属性名为键值添加</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并发请求多个URL</span></span><br><span class=\"line\">datasource = &#123;</span><br><span class=\"line\">    <span class=\"string\">'list'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>),</span><br><span class=\"line\">    <span class=\"string\">'config'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).constant(<span class=\"string\">'listConfig'</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>串行请求数据</p>\n<p>  通过一个数组配置并发的数据获取，数组中包含对象。将按照数组的顺序，<br>  依次加载每一个对象（对象中的各属性是并发）</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串行请求几个URL</span></span><br><span class=\"line\">datasource = [</span><br><span class=\"line\">    &#123; <span class=\"string\">'config'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).constant(<span class=\"string\">'config'</span>) &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">'list'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>) &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>  注意使用该方案时，各对象中的键<strong>不要相同</strong> ，否则会造成数据的覆盖</p>\n</li>\n<li><p>嵌套配置</p>\n<p>  数组和对象可以相互嵌套，但有一个限制：</p>\n<blockquote>\n<p>当一个对象中某个属性的值为普通对象（非数据加载配置项）或数组时，<br>该属性名将不起作用，即不会在 model 对象中存在以该属性名为键的值。</p>\n</blockquote>\n<p>  以下为一个串行和并行混杂的数据源配置：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datasource = &#123;</span><br><span class=\"line\">    <span class=\"string\">'one'</span>: [getX, getY, getZ],</span><br><span class=\"line\">    <span class=\"string\">'two'</span>: getA,</span><br><span class=\"line\">    <span class=\"string\">'three'</span>: [</span><br><span class=\"line\">        &#123; <span class=\"string\">'four'</span>: getB &#125;,</span><br><span class=\"line\">        &#123; <span class=\"string\">'five'</span>: getC &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  以上对象将在最终的 model 对象中生成 <code>two</code> 、 <code>four</code> 和 <code>five</code> 属性，而 <code>one</code> 、 <code>two</code> 和 <code>three</code> 因为属性值为普通对象或数组，将被忽略，其中<code>one</code>对应3个函数，将会把函数的返回值展开后添加到当前 model 同样，注意在嵌套的同时，各属性名<strong>不要相同</strong>，除非该属性名称没用，以避免出现数据相互覆盖的情况。</p>\n</li>\n<li><p>通过数据获取配置项</p>\n<p>  上面所述的各种方案，均是数据获取配置项的简写，一个数据获取配置项的结构请参考 meta/DatasourceOption.js。因此，可以使用数据获取配置项来处理一些例外情况，比如并行加载2个对象，且2个对象均无对应的键值，需要完整添加到 <code>Model</code> 对象：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并行加载对象并完整添加到`Model`对象</span></span><br><span class=\"line\">datasource = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        retrieve: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>),</span><br><span class=\"line\">        dump: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        retrieve: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/user/info'</span>),</span><br><span class=\"line\">        dump: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>  对于不同的简写，其与数据获取配置项的对应关系如下：</p>\n<ul>\n<li>普通的函数，映射为 <code>{ retrieve: {fn}, dump: true }</code></li>\n<li>对象中的一个属性，映射为 <code>{ retrieve: {fn}, name: {name} }</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"View-js\"><a href=\"#View-js\" class=\"headerlink\" title=\"View.js\"></a>View.js</h3><p>在 aciton 的生命周期中，加载完 model 数据之后，就会渲染视图了，此时调用的是 view.render() 方法，也就是说 view.render() 就是 view 的入口函数。er 的视图默认使用 <a href=\"https://github.com/ecomfe/etpl\" target=\"_blank\" rel=\"external\">etpl</a> 模版引擎渲染。</p>\n<p>在指定容器内渲染出 html 结构之后，就会调用 view.enterDocument() 方法，用于控制元素可见性及绑定事件等DOM操作。比如利用 <a href=\"https://github.com/ecomfe/esui\" target=\"_blank\" rel=\"external\">esui</a> 来初始化各种控件等等。</p>\n<h3 id=\"controller-js\"><a href=\"#controller-js\" class=\"headerlink\" title=\"controller.js\"></a>controller.js</h3><p>控制器类，负责 URL 与 Action 的调度，将 URL 映射到具体的一个 action 的执行上。</p>\n<p>可以使用 controller.registerAction() 方法来注册 action 配置，配置数据放在 controller.actionPathMapping 属性上（ path 到配置对象的映射 ）。每一个配置对象包含以下属性（ actionConfig ）：</p>\n<ul>\n<li>path：该 action 对应的 url path</li>\n<li>type：如果是一个字符串，则认为是此 action 的模块路径，否则认为就是一个模块对象，直接使用</li>\n<li>movedTo：如果此属性存在，则会定向到此属性指定的 URL，类似于302</li>\n<li>childActionOnly：如果为 true，就说明这个配置仅用于子 action</li>\n<li>authority：权限配置，参考 meta.ActionConfig#authority 属性的说明</li>\n<li>title：</li>\n<li>documentTitle</li>\n</ul>\n<p>当路径改变时，会调用 controller.renderAction() 方法，此处渲染的是主 Action。渲染之前，会去 controller.actionPathMapping 上查找相应的 action 配置，如果找不到，则会跳转到404 url（404 url 可以通过 controller.setNotFoundLocation() 来设置）；如果没有找到404对应的 action 配置，则会 reject。判断完 action 配置是否存在之后，会检查是否有权限访问这个 url，如果没有权限，则会跳转到没有权限的页面（此页面可以通过 controller.setNoAuthorityLocation() 设置）。</p>\n<p>在 action 的渲染过程中，会伴随一个 actionContext 对象，里面包含如下属性：</p>\n<ul>\n<li>url：此 action 对应的 url，是一个 URL 类的对象</li>\n<li>container：容器元素的 id</li>\n<li>isChildAction：是否是子 action</li>\n<li>originalURL：之前的 url，在重定向、404、未授权的情况下，此属性会被设置，指代原始的那个 url</li>\n<li>title：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）</li>\n<li>args：有 actionContext 对象的所有属性（除 args 属性之外）</li>\n<li>documentTitle：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）。此属性比 title 属性优先级低</li>\n</ul>\n<p>controller 对象有一个 eventBus 属性，该属性是 mini-event.EventBus 的实例。在此实例上，会有如下一系列事件触发：</p>\n<ul>\n<li>forwardaction：加载 action 之前</li>\n<li>actionmoved：action 重定向，类似于302过程</li>\n<li>actionnotfound：没有找到当前 url 对应的 action 配置</li>\n<li>permissiondenied：没有权限访问当前的 url</li>\n<li>actionabort</li>\n<li>actionfail：当前 url 没有对应的 action 模块实现，或者创建 action 失败</li>\n<li>actionloaded：action 加载完成</li>\n<li>leaveaction：之前的主 action 销毁</li>\n<li>enteraction：进入 action 之前触发</li>\n</ul>\n<p>对于当前 url 加载到的 action 模块对象，如果是一个函数，则认为是一个 Action 构造函数，直接实例化；如果是一个包含 createRuntimeAction() 的对象，则认为这个 createRuntimeAction() 函数就是一个 Action 工厂函数，调用该工厂函数就可以创建出 action 对象；否则认为这个模块对象就是 action 实例。</p>\n<p>找到了当前 url 对应的主 action 之后，就要开始进入这个 action 了。在进入之前，需要销毁之前的主 action（调用 action.leave() 方法）。销毁之后，调用 action.enter()，进入当前 action。</p>\n","excerpt":"<p>首先上一张图：</p>\n<p><img src=\"https://raw.githubusercontent.com/ecomfe/er/master/doc/asset/er-overview.png\" alt=\"\"><br>","more":"</p>\n<h3 id=\"ajax-js\"><a href=\"#ajax-js\" class=\"headerlink\" title=\"ajax.js\"></a>ajax.js</h3><p>此模块返回一个 ajax 对象，用于发送 ajax 请求，最主要的就是 request 方法。同时该对象上也会挂载 Ajax 构造函数。</p>\n<p>返回的 ajax 对象上会带有一个钩子属性（ hooks ），钩子属性上包含的类容可能有：</p>\n<ul>\n<li>serializeData()： 将数据序列化为适合发送 http 请求的格式</li>\n<li>serializeArray()：序列化一组数据，以便发送 http 请求</li>\n<li>beforeExecute()：在请求发送之前调用</li>\n<li>beforeCreate()：在创建 XMLHttpRequest 对象之前调用，如果该函数返回 true，则会返回一个假的 promise 对象</li>\n<li>afterReceive()：在接受到响应的时候调用，此时，返回的数据都还未做解析处理</li>\n<li>afterParse()：响应的数据已经经过解析处理了</li>\n<li>beforeSend()：在 xhr 对象的 open() 调用之后，send 调用之前调用</li>\n</ul>\n<p>request() 函数只有一个 options 对象参数，其属性如下：</p>\n<ul>\n<li>url：请求 url</li>\n<li>method：请求方法，POST 、 GET</li>\n<li>data：请求附带的数据对象</li>\n<li>xhrFields：给 xhr 对象上混入的属性</li>\n<li>dataType：返回的数据类型，比如，如果是 <code>json</code> 的话，则会对 xhr.responseText 做 JSON 解析</li>\n<li>contentType：请求 MIME 类型，默认是 application/x-www-form-urlencoded，仅在 method 为非 GET 方式的时候有效</li>\n</ul>\n<p>request() 函数的 options 参数上还可能混入其他一些参数，这些参数都是通过 xhr.config 来配置的，是 ajax 对象的全局配置，这些属性包括：</p>\n<ul>\n<li>cache：如果为 false，则会在请求的 url 后面加上时间戳参数</li>\n<li>timeout：如果 timeout 大于0，则会有请求超时。如果发生了超时，则会触发 ajax 对象的 timeout 事件</li>\n<li>charset：跟在 http contentType 后面的 charset，例如：application/x-www-form-urlencoded;charset=UTF-8</li>\n</ul>\n<p>ajax 对象上除了 request 方法，还有如下一些方法：</p>\n<ul>\n<li>get()：发送 GET 请求的简短方法</li>\n<li>getJSON()：用 GET 请求获取 JSON 数据</li>\n<li>post()：发送 post 请求</li>\n<li>log()：发送前端日志信息，不保证成功，没有回调</li>\n</ul>\n<h3 id=\"Action-js\"><a href=\"#Action-js\" class=\"headerlink\" title=\"Action.js\"></a>Action.js</h3><p>Action 类，用于构造 action 对象。action 代表一种动作，比如页面跳转、鼠标事件、键盘事件等，都可以产生一个 action。</p>\n<p>action 上会附着 model 和 view，进入 action 的时候，会先去加载 model 指定的数据，然后根据拿到的数据来渲染 view 指定的视图。</p>\n<p>任何一个有 enter() 方法的对象都可作为 action 对象。</p>\n<p>enter() 方法开启了 action 的生命周期，在 action 的生命周期中，会触发如下事件：</p>\n<ul>\n<li>enter：action 生命周期开始了</li>\n<li>beforemodelload：action 上的 model（ action.model ） 加载之前触发</li>\n<li>modelloaded：model 加载完成</li>\n<li>beforerender：视图渲染之前</li>\n<li>rendered：视图渲染完成</li>\n<li>entercomplete：action 完成启动</li>\n<li>beforeleave：离开 action 之前</li>\n<li>leave：离开 action 之后，销毁注册在 action 上所有事件之前触发</li>\n</ul>\n<p>action 生命周期相关的一些方法：</p>\n<ul>\n<li>enter()：action 入口函数</li>\n<li>forwardToView()：转入 view 处理流程</li>\n<li>leave()：离开 action，销毁 action 上的所有事件</li>\n<li>reload()：重加载当前 action</li>\n</ul>\n<h3 id=\"Model-js\"><a href=\"#Model-js\" class=\"headerlink\" title=\"Model.js\"></a>Model.js</h3><p>MVC 中的 Model，主要用于从后端取数据，然后提供一些方法管理取到的数据。其中 load() 方法用于取数据，该方法会根据当前 model 对象上的数据源对象（ model.datasource ）去后端取数据。</p>\n<p>数据源是对数据一系列配置，其中保存了多个数据的获取函数，有以下方式：</p>\n<ul>\n<li><p>单一数据源配置</p>\n<p>  如果<code>datasource</code>是一个函数，则认为该函数是一个数据获取函数，<br>  执行该函数，并把返回值按照一个对象放到当前 model 中</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 配置从指定的URL获取数据</span></span><br><span class=\"line\">datasource = <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>并发请求数据</p>\n<p>  通过一个对象配置并发的数据获取。对象中每一个属性对应一个获取函数，<br>  当数据获取后，会调用 <code>this.set(name, result)</code>，以属性名为键值添加</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并发请求多个URL</span></span><br><span class=\"line\">datasource = &#123;</span><br><span class=\"line\">    <span class=\"string\">'list'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>),</span><br><span class=\"line\">    <span class=\"string\">'config'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).constant(<span class=\"string\">'listConfig'</span>)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>串行请求数据</p>\n<p>  通过一个数组配置并发的数据获取，数组中包含对象。将按照数组的顺序，<br>  依次加载每一个对象（对象中的各属性是并发）</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 串行请求几个URL</span></span><br><span class=\"line\">datasource = [</span><br><span class=\"line\">    &#123; <span class=\"string\">'config'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).constant(<span class=\"string\">'config'</span>) &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">'list'</span>: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>) &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>  注意使用该方案时，各对象中的键<strong>不要相同</strong> ，否则会造成数据的覆盖</p>\n</li>\n<li><p>嵌套配置</p>\n<p>  数组和对象可以相互嵌套，但有一个限制：</p>\n<blockquote>\n<p>当一个对象中某个属性的值为普通对象（非数据加载配置项）或数组时，<br>该属性名将不起作用，即不会在 model 对象中存在以该属性名为键的值。</p>\n</blockquote>\n<p>  以下为一个串行和并行混杂的数据源配置：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">datasource = &#123;</span><br><span class=\"line\">    <span class=\"string\">'one'</span>: [getX, getY, getZ],</span><br><span class=\"line\">    <span class=\"string\">'two'</span>: getA,</span><br><span class=\"line\">    <span class=\"string\">'three'</span>: [</span><br><span class=\"line\">        &#123; <span class=\"string\">'four'</span>: getB &#125;,</span><br><span class=\"line\">        &#123; <span class=\"string\">'five'</span>: getC &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>  以上对象将在最终的 model 对象中生成 <code>two</code> 、 <code>four</code> 和 <code>five</code> 属性，而 <code>one</code> 、 <code>two</code> 和 <code>three</code> 因为属性值为普通对象或数组，将被忽略，其中<code>one</code>对应3个函数，将会把函数的返回值展开后添加到当前 model 同样，注意在嵌套的同时，各属性名<strong>不要相同</strong>，除非该属性名称没用，以避免出现数据相互覆盖的情况。</p>\n</li>\n<li><p>通过数据获取配置项</p>\n<p>  上面所述的各种方案，均是数据获取配置项的简写，一个数据获取配置项的结构请参考 meta/DatasourceOption.js。因此，可以使用数据获取配置项来处理一些例外情况，比如并行加载2个对象，且2个对象均无对应的键值，需要完整添加到 <code>Model</code> 对象：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 并行加载对象并完整添加到`Model`对象</span></span><br><span class=\"line\">datasource = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        retrieve: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/model/list'</span>),</span><br><span class=\"line\">        dump: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        retrieve: <span class=\"built_in\">require</span>(<span class=\"string\">'./datasource'</span>).remote(<span class=\"string\">'/user/info'</span>),</span><br><span class=\"line\">        dump: <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<p>  对于不同的简写，其与数据获取配置项的对应关系如下：</p>\n<ul>\n<li>普通的函数，映射为 <code>{ retrieve: {fn}, dump: true }</code></li>\n<li>对象中的一个属性，映射为 <code>{ retrieve: {fn}, name: {name} }</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"View-js\"><a href=\"#View-js\" class=\"headerlink\" title=\"View.js\"></a>View.js</h3><p>在 aciton 的生命周期中，加载完 model 数据之后，就会渲染视图了，此时调用的是 view.render() 方法，也就是说 view.render() 就是 view 的入口函数。er 的视图默认使用 <a href=\"https://github.com/ecomfe/etpl\">etpl</a> 模版引擎渲染。</p>\n<p>在指定容器内渲染出 html 结构之后，就会调用 view.enterDocument() 方法，用于控制元素可见性及绑定事件等DOM操作。比如利用 <a href=\"https://github.com/ecomfe/esui\">esui</a> 来初始化各种控件等等。</p>\n<h3 id=\"controller-js\"><a href=\"#controller-js\" class=\"headerlink\" title=\"controller.js\"></a>controller.js</h3><p>控制器类，负责 URL 与 Action 的调度，将 URL 映射到具体的一个 action 的执行上。</p>\n<p>可以使用 controller.registerAction() 方法来注册 action 配置，配置数据放在 controller.actionPathMapping 属性上（ path 到配置对象的映射 ）。每一个配置对象包含以下属性（ actionConfig ）：</p>\n<ul>\n<li>path：该 action 对应的 url path</li>\n<li>type：如果是一个字符串，则认为是此 action 的模块路径，否则认为就是一个模块对象，直接使用</li>\n<li>movedTo：如果此属性存在，则会定向到此属性指定的 URL，类似于302</li>\n<li>childActionOnly：如果为 true，就说明这个配置仅用于子 action</li>\n<li>authority：权限配置，参考 meta.ActionConfig#authority 属性的说明</li>\n<li>title：</li>\n<li>documentTitle</li>\n</ul>\n<p>当路径改变时，会调用 controller.renderAction() 方法，此处渲染的是主 Action。渲染之前，会去 controller.actionPathMapping 上查找相应的 action 配置，如果找不到，则会跳转到404 url（404 url 可以通过 controller.setNotFoundLocation() 来设置）；如果没有找到404对应的 action 配置，则会 reject。判断完 action 配置是否存在之后，会检查是否有权限访问这个 url，如果没有权限，则会跳转到没有权限的页面（此页面可以通过 controller.setNoAuthorityLocation() 设置）。</p>\n<p>在 action 的渲染过程中，会伴随一个 actionContext 对象，里面包含如下属性：</p>\n<ul>\n<li>url：此 action 对应的 url，是一个 URL 类的对象</li>\n<li>container：容器元素的 id</li>\n<li>isChildAction：是否是子 action</li>\n<li>originalURL：之前的 url，在重定向、404、未授权的情况下，此属性会被设置，指代原始的那个 url</li>\n<li>title：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）</li>\n<li>args：有 actionContext 对象的所有属性（除 args 属性之外）</li>\n<li>documentTitle：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）。此属性比 title 属性优先级低</li>\n</ul>\n<p>controller 对象有一个 eventBus 属性，该属性是 mini-event.EventBus 的实例。在此实例上，会有如下一系列事件触发：</p>\n<ul>\n<li>forwardaction：加载 action 之前</li>\n<li>actionmoved：action 重定向，类似于302过程</li>\n<li>actionnotfound：没有找到当前 url 对应的 action 配置</li>\n<li>permissiondenied：没有权限访问当前的 url</li>\n<li>actionabort</li>\n<li>actionfail：当前 url 没有对应的 action 模块实现，或者创建 action 失败</li>\n<li>actionloaded：action 加载完成</li>\n<li>leaveaction：之前的主 action 销毁</li>\n<li>enteraction：进入 action 之前触发</li>\n</ul>\n<p>对于当前 url 加载到的 action 模块对象，如果是一个函数，则认为是一个 Action 构造函数，直接实例化；如果是一个包含 createRuntimeAction() 的对象，则认为这个 createRuntimeAction() 函数就是一个 Action 工厂函数，调用该工厂函数就可以创建出 action 对象；否则认为这个模块对象就是 action 实例。</p>\n<p>找到了当前 url 对应的主 action 之后，就要开始进入这个 action 了。在进入之前，需要销毁之前的主 action（调用 action.leave() 方法）。销毁之后，调用 action.enter()，进入当前 action。</p>"},{"title":"百度 EFE 前端框架学习笔记（esui）","date":"2015-05-31T16:00:00.000Z","_content":"\n基础点：\n\n### Control.js\n\n控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。\n\n包含如下一些自有属性：\n\n* type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等\n* skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更\n* styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替\n* id ： 控件的 id\n\n<!-- more -->\n\n这些属性（ property ）均可在 html 代码中设置，比如：\n\n```html\n<div data-ui-type=\"Button\"></div>\n```\n\n还有另外一部分自有属性，这些属性不能用于 html 代码设置：\n\n* helper ：控件常用的一些方法组成的一个对象属性\n* children ：子控件数组\n* childrenIndex\n* currentStates\n* domEvents\n* main ： 控件的主元素， HTMLElement 类型\n\n原型（ Control.prototype ）上面有一些对象属性：\n\n* ignoreStates ： 指定在哪些状态下该元素不处理相关的DOM事件\n\n控件的生命周期中，有如下状态：\n\n* NEW ： 在进入构造函数后，控件的状态就是 NEW 了\n* INITED ： 控件完成 options 初始化（ initOptions() ）、视图环境初始化（ initViewContext() ）、扩展初始化（ initExtensions() ）之后状态就是 INITED 了\n* RENDERED ： 控件第一次调用 render() 方法之后，就转变为 RENDERED 了\n* DISPOSED ： 控件处于非 DISPOSED 状态下，调用 destroy() 方法，就变成了 DISPOSED 状态了\n\nControl 上有一个重要的方法 render() ，用于渲染控件，该方法会去调用 repaint() 方法。\n\n另外，Control 上还有一些 DOM 操作的方法，比如 appendTo() 、 insertBefore() 等。\n\nControl 上的 get() 和 set() 很有猫腻。举个例子，如果这样调用 get() 方法： `get('some-title')` ，首先会去检测当前实例上面有没有 `getSomeTitle()` 方法，如果有，则直接调用这个方法，返回这个方法的返回值；如果没有，则直接返回当前对象的 `some-title` 属性。 `set()` 方法也是类似的。\n\nsetProperties() 方法可以用来批量设置属性，它会对一些特殊属性进行处理、控制，比如：\n\n* 只有在渲染以前（就是 `initOptions()` 调用的那次）才允许设置 id 属性\n* 如果要设置 viewContext ，则直接调用 setViewContext() 设置\n* 有些属性要转换成布尔值，比如 disabled 、 hidden\n\nsetProperties() 也会对批量设置的值进行脏检测，如果发现有属性值发生了改变，则会调用 repaint() 方法。脏检测函数是 isPropertyChanged() ， 默认只会用恒等号去判断是否变化，但是可以在子类中覆盖这个方法，实现自己想要的脏检测功能。\n\n### Button.js\n\n按钮控件。主要有这么几种按钮：普通按钮、添加按钮、下载按钮、链接按钮、右上角关闭按钮。\n\n可以对按钮设置皮肤（ data-ui-skin ），内置的皮肤有： spring 、 spring-add 、 download 、 layerClose 、 link 。\n\n可以禁用掉按钮（ data-ui-disabled=\"diabled\" ）。\n\n按钮上 DOM 相关的事件只有 click 。由于按钮是间接继承自 EventTarget ，所以可以使用 on 、 un 等方法处理事件：\n\n```js\n// 给按钮绑定事件处理函数\nsomeButton.on('click', handler);\n\n// 5s 后取消绑定事件绑定\nsetTimeout(function () {\n    someButton.un('click', handler);\n}, 5000);\n\n// 只执行一次的回调函数\nsomeButton.once('click', function () {\n    // only once\n});\n\nfunction handler(event) {\n    // do something\n}\n```\n\n具体按钮 demo 可参看[此处](http://yibuyisheng.github.io/esui-demo/demo/Button.html)。\n\n### Validator\n\n数据验证模块，主要有三个基础类 Validity 、 ValidityState 、 Rule 。\n\nValidityState 表示某个控件的某一条验证规则的状态（是否验证通过），有两个自有属性：\n\n* state ： 验证状态， `true` 为值合法， `false` 为值非法\n* message ： 验证信息，比如说错误提示语\n\nRule 是验证规则基类，是对 InputControl 的值的验证逻辑的抽象。每一个验证规则都包含一个 `check(value, control)` 方法，该方法返回一个 ValidityState 对象以表示验证结果。验证规则必须通过 main.registerRule() 进行注册后才可生效。每一个验证规则包含 `prototype.type` 属性来确定规则的类型。验证规则并不会显式地附加到控件上，而是通过控件自身的属性决定哪些规则生效，当控件本身具有与规则的`type`属性相同的属性时，此规则即会生效，例如：\n\n```js\nvar textbox = main.create('TextBox', { maxLength: 30 });\ntextbox.validate();\n```\n\n由于 `textbox` 上存在 `maxLength` 属性，因此 `MaxLengthRule` 会对其进行验证，此特性可以从 main.createRulesByControl() 方法中看出。\n\nValidity 主要用于存放一系列验证结果（ ValidityState ），如果验证失败，则会触发 InputControl 的 invalid 事件，该事件会带上一个 Validity 对象作为参数。\n\n### InputControl.js\n\n输入控件基类模块，用于表示需要在表单中包含的控件，主要提供 `getRawValue()` 和 `getValue()` 方法供获取值。该类是一个抽象类，不应该直接使用。\n\n需要注意的是，控件其实并不通过严格的继承关系来判断一个控件是否为输入控件，只要 `getCategory()` 返回为 `\"input\"` 、 `\"check\" 或 `\"extend\"` 就认为是输入控件。\n\n相比普通控件的 **禁用 / 启用** ，输入控件共有3种状态：\n\n- 普通状态：可编辑，值随表单提交\n- `disabled` ：禁用状态，此状态下控件不能编辑，同时值不随表单提交\n- `readOnly` ：只读状态，此状态下控件不能编辑，但其值会随表单提交\n\nsetValue() 和 getValue() 分别用于设置输入控件的值和获取输入控件的值。 getRawValue() 和 setRawValue() 用于处理控件原始值，原始值的格式由控件自身决定。这两对处理输入控件值的方法的主要区别是，setValue() 会先调用控件的 parseValue() （子类可重写此方法）方法转换传入的值，然后再调用 setRawValue() 设置到控件上面去， getValue() 也会调用控件的 stringifyValue() （子类可重写此方法）将 getRawValue() 得到的值转换后返回。\n\ngetValidationResult() 方法用于获取此控件数据验证结果。\n\n### BoxGroup.js\n\n选择框组控件的各种使用可参见[此处](http://yibuyisheng.github.io/esui-demo/demo/BoxGroup.html)。\n\n### CheckBox.js\n\n`CheckBox` 控件在初始化时可以提供 `datasource` 属性，该属性用于控件判断一开始是否选中，且这个属性只在初始化时有效，不会保存下来。`datasource`可以是以下类型：\n\n- 数组：此时只要`rawValue`在`datasource`中（使用`==`比较）则选上\n- 其它：只要`rawValue`与此相等（使用`==`比较）则选上\n\n[示例](http://127.0.0.1:8848/demo/CheckBox.html)。\n\n### ControlCollection.js\n\n控件集合，类似 `jQuery` 对象的功能，提供便携的方法来访问和修改一个或多个控件。\n\n`ControlCollection` 提供 Control 的所有**公有**方法，但*没有*任何**保护或私有**方法。\n\n对于方法， `ControlCollection` 采用 **Write all, Read first** 的策略，需要注意的是，类似 setProperties() 的方法虽然有返回值，但被归类于写操作，因此会对所有内部的控件生效，但只返回第一个控件执行的结果。\n\n`ControlCollection` 仅继承 Control 的方法，并不包含任何子类独有方法，因此无法认为集合是一个 InputControl 而执行如下代码：\n\n```js\ncollection.setValue('foo');\n```\n\n此时可以使用通用的 set() 方法来代替：\n\n```js\ncollection.set('value', 'foo');\n```\n\n根据 set() 方法的规则，如果控件存在 `setValue()` 方法，则会进行调用。\n\n### ViewContext.js\n\n视图环境类，一个视图环境是一组控件的集合，不同视图环境中相同 id 的控件的 DOM id 不会重复。\n\n该类的实例包含的主要属性为：\n\n* controls ：该视图环境下所有的控件\n* groups ：视图环境控件分组集合\n* id ：视图环境 id，只读\n\n当前页面所有的视图环境对象都会以`id->对象`的形式保存在私有的 pool 变量中。\n\n### painters.js\n\n渲染器模块，负责 dom 渲染。\n\n可以生成各种各样的渲染器（ painter ）。例如：\n\n* painters.state()：生成一个将属性与控件状态关联的渲染器\n* painters.attribute()：生成一个将控件属性与控件主元素元素的属性关联的渲染器\n* painters.style()：生成一个将控件属性与控件主元素元素的样式关联的渲染器\n* painters.html()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器\n* painters.text()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器\n* painters.delegate()：生成一个将控件属性的变化代理到指定成员的指定方法上\n\n借助于这些方法，可以为某一个控件生成一组渲染器，当该控件发生了变化（样式属性变化等），相应的渲染器就会被调用，从而保证了数据与界面的一致性，形成了单向数据流，同时也比较细腻度地更新指定界面部分，不会出现全局刷新的情况。\n\n### Extension.js\n\n扩展基类，针对控件的扩展。\n\n`Extension` 类为扩展基类，所有扩展类需要继承于 `Extension` 。扩展类需要通过 main.registerExtension 方法，注册扩展类型。注册扩展类型时将自动根据 `prototype.type` 进行类型关联。\n\n一个控件实例可以组合多个`Extension`实例，但一个控件实例对同种类型（即 `type` 相同）的 `Extension` ，只能拥有一份。\n\n从设计上而言， `Extension` 不同于普通脚本对控件的操作，相比 ESUI 从设计理念上不希望普通脚本操作控件的保护属性及内部DOM元素，扩展则对控件拥有**完全开放**的权限，这包含但不限于：\n\n- 注册事件、修改属性等其它逻辑程序可做的行为。\n- 覆盖控件实例上的相应函数，如 `render()` 或 `addChild()` 等。\n- 读取`核心属性`与`关键属性`，包括 `type` 、 `main` 等。\n- 可接触控件内部的 DOM 对象，即可以访问 `main` 及其子树，并对 DOM 做任何操作。\n\n在控件初始化时，会对扩展进行初始化，其基本流程为：\n\n1、 当控件 `init` 之后，会依次对所有关联 `Extension` ，调用 `attachTo()` 方法。一个类型的 `Extension` 仅能在控件实例上附加一次，如果一个控件已经附加了同类型的 `Extension` 实例，则跳过本次 `attachTo` 操作。\n2、 当控件 `dispose` 之前，会依次对所有关联 `Extension` ，调用其 `dispose()` 方法。\n\n有多种方法可以将扩展绑定到具体的控件实例上：\n\n- 在控件创建时绑定\n\n    通过控件构造函数参数 `options.extensions` 可以为控件绑定扩展。\n\n    ```js\n    new TextBox({\n        extensions: [\n            new MyExtension({ ... }),\n            new OtherExtension({ ... })\n        ]\n    });\n    ```\n\n- 在使用HTML生成时绑定\n\n    在HTML中，使用 `data-ui-extension-xxx` 属性注册一个扩展：\n\n    ```html\n    <div id=\"main-panel\" class=\"wrapper\"\n        data-ui-type=\"Panel\"\n        data-ui-extension-command-type=\"Command\"\n        data-ui-extension-command-events=\"click,keypress,keyup\"\n        data-ui-extension-command-use-capture=\"false\"\n    </div>\n    ```\n\n    在HTML中，使用 `data-ui-extension-*-property` 属性添加扩展，其中`*`作为扩展的分组，可以是任何字符串，相同的`*`将作为对同一扩展的定义，必须包含 `data-ui-extension-*-type` 定义扩展的类型，而其它 `data-ui-extension-*-property=\"value\"` 属性则将作为 `options` 参数的属性传递给扩展的构造函数。\n\n- 在实例创建后动态地绑定\n\n    在控件创建后，可以动态创建扩展并在适当的时候绑定至控件。\n\n    ```js\n    var panel = new Label({ text: 'abc' });\n    var delegateDOMEvents = main.createExtension(\n        'Command',\n        {\n            eventTypes: ['click', 'keypress', 'keyup'],\n            useCapture: false\n        }\n    );\n    // 需主动调用attachTo方法\n    delegateDomEvents.attachTo(panel);\n    panel.appendTo(container);\n    ```\n\n- 全局绑定\n\n    调用{@link main#attachExtension}函数可在全局注册一个扩展：\n\n    ```js\n    main.attachExtension('Command', { events: ['click'] });\n    ```\n\n    全局注册的扩展，将会被附加到**所有**控件的实例上。使用 `options` 参数作为 `Extension` 创建时的选项，创建 `Extension` 实例时会对 `options` 做复制处理。\n\n    具体可以参考 extension.Command 作为示例，来学习扩展的编写。\n\n### src/main.js 中的 main.init() 方法\n\n该方法是整个 esui 的入口方法，可以指定当前要使用 esui 的 dom 节点容器，类似于 angular.bootstrap() 或者 React.render()，都是以指定的 dom 元素为根，然后开始渲染这块地盘。具体参数传递可参看文档。\n\n该方法会返回一个这个块地盘初始化的控件对象集合，例如：\n\n```html\n<div id=\"container\">\n    <button data-ui=\"type:Button;id:defaultBtn;\">默认按钮</button>\n    <span data-ui=\"type:Button;id:springBtn;skin:spring\">创建</span>\n    <div data-ui=\"type:Button;id:springAddBtn;skin:spring-add\">添加</div>\n    <div data-ui=\"type:Button;id:downloadBtn;skin:download\">下载</div>\n    <div data-ui=\"type:Button;id:actBtn;\">改变文字</div>\n</div>\n```\n\n此 container 初始化后就会返回五个控件对象控件的集合。\n\n### 类关系\n\n* ControlCollection\n    * ControlGroup\n* Extension\n* EventTarget\n    * Control\n        * Button\n        * CommandMenu\n        * Crumb\n        * InputControl\n            * BoxGroup\n            * Calendar\n            * CheckBox\n            * RangeCalendar\n            * Region\n            * RichCalendar\n            * Schedule\n            * Select\n            * TextBox\n            * TextLine\n        * Dialog\n        * Label\n        * Frame\n        * Pager\n        * Panel\n            * Form\n            * Overlay\n        * SearchBox\n        * Sidebar\n        * Tab\n        * Table\n        * Tip\n        * TipLayer\n        * Toast\n        * Tree\n        * Validity\n        * Wizard\n    * Layer\n    * Link\n    * MonthView\n* SafeWrapper\n* TreeStrategy\n* ViewContext\n\n### 一些总结\n\n绝大多数控件在源码中其实都有比较详尽的说明了，只要仔细看看注释，再结合相关代码，很快就会用了。不过，在看代码的时候，以下几处务必留意：\n\n* 1、 initOption() 函数，该函数会初始化一些参数，很多都可以通过 `data-ui-xxx` 来设置，也可以通过 set() 方法来设置；\n* 2、 repaint 属性，该属性中存放了重绘相关的配置，留意会造成重绘的属性，这些属性往往也可以用上条所述方式设置；\n* 3、留意控件会触发什么事件，直接在源代码中搜索 `fire(` ，即可快速知道该控件会触发什么事件。\n\n\n","source":"_posts/百度 EFE 前端框架学习笔记（esui）.md","raw":"---\ntitle: 百度 EFE 前端框架学习笔记（esui）\ndate: 2015-06-01\n---\n\n基础点：\n\n### Control.js\n\n控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。\n\n包含如下一些自有属性：\n\n* type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等\n* skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更\n* styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替\n* id ： 控件的 id\n\n<!-- more -->\n\n这些属性（ property ）均可在 html 代码中设置，比如：\n\n```html\n<div data-ui-type=\"Button\"></div>\n```\n\n还有另外一部分自有属性，这些属性不能用于 html 代码设置：\n\n* helper ：控件常用的一些方法组成的一个对象属性\n* children ：子控件数组\n* childrenIndex\n* currentStates\n* domEvents\n* main ： 控件的主元素， HTMLElement 类型\n\n原型（ Control.prototype ）上面有一些对象属性：\n\n* ignoreStates ： 指定在哪些状态下该元素不处理相关的DOM事件\n\n控件的生命周期中，有如下状态：\n\n* NEW ： 在进入构造函数后，控件的状态就是 NEW 了\n* INITED ： 控件完成 options 初始化（ initOptions() ）、视图环境初始化（ initViewContext() ）、扩展初始化（ initExtensions() ）之后状态就是 INITED 了\n* RENDERED ： 控件第一次调用 render() 方法之后，就转变为 RENDERED 了\n* DISPOSED ： 控件处于非 DISPOSED 状态下，调用 destroy() 方法，就变成了 DISPOSED 状态了\n\nControl 上有一个重要的方法 render() ，用于渲染控件，该方法会去调用 repaint() 方法。\n\n另外，Control 上还有一些 DOM 操作的方法，比如 appendTo() 、 insertBefore() 等。\n\nControl 上的 get() 和 set() 很有猫腻。举个例子，如果这样调用 get() 方法： `get('some-title')` ，首先会去检测当前实例上面有没有 `getSomeTitle()` 方法，如果有，则直接调用这个方法，返回这个方法的返回值；如果没有，则直接返回当前对象的 `some-title` 属性。 `set()` 方法也是类似的。\n\nsetProperties() 方法可以用来批量设置属性，它会对一些特殊属性进行处理、控制，比如：\n\n* 只有在渲染以前（就是 `initOptions()` 调用的那次）才允许设置 id 属性\n* 如果要设置 viewContext ，则直接调用 setViewContext() 设置\n* 有些属性要转换成布尔值，比如 disabled 、 hidden\n\nsetProperties() 也会对批量设置的值进行脏检测，如果发现有属性值发生了改变，则会调用 repaint() 方法。脏检测函数是 isPropertyChanged() ， 默认只会用恒等号去判断是否变化，但是可以在子类中覆盖这个方法，实现自己想要的脏检测功能。\n\n### Button.js\n\n按钮控件。主要有这么几种按钮：普通按钮、添加按钮、下载按钮、链接按钮、右上角关闭按钮。\n\n可以对按钮设置皮肤（ data-ui-skin ），内置的皮肤有： spring 、 spring-add 、 download 、 layerClose 、 link 。\n\n可以禁用掉按钮（ data-ui-disabled=\"diabled\" ）。\n\n按钮上 DOM 相关的事件只有 click 。由于按钮是间接继承自 EventTarget ，所以可以使用 on 、 un 等方法处理事件：\n\n```js\n// 给按钮绑定事件处理函数\nsomeButton.on('click', handler);\n\n// 5s 后取消绑定事件绑定\nsetTimeout(function () {\n    someButton.un('click', handler);\n}, 5000);\n\n// 只执行一次的回调函数\nsomeButton.once('click', function () {\n    // only once\n});\n\nfunction handler(event) {\n    // do something\n}\n```\n\n具体按钮 demo 可参看[此处](http://yibuyisheng.github.io/esui-demo/demo/Button.html)。\n\n### Validator\n\n数据验证模块，主要有三个基础类 Validity 、 ValidityState 、 Rule 。\n\nValidityState 表示某个控件的某一条验证规则的状态（是否验证通过），有两个自有属性：\n\n* state ： 验证状态， `true` 为值合法， `false` 为值非法\n* message ： 验证信息，比如说错误提示语\n\nRule 是验证规则基类，是对 InputControl 的值的验证逻辑的抽象。每一个验证规则都包含一个 `check(value, control)` 方法，该方法返回一个 ValidityState 对象以表示验证结果。验证规则必须通过 main.registerRule() 进行注册后才可生效。每一个验证规则包含 `prototype.type` 属性来确定规则的类型。验证规则并不会显式地附加到控件上，而是通过控件自身的属性决定哪些规则生效，当控件本身具有与规则的`type`属性相同的属性时，此规则即会生效，例如：\n\n```js\nvar textbox = main.create('TextBox', { maxLength: 30 });\ntextbox.validate();\n```\n\n由于 `textbox` 上存在 `maxLength` 属性，因此 `MaxLengthRule` 会对其进行验证，此特性可以从 main.createRulesByControl() 方法中看出。\n\nValidity 主要用于存放一系列验证结果（ ValidityState ），如果验证失败，则会触发 InputControl 的 invalid 事件，该事件会带上一个 Validity 对象作为参数。\n\n### InputControl.js\n\n输入控件基类模块，用于表示需要在表单中包含的控件，主要提供 `getRawValue()` 和 `getValue()` 方法供获取值。该类是一个抽象类，不应该直接使用。\n\n需要注意的是，控件其实并不通过严格的继承关系来判断一个控件是否为输入控件，只要 `getCategory()` 返回为 `\"input\"` 、 `\"check\" 或 `\"extend\"` 就认为是输入控件。\n\n相比普通控件的 **禁用 / 启用** ，输入控件共有3种状态：\n\n- 普通状态：可编辑，值随表单提交\n- `disabled` ：禁用状态，此状态下控件不能编辑，同时值不随表单提交\n- `readOnly` ：只读状态，此状态下控件不能编辑，但其值会随表单提交\n\nsetValue() 和 getValue() 分别用于设置输入控件的值和获取输入控件的值。 getRawValue() 和 setRawValue() 用于处理控件原始值，原始值的格式由控件自身决定。这两对处理输入控件值的方法的主要区别是，setValue() 会先调用控件的 parseValue() （子类可重写此方法）方法转换传入的值，然后再调用 setRawValue() 设置到控件上面去， getValue() 也会调用控件的 stringifyValue() （子类可重写此方法）将 getRawValue() 得到的值转换后返回。\n\ngetValidationResult() 方法用于获取此控件数据验证结果。\n\n### BoxGroup.js\n\n选择框组控件的各种使用可参见[此处](http://yibuyisheng.github.io/esui-demo/demo/BoxGroup.html)。\n\n### CheckBox.js\n\n`CheckBox` 控件在初始化时可以提供 `datasource` 属性，该属性用于控件判断一开始是否选中，且这个属性只在初始化时有效，不会保存下来。`datasource`可以是以下类型：\n\n- 数组：此时只要`rawValue`在`datasource`中（使用`==`比较）则选上\n- 其它：只要`rawValue`与此相等（使用`==`比较）则选上\n\n[示例](http://127.0.0.1:8848/demo/CheckBox.html)。\n\n### ControlCollection.js\n\n控件集合，类似 `jQuery` 对象的功能，提供便携的方法来访问和修改一个或多个控件。\n\n`ControlCollection` 提供 Control 的所有**公有**方法，但*没有*任何**保护或私有**方法。\n\n对于方法， `ControlCollection` 采用 **Write all, Read first** 的策略，需要注意的是，类似 setProperties() 的方法虽然有返回值，但被归类于写操作，因此会对所有内部的控件生效，但只返回第一个控件执行的结果。\n\n`ControlCollection` 仅继承 Control 的方法，并不包含任何子类独有方法，因此无法认为集合是一个 InputControl 而执行如下代码：\n\n```js\ncollection.setValue('foo');\n```\n\n此时可以使用通用的 set() 方法来代替：\n\n```js\ncollection.set('value', 'foo');\n```\n\n根据 set() 方法的规则，如果控件存在 `setValue()` 方法，则会进行调用。\n\n### ViewContext.js\n\n视图环境类，一个视图环境是一组控件的集合，不同视图环境中相同 id 的控件的 DOM id 不会重复。\n\n该类的实例包含的主要属性为：\n\n* controls ：该视图环境下所有的控件\n* groups ：视图环境控件分组集合\n* id ：视图环境 id，只读\n\n当前页面所有的视图环境对象都会以`id->对象`的形式保存在私有的 pool 变量中。\n\n### painters.js\n\n渲染器模块，负责 dom 渲染。\n\n可以生成各种各样的渲染器（ painter ）。例如：\n\n* painters.state()：生成一个将属性与控件状态关联的渲染器\n* painters.attribute()：生成一个将控件属性与控件主元素元素的属性关联的渲染器\n* painters.style()：生成一个将控件属性与控件主元素元素的样式关联的渲染器\n* painters.html()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器\n* painters.text()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器\n* painters.delegate()：生成一个将控件属性的变化代理到指定成员的指定方法上\n\n借助于这些方法，可以为某一个控件生成一组渲染器，当该控件发生了变化（样式属性变化等），相应的渲染器就会被调用，从而保证了数据与界面的一致性，形成了单向数据流，同时也比较细腻度地更新指定界面部分，不会出现全局刷新的情况。\n\n### Extension.js\n\n扩展基类，针对控件的扩展。\n\n`Extension` 类为扩展基类，所有扩展类需要继承于 `Extension` 。扩展类需要通过 main.registerExtension 方法，注册扩展类型。注册扩展类型时将自动根据 `prototype.type` 进行类型关联。\n\n一个控件实例可以组合多个`Extension`实例，但一个控件实例对同种类型（即 `type` 相同）的 `Extension` ，只能拥有一份。\n\n从设计上而言， `Extension` 不同于普通脚本对控件的操作，相比 ESUI 从设计理念上不希望普通脚本操作控件的保护属性及内部DOM元素，扩展则对控件拥有**完全开放**的权限，这包含但不限于：\n\n- 注册事件、修改属性等其它逻辑程序可做的行为。\n- 覆盖控件实例上的相应函数，如 `render()` 或 `addChild()` 等。\n- 读取`核心属性`与`关键属性`，包括 `type` 、 `main` 等。\n- 可接触控件内部的 DOM 对象，即可以访问 `main` 及其子树，并对 DOM 做任何操作。\n\n在控件初始化时，会对扩展进行初始化，其基本流程为：\n\n1、 当控件 `init` 之后，会依次对所有关联 `Extension` ，调用 `attachTo()` 方法。一个类型的 `Extension` 仅能在控件实例上附加一次，如果一个控件已经附加了同类型的 `Extension` 实例，则跳过本次 `attachTo` 操作。\n2、 当控件 `dispose` 之前，会依次对所有关联 `Extension` ，调用其 `dispose()` 方法。\n\n有多种方法可以将扩展绑定到具体的控件实例上：\n\n- 在控件创建时绑定\n\n    通过控件构造函数参数 `options.extensions` 可以为控件绑定扩展。\n\n    ```js\n    new TextBox({\n        extensions: [\n            new MyExtension({ ... }),\n            new OtherExtension({ ... })\n        ]\n    });\n    ```\n\n- 在使用HTML生成时绑定\n\n    在HTML中，使用 `data-ui-extension-xxx` 属性注册一个扩展：\n\n    ```html\n    <div id=\"main-panel\" class=\"wrapper\"\n        data-ui-type=\"Panel\"\n        data-ui-extension-command-type=\"Command\"\n        data-ui-extension-command-events=\"click,keypress,keyup\"\n        data-ui-extension-command-use-capture=\"false\"\n    </div>\n    ```\n\n    在HTML中，使用 `data-ui-extension-*-property` 属性添加扩展，其中`*`作为扩展的分组，可以是任何字符串，相同的`*`将作为对同一扩展的定义，必须包含 `data-ui-extension-*-type` 定义扩展的类型，而其它 `data-ui-extension-*-property=\"value\"` 属性则将作为 `options` 参数的属性传递给扩展的构造函数。\n\n- 在实例创建后动态地绑定\n\n    在控件创建后，可以动态创建扩展并在适当的时候绑定至控件。\n\n    ```js\n    var panel = new Label({ text: 'abc' });\n    var delegateDOMEvents = main.createExtension(\n        'Command',\n        {\n            eventTypes: ['click', 'keypress', 'keyup'],\n            useCapture: false\n        }\n    );\n    // 需主动调用attachTo方法\n    delegateDomEvents.attachTo(panel);\n    panel.appendTo(container);\n    ```\n\n- 全局绑定\n\n    调用{@link main#attachExtension}函数可在全局注册一个扩展：\n\n    ```js\n    main.attachExtension('Command', { events: ['click'] });\n    ```\n\n    全局注册的扩展，将会被附加到**所有**控件的实例上。使用 `options` 参数作为 `Extension` 创建时的选项，创建 `Extension` 实例时会对 `options` 做复制处理。\n\n    具体可以参考 extension.Command 作为示例，来学习扩展的编写。\n\n### src/main.js 中的 main.init() 方法\n\n该方法是整个 esui 的入口方法，可以指定当前要使用 esui 的 dom 节点容器，类似于 angular.bootstrap() 或者 React.render()，都是以指定的 dom 元素为根，然后开始渲染这块地盘。具体参数传递可参看文档。\n\n该方法会返回一个这个块地盘初始化的控件对象集合，例如：\n\n```html\n<div id=\"container\">\n    <button data-ui=\"type:Button;id:defaultBtn;\">默认按钮</button>\n    <span data-ui=\"type:Button;id:springBtn;skin:spring\">创建</span>\n    <div data-ui=\"type:Button;id:springAddBtn;skin:spring-add\">添加</div>\n    <div data-ui=\"type:Button;id:downloadBtn;skin:download\">下载</div>\n    <div data-ui=\"type:Button;id:actBtn;\">改变文字</div>\n</div>\n```\n\n此 container 初始化后就会返回五个控件对象控件的集合。\n\n### 类关系\n\n* ControlCollection\n    * ControlGroup\n* Extension\n* EventTarget\n    * Control\n        * Button\n        * CommandMenu\n        * Crumb\n        * InputControl\n            * BoxGroup\n            * Calendar\n            * CheckBox\n            * RangeCalendar\n            * Region\n            * RichCalendar\n            * Schedule\n            * Select\n            * TextBox\n            * TextLine\n        * Dialog\n        * Label\n        * Frame\n        * Pager\n        * Panel\n            * Form\n            * Overlay\n        * SearchBox\n        * Sidebar\n        * Tab\n        * Table\n        * Tip\n        * TipLayer\n        * Toast\n        * Tree\n        * Validity\n        * Wizard\n    * Layer\n    * Link\n    * MonthView\n* SafeWrapper\n* TreeStrategy\n* ViewContext\n\n### 一些总结\n\n绝大多数控件在源码中其实都有比较详尽的说明了，只要仔细看看注释，再结合相关代码，很快就会用了。不过，在看代码的时候，以下几处务必留意：\n\n* 1、 initOption() 函数，该函数会初始化一些参数，很多都可以通过 `data-ui-xxx` 来设置，也可以通过 set() 方法来设置；\n* 2、 repaint 属性，该属性中存放了重绘相关的配置，留意会造成重绘的属性，这些属性往往也可以用上条所述方式设置；\n* 3、留意控件会触发什么事件，直接在源代码中搜索 `fire(` ，即可快速知道该控件会触发什么事件。\n\n\n","slug":"百度 EFE 前端框架学习笔记（esui）","published":1,"updated":"2016-06-09T03:57:30.000Z","_id":"cip6tkneo000mn407rzr2reny","comments":1,"layout":"post","photos":[],"link":"","content":"<p>基础点：</p>\n<h3 id=\"Control-js\"><a href=\"#Control-js\" class=\"headerlink\" title=\"Control.js\"></a>Control.js</h3><p>控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。</p>\n<p>包含如下一些自有属性：</p>\n<ul>\n<li>type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等</li>\n<li>skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更</li>\n<li>styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替</li>\n<li>id ： 控件的 id</li>\n</ul>\n<a id=\"more\"></a>\n<p>这些属性（ property ）均可在 html 代码中设置，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui-type</span>=<span class=\"string\">\"Button\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>还有另外一部分自有属性，这些属性不能用于 html 代码设置：</p>\n<ul>\n<li>helper ：控件常用的一些方法组成的一个对象属性</li>\n<li>children ：子控件数组</li>\n<li>childrenIndex</li>\n<li>currentStates</li>\n<li>domEvents</li>\n<li>main ： 控件的主元素， HTMLElement 类型</li>\n</ul>\n<p>原型（ Control.prototype ）上面有一些对象属性：</p>\n<ul>\n<li>ignoreStates ： 指定在哪些状态下该元素不处理相关的DOM事件</li>\n</ul>\n<p>控件的生命周期中，有如下状态：</p>\n<ul>\n<li>NEW ： 在进入构造函数后，控件的状态就是 NEW 了</li>\n<li>INITED ： 控件完成 options 初始化（ initOptions() ）、视图环境初始化（ initViewContext() ）、扩展初始化（ initExtensions() ）之后状态就是 INITED 了</li>\n<li>RENDERED ： 控件第一次调用 render() 方法之后，就转变为 RENDERED 了</li>\n<li>DISPOSED ： 控件处于非 DISPOSED 状态下，调用 destroy() 方法，就变成了 DISPOSED 状态了</li>\n</ul>\n<p>Control 上有一个重要的方法 render() ，用于渲染控件，该方法会去调用 repaint() 方法。</p>\n<p>另外，Control 上还有一些 DOM 操作的方法，比如 appendTo() 、 insertBefore() 等。</p>\n<p>Control 上的 get() 和 set() 很有猫腻。举个例子，如果这样调用 get() 方法： <code>get(&#39;some-title&#39;)</code> ，首先会去检测当前实例上面有没有 <code>getSomeTitle()</code> 方法，如果有，则直接调用这个方法，返回这个方法的返回值；如果没有，则直接返回当前对象的 <code>some-title</code> 属性。 <code>set()</code> 方法也是类似的。</p>\n<p>setProperties() 方法可以用来批量设置属性，它会对一些特殊属性进行处理、控制，比如：</p>\n<ul>\n<li>只有在渲染以前（就是 <code>initOptions()</code> 调用的那次）才允许设置 id 属性</li>\n<li>如果要设置 viewContext ，则直接调用 setViewContext() 设置</li>\n<li>有些属性要转换成布尔值，比如 disabled 、 hidden</li>\n</ul>\n<p>setProperties() 也会对批量设置的值进行脏检测，如果发现有属性值发生了改变，则会调用 repaint() 方法。脏检测函数是 isPropertyChanged() ， 默认只会用恒等号去判断是否变化，但是可以在子类中覆盖这个方法，实现自己想要的脏检测功能。</p>\n<h3 id=\"Button-js\"><a href=\"#Button-js\" class=\"headerlink\" title=\"Button.js\"></a>Button.js</h3><p>按钮控件。主要有这么几种按钮：普通按钮、添加按钮、下载按钮、链接按钮、右上角关闭按钮。</p>\n<p>可以对按钮设置皮肤（ data-ui-skin ），内置的皮肤有： spring 、 spring-add 、 download 、 layerClose 、 link 。</p>\n<p>可以禁用掉按钮（ data-ui-disabled=”diabled” ）。</p>\n<p>按钮上 DOM 相关的事件只有 click 。由于按钮是间接继承自 EventTarget ，所以可以使用 on 、 un 等方法处理事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给按钮绑定事件处理函数</span></span><br><span class=\"line\">someButton.on(<span class=\"string\">'click'</span>, handler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5s 后取消绑定事件绑定</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    someButton.un(<span class=\"string\">'click'</span>, handler);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只执行一次的回调函数</span></span><br><span class=\"line\">someButton.once(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// only once</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体按钮 demo 可参看<a href=\"http://yibuyisheng.github.io/esui-demo/demo/Button.html\" target=\"_blank\" rel=\"external\">此处</a>。</p>\n<h3 id=\"Validator\"><a href=\"#Validator\" class=\"headerlink\" title=\"Validator\"></a>Validator</h3><p>数据验证模块，主要有三个基础类 Validity 、 ValidityState 、 Rule 。</p>\n<p>ValidityState 表示某个控件的某一条验证规则的状态（是否验证通过），有两个自有属性：</p>\n<ul>\n<li>state ： 验证状态， <code>true</code> 为值合法， <code>false</code> 为值非法</li>\n<li>message ： 验证信息，比如说错误提示语</li>\n</ul>\n<p>Rule 是验证规则基类，是对 InputControl 的值的验证逻辑的抽象。每一个验证规则都包含一个 <code>check(value, control)</code> 方法，该方法返回一个 ValidityState 对象以表示验证结果。验证规则必须通过 main.registerRule() 进行注册后才可生效。每一个验证规则包含 <code>prototype.type</code> 属性来确定规则的类型。验证规则并不会显式地附加到控件上，而是通过控件自身的属性决定哪些规则生效，当控件本身具有与规则的<code>type</code>属性相同的属性时，此规则即会生效，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textbox = main.create(<span class=\"string\">'TextBox'</span>, &#123; maxLength: <span class=\"number\">30</span> &#125;);</span><br><span class=\"line\">textbox.validate();</span><br></pre></td></tr></table></figure>\n<p>由于 <code>textbox</code> 上存在 <code>maxLength</code> 属性，因此 <code>MaxLengthRule</code> 会对其进行验证，此特性可以从 main.createRulesByControl() 方法中看出。</p>\n<p>Validity 主要用于存放一系列验证结果（ ValidityState ），如果验证失败，则会触发 InputControl 的 invalid 事件，该事件会带上一个 Validity 对象作为参数。</p>\n<h3 id=\"InputControl-js\"><a href=\"#InputControl-js\" class=\"headerlink\" title=\"InputControl.js\"></a>InputControl.js</h3><p>输入控件基类模块，用于表示需要在表单中包含的控件，主要提供 <code>getRawValue()</code> 和 <code>getValue()</code> 方法供获取值。该类是一个抽象类，不应该直接使用。</p>\n<p>需要注意的是，控件其实并不通过严格的继承关系来判断一个控件是否为输入控件，只要 <code>getCategory()</code> 返回为 <code>&quot;input&quot;</code> 、 <code>&quot;check&quot; 或</code>“extend”` 就认为是输入控件。</p>\n<p>相比普通控件的 <strong>禁用 / 启用</strong> ，输入控件共有3种状态：</p>\n<ul>\n<li>普通状态：可编辑，值随表单提交</li>\n<li><code>disabled</code> ：禁用状态，此状态下控件不能编辑，同时值不随表单提交</li>\n<li><code>readOnly</code> ：只读状态，此状态下控件不能编辑，但其值会随表单提交</li>\n</ul>\n<p>setValue() 和 getValue() 分别用于设置输入控件的值和获取输入控件的值。 getRawValue() 和 setRawValue() 用于处理控件原始值，原始值的格式由控件自身决定。这两对处理输入控件值的方法的主要区别是，setValue() 会先调用控件的 parseValue() （子类可重写此方法）方法转换传入的值，然后再调用 setRawValue() 设置到控件上面去， getValue() 也会调用控件的 stringifyValue() （子类可重写此方法）将 getRawValue() 得到的值转换后返回。</p>\n<p>getValidationResult() 方法用于获取此控件数据验证结果。</p>\n<h3 id=\"BoxGroup-js\"><a href=\"#BoxGroup-js\" class=\"headerlink\" title=\"BoxGroup.js\"></a>BoxGroup.js</h3><p>选择框组控件的各种使用可参见<a href=\"http://yibuyisheng.github.io/esui-demo/demo/BoxGroup.html\" target=\"_blank\" rel=\"external\">此处</a>。</p>\n<h3 id=\"CheckBox-js\"><a href=\"#CheckBox-js\" class=\"headerlink\" title=\"CheckBox.js\"></a>CheckBox.js</h3><p><code>CheckBox</code> 控件在初始化时可以提供 <code>datasource</code> 属性，该属性用于控件判断一开始是否选中，且这个属性只在初始化时有效，不会保存下来。<code>datasource</code>可以是以下类型：</p>\n<ul>\n<li>数组：此时只要<code>rawValue</code>在<code>datasource</code>中（使用<code>==</code>比较）则选上</li>\n<li>其它：只要<code>rawValue</code>与此相等（使用<code>==</code>比较）则选上</li>\n</ul>\n<p><a href=\"http://127.0.0.1:8848/demo/CheckBox.html\" target=\"_blank\" rel=\"external\">示例</a>。</p>\n<h3 id=\"ControlCollection-js\"><a href=\"#ControlCollection-js\" class=\"headerlink\" title=\"ControlCollection.js\"></a>ControlCollection.js</h3><p>控件集合，类似 <code>jQuery</code> 对象的功能，提供便携的方法来访问和修改一个或多个控件。</p>\n<p><code>ControlCollection</code> 提供 Control 的所有<strong>公有</strong>方法，但<em>没有</em>任何<strong>保护或私有</strong>方法。</p>\n<p>对于方法， <code>ControlCollection</code> 采用 <strong>Write all, Read first</strong> 的策略，需要注意的是，类似 setProperties() 的方法虽然有返回值，但被归类于写操作，因此会对所有内部的控件生效，但只返回第一个控件执行的结果。</p>\n<p><code>ControlCollection</code> 仅继承 Control 的方法，并不包含任何子类独有方法，因此无法认为集合是一个 InputControl 而执行如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection.setValue(<span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></figure>\n<p>此时可以使用通用的 set() 方法来代替：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection.set(<span class=\"string\">'value'</span>, <span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></figure>\n<p>根据 set() 方法的规则，如果控件存在 <code>setValue()</code> 方法，则会进行调用。</p>\n<h3 id=\"ViewContext-js\"><a href=\"#ViewContext-js\" class=\"headerlink\" title=\"ViewContext.js\"></a>ViewContext.js</h3><p>视图环境类，一个视图环境是一组控件的集合，不同视图环境中相同 id 的控件的 DOM id 不会重复。</p>\n<p>该类的实例包含的主要属性为：</p>\n<ul>\n<li>controls ：该视图环境下所有的控件</li>\n<li>groups ：视图环境控件分组集合</li>\n<li>id ：视图环境 id，只读</li>\n</ul>\n<p>当前页面所有的视图环境对象都会以<code>id-&gt;对象</code>的形式保存在私有的 pool 变量中。</p>\n<h3 id=\"painters-js\"><a href=\"#painters-js\" class=\"headerlink\" title=\"painters.js\"></a>painters.js</h3><p>渲染器模块，负责 dom 渲染。</p>\n<p>可以生成各种各样的渲染器（ painter ）。例如：</p>\n<ul>\n<li>painters.state()：生成一个将属性与控件状态关联的渲染器</li>\n<li>painters.attribute()：生成一个将控件属性与控件主元素元素的属性关联的渲染器</li>\n<li>painters.style()：生成一个将控件属性与控件主元素元素的样式关联的渲染器</li>\n<li>painters.html()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器</li>\n<li>painters.text()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器</li>\n<li>painters.delegate()：生成一个将控件属性的变化代理到指定成员的指定方法上</li>\n</ul>\n<p>借助于这些方法，可以为某一个控件生成一组渲染器，当该控件发生了变化（样式属性变化等），相应的渲染器就会被调用，从而保证了数据与界面的一致性，形成了单向数据流，同时也比较细腻度地更新指定界面部分，不会出现全局刷新的情况。</p>\n<h3 id=\"Extension-js\"><a href=\"#Extension-js\" class=\"headerlink\" title=\"Extension.js\"></a>Extension.js</h3><p>扩展基类，针对控件的扩展。</p>\n<p><code>Extension</code> 类为扩展基类，所有扩展类需要继承于 <code>Extension</code> 。扩展类需要通过 main.registerExtension 方法，注册扩展类型。注册扩展类型时将自动根据 <code>prototype.type</code> 进行类型关联。</p>\n<p>一个控件实例可以组合多个<code>Extension</code>实例，但一个控件实例对同种类型（即 <code>type</code> 相同）的 <code>Extension</code> ，只能拥有一份。</p>\n<p>从设计上而言， <code>Extension</code> 不同于普通脚本对控件的操作，相比 ESUI 从设计理念上不希望普通脚本操作控件的保护属性及内部DOM元素，扩展则对控件拥有<strong>完全开放</strong>的权限，这包含但不限于：</p>\n<ul>\n<li>注册事件、修改属性等其它逻辑程序可做的行为。</li>\n<li>覆盖控件实例上的相应函数，如 <code>render()</code> 或 <code>addChild()</code> 等。</li>\n<li>读取<code>核心属性</code>与<code>关键属性</code>，包括 <code>type</code> 、 <code>main</code> 等。</li>\n<li>可接触控件内部的 DOM 对象，即可以访问 <code>main</code> 及其子树，并对 DOM 做任何操作。</li>\n</ul>\n<p>在控件初始化时，会对扩展进行初始化，其基本流程为：</p>\n<p>1、 当控件 <code>init</code> 之后，会依次对所有关联 <code>Extension</code> ，调用 <code>attachTo()</code> 方法。一个类型的 <code>Extension</code> 仅能在控件实例上附加一次，如果一个控件已经附加了同类型的 <code>Extension</code> 实例，则跳过本次 <code>attachTo</code> 操作。<br>2、 当控件 <code>dispose</code> 之前，会依次对所有关联 <code>Extension</code> ，调用其 <code>dispose()</code> 方法。</p>\n<p>有多种方法可以将扩展绑定到具体的控件实例上：</p>\n<ul>\n<li><p>在控件创建时绑定</p>\n<p>  通过控件构造函数参数 <code>options.extensions</code> 可以为控件绑定扩展。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> TextBox(&#123;</span><br><span class=\"line\">    extensions: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyExtension(&#123; ... &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OtherExtension(&#123; ... &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在使用HTML生成时绑定</p>\n<p>  在HTML中，使用 <code>data-ui-extension-xxx</code> 属性注册一个扩展：</p>\n  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=\"main-panel\" class=\"wrapper\"</span><br><span class=\"line\">    data-ui-type=\"Panel\"</span><br><span class=\"line\">    data-ui-extension-command-type=\"Command\"</span><br><span class=\"line\">    data-ui-extension-command-events=\"click,keypress,keyup\"</span><br><span class=\"line\">    data-ui-extension-command-use-capture=\"false\"</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>  在HTML中，使用 <code>data-ui-extension-*-property</code> 属性添加扩展，其中<code>*</code>作为扩展的分组，可以是任何字符串，相同的<code>*</code>将作为对同一扩展的定义，必须包含 <code>data-ui-extension-*-type</code> 定义扩展的类型，而其它 <code>data-ui-extension-*-property=&quot;value&quot;</code> 属性则将作为 <code>options</code> 参数的属性传递给扩展的构造函数。</p>\n</li>\n<li><p>在实例创建后动态地绑定</p>\n<p>  在控件创建后，可以动态创建扩展并在适当的时候绑定至控件。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> panel = <span class=\"keyword\">new</span> Label(&#123; text: <span class=\"string\">'abc'</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delegateDOMEvents = main.createExtension(</span><br><span class=\"line\">    <span class=\"string\">'Command'</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventTypes: [<span class=\"string\">'click'</span>, <span class=\"string\">'keypress'</span>, <span class=\"string\">'keyup'</span>],</span><br><span class=\"line\">        useCapture: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 需主动调用attachTo方法</span></span><br><span class=\"line\">delegateDomEvents.attachTo(panel);</span><br><span class=\"line\">panel.appendTo(container);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>全局绑定</p>\n<p>  调用{@link main#attachExtension}函数可在全局注册一个扩展：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.attachExtension(<span class=\"string\">'Command'</span>, &#123; events: [<span class=\"string\">'click'</span>] &#125;);</span><br></pre></td></tr></table></figure>\n<p>  全局注册的扩展，将会被附加到<strong>所有</strong>控件的实例上。使用 <code>options</code> 参数作为 <code>Extension</code> 创建时的选项，创建 <code>Extension</code> 实例时会对 <code>options</code> 做复制处理。</p>\n<p>  具体可以参考 extension.Command 作为示例，来学习扩展的编写。</p>\n</li>\n</ul>\n<h3 id=\"src-main-js-中的-main-init-方法\"><a href=\"#src-main-js-中的-main-init-方法\" class=\"headerlink\" title=\"src/main.js 中的 main.init() 方法\"></a>src/main.js 中的 main.init() 方法</h3><p>该方法是整个 esui 的入口方法，可以指定当前要使用 esui 的 dom 节点容器，类似于 angular.bootstrap() 或者 React.render()，都是以指定的 dom 元素为根，然后开始渲染这块地盘。具体参数传递可参看文档。</p>\n<p>该方法会返回一个这个块地盘初始化的控件对象集合，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:defaultBtn;\"</span>&gt;</span>默认按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:springBtn;skin:spring\"</span>&gt;</span>创建<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:springAddBtn;skin:spring-add\"</span>&gt;</span>添加<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:downloadBtn;skin:download\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:actBtn;\"</span>&gt;</span>改变文字<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>此 container 初始化后就会返回五个控件对象控件的集合。</p>\n<h3 id=\"类关系\"><a href=\"#类关系\" class=\"headerlink\" title=\"类关系\"></a>类关系</h3><ul>\n<li>ControlCollection<ul>\n<li>ControlGroup</li>\n</ul>\n</li>\n<li>Extension</li>\n<li>EventTarget<ul>\n<li>Control<ul>\n<li>Button</li>\n<li>CommandMenu</li>\n<li>Crumb</li>\n<li>InputControl<ul>\n<li>BoxGroup</li>\n<li>Calendar</li>\n<li>CheckBox</li>\n<li>RangeCalendar</li>\n<li>Region</li>\n<li>RichCalendar</li>\n<li>Schedule</li>\n<li>Select</li>\n<li>TextBox</li>\n<li>TextLine</li>\n</ul>\n</li>\n<li>Dialog</li>\n<li>Label</li>\n<li>Frame</li>\n<li>Pager</li>\n<li>Panel<ul>\n<li>Form</li>\n<li>Overlay</li>\n</ul>\n</li>\n<li>SearchBox</li>\n<li>Sidebar</li>\n<li>Tab</li>\n<li>Table</li>\n<li>Tip</li>\n<li>TipLayer</li>\n<li>Toast</li>\n<li>Tree</li>\n<li>Validity</li>\n<li>Wizard</li>\n</ul>\n</li>\n<li>Layer</li>\n<li>Link</li>\n<li>MonthView</li>\n</ul>\n</li>\n<li>SafeWrapper</li>\n<li>TreeStrategy</li>\n<li>ViewContext</li>\n</ul>\n<h3 id=\"一些总结\"><a href=\"#一些总结\" class=\"headerlink\" title=\"一些总结\"></a>一些总结</h3><p>绝大多数控件在源码中其实都有比较详尽的说明了，只要仔细看看注释，再结合相关代码，很快就会用了。不过，在看代码的时候，以下几处务必留意：</p>\n<ul>\n<li>1、 initOption() 函数，该函数会初始化一些参数，很多都可以通过 <code>data-ui-xxx</code> 来设置，也可以通过 set() 方法来设置；</li>\n<li>2、 repaint 属性，该属性中存放了重绘相关的配置，留意会造成重绘的属性，这些属性往往也可以用上条所述方式设置；</li>\n<li>3、留意控件会触发什么事件，直接在源代码中搜索 <code>fire(</code> ，即可快速知道该控件会触发什么事件。</li>\n</ul>\n","excerpt":"<p>基础点：</p>\n<h3 id=\"Control-js\"><a href=\"#Control-js\" class=\"headerlink\" title=\"Control.js\"></a>Control.js</h3><p>控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。</p>\n<p>包含如下一些自有属性：</p>\n<ul>\n<li>type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等</li>\n<li>skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更</li>\n<li>styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替</li>\n<li>id ： 控件的 id</li>\n</ul>","more":"<p>这些属性（ property ）均可在 html 代码中设置，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui-type</span>=<span class=\"string\">\"Button\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>还有另外一部分自有属性，这些属性不能用于 html 代码设置：</p>\n<ul>\n<li>helper ：控件常用的一些方法组成的一个对象属性</li>\n<li>children ：子控件数组</li>\n<li>childrenIndex</li>\n<li>currentStates</li>\n<li>domEvents</li>\n<li>main ： 控件的主元素， HTMLElement 类型</li>\n</ul>\n<p>原型（ Control.prototype ）上面有一些对象属性：</p>\n<ul>\n<li>ignoreStates ： 指定在哪些状态下该元素不处理相关的DOM事件</li>\n</ul>\n<p>控件的生命周期中，有如下状态：</p>\n<ul>\n<li>NEW ： 在进入构造函数后，控件的状态就是 NEW 了</li>\n<li>INITED ： 控件完成 options 初始化（ initOptions() ）、视图环境初始化（ initViewContext() ）、扩展初始化（ initExtensions() ）之后状态就是 INITED 了</li>\n<li>RENDERED ： 控件第一次调用 render() 方法之后，就转变为 RENDERED 了</li>\n<li>DISPOSED ： 控件处于非 DISPOSED 状态下，调用 destroy() 方法，就变成了 DISPOSED 状态了</li>\n</ul>\n<p>Control 上有一个重要的方法 render() ，用于渲染控件，该方法会去调用 repaint() 方法。</p>\n<p>另外，Control 上还有一些 DOM 操作的方法，比如 appendTo() 、 insertBefore() 等。</p>\n<p>Control 上的 get() 和 set() 很有猫腻。举个例子，如果这样调用 get() 方法： <code>get(&#39;some-title&#39;)</code> ，首先会去检测当前实例上面有没有 <code>getSomeTitle()</code> 方法，如果有，则直接调用这个方法，返回这个方法的返回值；如果没有，则直接返回当前对象的 <code>some-title</code> 属性。 <code>set()</code> 方法也是类似的。</p>\n<p>setProperties() 方法可以用来批量设置属性，它会对一些特殊属性进行处理、控制，比如：</p>\n<ul>\n<li>只有在渲染以前（就是 <code>initOptions()</code> 调用的那次）才允许设置 id 属性</li>\n<li>如果要设置 viewContext ，则直接调用 setViewContext() 设置</li>\n<li>有些属性要转换成布尔值，比如 disabled 、 hidden</li>\n</ul>\n<p>setProperties() 也会对批量设置的值进行脏检测，如果发现有属性值发生了改变，则会调用 repaint() 方法。脏检测函数是 isPropertyChanged() ， 默认只会用恒等号去判断是否变化，但是可以在子类中覆盖这个方法，实现自己想要的脏检测功能。</p>\n<h3 id=\"Button-js\"><a href=\"#Button-js\" class=\"headerlink\" title=\"Button.js\"></a>Button.js</h3><p>按钮控件。主要有这么几种按钮：普通按钮、添加按钮、下载按钮、链接按钮、右上角关闭按钮。</p>\n<p>可以对按钮设置皮肤（ data-ui-skin ），内置的皮肤有： spring 、 spring-add 、 download 、 layerClose 、 link 。</p>\n<p>可以禁用掉按钮（ data-ui-disabled=”diabled” ）。</p>\n<p>按钮上 DOM 相关的事件只有 click 。由于按钮是间接继承自 EventTarget ，所以可以使用 on 、 un 等方法处理事件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给按钮绑定事件处理函数</span></span><br><span class=\"line\">someButton.on(<span class=\"string\">'click'</span>, handler);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 5s 后取消绑定事件绑定</span></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    someButton.un(<span class=\"string\">'click'</span>, handler);</span><br><span class=\"line\">&#125;, <span class=\"number\">5000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 只执行一次的回调函数</span></span><br><span class=\"line\">someButton.once(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// only once</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handler</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体按钮 demo 可参看<a href=\"http://yibuyisheng.github.io/esui-demo/demo/Button.html\">此处</a>。</p>\n<h3 id=\"Validator\"><a href=\"#Validator\" class=\"headerlink\" title=\"Validator\"></a>Validator</h3><p>数据验证模块，主要有三个基础类 Validity 、 ValidityState 、 Rule 。</p>\n<p>ValidityState 表示某个控件的某一条验证规则的状态（是否验证通过），有两个自有属性：</p>\n<ul>\n<li>state ： 验证状态， <code>true</code> 为值合法， <code>false</code> 为值非法</li>\n<li>message ： 验证信息，比如说错误提示语</li>\n</ul>\n<p>Rule 是验证规则基类，是对 InputControl 的值的验证逻辑的抽象。每一个验证规则都包含一个 <code>check(value, control)</code> 方法，该方法返回一个 ValidityState 对象以表示验证结果。验证规则必须通过 main.registerRule() 进行注册后才可生效。每一个验证规则包含 <code>prototype.type</code> 属性来确定规则的类型。验证规则并不会显式地附加到控件上，而是通过控件自身的属性决定哪些规则生效，当控件本身具有与规则的<code>type</code>属性相同的属性时，此规则即会生效，例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> textbox = main.create(<span class=\"string\">'TextBox'</span>, &#123; maxLength: <span class=\"number\">30</span> &#125;);</span><br><span class=\"line\">textbox.validate();</span><br></pre></td></tr></table></figure>\n<p>由于 <code>textbox</code> 上存在 <code>maxLength</code> 属性，因此 <code>MaxLengthRule</code> 会对其进行验证，此特性可以从 main.createRulesByControl() 方法中看出。</p>\n<p>Validity 主要用于存放一系列验证结果（ ValidityState ），如果验证失败，则会触发 InputControl 的 invalid 事件，该事件会带上一个 Validity 对象作为参数。</p>\n<h3 id=\"InputControl-js\"><a href=\"#InputControl-js\" class=\"headerlink\" title=\"InputControl.js\"></a>InputControl.js</h3><p>输入控件基类模块，用于表示需要在表单中包含的控件，主要提供 <code>getRawValue()</code> 和 <code>getValue()</code> 方法供获取值。该类是一个抽象类，不应该直接使用。</p>\n<p>需要注意的是，控件其实并不通过严格的继承关系来判断一个控件是否为输入控件，只要 <code>getCategory()</code> 返回为 <code>&quot;input&quot;</code> 、 <code>&quot;check&quot; 或</code>“extend”` 就认为是输入控件。</p>\n<p>相比普通控件的 <strong>禁用 / 启用</strong> ，输入控件共有3种状态：</p>\n<ul>\n<li>普通状态：可编辑，值随表单提交</li>\n<li><code>disabled</code> ：禁用状态，此状态下控件不能编辑，同时值不随表单提交</li>\n<li><code>readOnly</code> ：只读状态，此状态下控件不能编辑，但其值会随表单提交</li>\n</ul>\n<p>setValue() 和 getValue() 分别用于设置输入控件的值和获取输入控件的值。 getRawValue() 和 setRawValue() 用于处理控件原始值，原始值的格式由控件自身决定。这两对处理输入控件值的方法的主要区别是，setValue() 会先调用控件的 parseValue() （子类可重写此方法）方法转换传入的值，然后再调用 setRawValue() 设置到控件上面去， getValue() 也会调用控件的 stringifyValue() （子类可重写此方法）将 getRawValue() 得到的值转换后返回。</p>\n<p>getValidationResult() 方法用于获取此控件数据验证结果。</p>\n<h3 id=\"BoxGroup-js\"><a href=\"#BoxGroup-js\" class=\"headerlink\" title=\"BoxGroup.js\"></a>BoxGroup.js</h3><p>选择框组控件的各种使用可参见<a href=\"http://yibuyisheng.github.io/esui-demo/demo/BoxGroup.html\">此处</a>。</p>\n<h3 id=\"CheckBox-js\"><a href=\"#CheckBox-js\" class=\"headerlink\" title=\"CheckBox.js\"></a>CheckBox.js</h3><p><code>CheckBox</code> 控件在初始化时可以提供 <code>datasource</code> 属性，该属性用于控件判断一开始是否选中，且这个属性只在初始化时有效，不会保存下来。<code>datasource</code>可以是以下类型：</p>\n<ul>\n<li>数组：此时只要<code>rawValue</code>在<code>datasource</code>中（使用<code>==</code>比较）则选上</li>\n<li>其它：只要<code>rawValue</code>与此相等（使用<code>==</code>比较）则选上</li>\n</ul>\n<p><a href=\"http://127.0.0.1:8848/demo/CheckBox.html\">示例</a>。</p>\n<h3 id=\"ControlCollection-js\"><a href=\"#ControlCollection-js\" class=\"headerlink\" title=\"ControlCollection.js\"></a>ControlCollection.js</h3><p>控件集合，类似 <code>jQuery</code> 对象的功能，提供便携的方法来访问和修改一个或多个控件。</p>\n<p><code>ControlCollection</code> 提供 Control 的所有<strong>公有</strong>方法，但<em>没有</em>任何<strong>保护或私有</strong>方法。</p>\n<p>对于方法， <code>ControlCollection</code> 采用 <strong>Write all, Read first</strong> 的策略，需要注意的是，类似 setProperties() 的方法虽然有返回值，但被归类于写操作，因此会对所有内部的控件生效，但只返回第一个控件执行的结果。</p>\n<p><code>ControlCollection</code> 仅继承 Control 的方法，并不包含任何子类独有方法，因此无法认为集合是一个 InputControl 而执行如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection.setValue(<span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></figure>\n<p>此时可以使用通用的 set() 方法来代替：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">collection.set(<span class=\"string\">'value'</span>, <span class=\"string\">'foo'</span>);</span><br></pre></td></tr></table></figure>\n<p>根据 set() 方法的规则，如果控件存在 <code>setValue()</code> 方法，则会进行调用。</p>\n<h3 id=\"ViewContext-js\"><a href=\"#ViewContext-js\" class=\"headerlink\" title=\"ViewContext.js\"></a>ViewContext.js</h3><p>视图环境类，一个视图环境是一组控件的集合，不同视图环境中相同 id 的控件的 DOM id 不会重复。</p>\n<p>该类的实例包含的主要属性为：</p>\n<ul>\n<li>controls ：该视图环境下所有的控件</li>\n<li>groups ：视图环境控件分组集合</li>\n<li>id ：视图环境 id，只读</li>\n</ul>\n<p>当前页面所有的视图环境对象都会以<code>id-&gt;对象</code>的形式保存在私有的 pool 变量中。</p>\n<h3 id=\"painters-js\"><a href=\"#painters-js\" class=\"headerlink\" title=\"painters.js\"></a>painters.js</h3><p>渲染器模块，负责 dom 渲染。</p>\n<p>可以生成各种各样的渲染器（ painter ）。例如：</p>\n<ul>\n<li>painters.state()：生成一个将属性与控件状态关联的渲染器</li>\n<li>painters.attribute()：生成一个将控件属性与控件主元素元素的属性关联的渲染器</li>\n<li>painters.style()：生成一个将控件属性与控件主元素元素的样式关联的渲染器</li>\n<li>painters.html()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器</li>\n<li>painters.text()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器</li>\n<li>painters.delegate()：生成一个将控件属性的变化代理到指定成员的指定方法上</li>\n</ul>\n<p>借助于这些方法，可以为某一个控件生成一组渲染器，当该控件发生了变化（样式属性变化等），相应的渲染器就会被调用，从而保证了数据与界面的一致性，形成了单向数据流，同时也比较细腻度地更新指定界面部分，不会出现全局刷新的情况。</p>\n<h3 id=\"Extension-js\"><a href=\"#Extension-js\" class=\"headerlink\" title=\"Extension.js\"></a>Extension.js</h3><p>扩展基类，针对控件的扩展。</p>\n<p><code>Extension</code> 类为扩展基类，所有扩展类需要继承于 <code>Extension</code> 。扩展类需要通过 main.registerExtension 方法，注册扩展类型。注册扩展类型时将自动根据 <code>prototype.type</code> 进行类型关联。</p>\n<p>一个控件实例可以组合多个<code>Extension</code>实例，但一个控件实例对同种类型（即 <code>type</code> 相同）的 <code>Extension</code> ，只能拥有一份。</p>\n<p>从设计上而言， <code>Extension</code> 不同于普通脚本对控件的操作，相比 ESUI 从设计理念上不希望普通脚本操作控件的保护属性及内部DOM元素，扩展则对控件拥有<strong>完全开放</strong>的权限，这包含但不限于：</p>\n<ul>\n<li>注册事件、修改属性等其它逻辑程序可做的行为。</li>\n<li>覆盖控件实例上的相应函数，如 <code>render()</code> 或 <code>addChild()</code> 等。</li>\n<li>读取<code>核心属性</code>与<code>关键属性</code>，包括 <code>type</code> 、 <code>main</code> 等。</li>\n<li>可接触控件内部的 DOM 对象，即可以访问 <code>main</code> 及其子树，并对 DOM 做任何操作。</li>\n</ul>\n<p>在控件初始化时，会对扩展进行初始化，其基本流程为：</p>\n<p>1、 当控件 <code>init</code> 之后，会依次对所有关联 <code>Extension</code> ，调用 <code>attachTo()</code> 方法。一个类型的 <code>Extension</code> 仅能在控件实例上附加一次，如果一个控件已经附加了同类型的 <code>Extension</code> 实例，则跳过本次 <code>attachTo</code> 操作。<br>2、 当控件 <code>dispose</code> 之前，会依次对所有关联 <code>Extension</code> ，调用其 <code>dispose()</code> 方法。</p>\n<p>有多种方法可以将扩展绑定到具体的控件实例上：</p>\n<ul>\n<li><p>在控件创建时绑定</p>\n<p>  通过控件构造函数参数 <code>options.extensions</code> 可以为控件绑定扩展。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> TextBox(&#123;</span><br><span class=\"line\">    extensions: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> MyExtension(&#123; ... &#125;),</span><br><span class=\"line\">        <span class=\"keyword\">new</span> OtherExtension(&#123; ... &#125;)</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在使用HTML生成时绑定</p>\n<p>  在HTML中，使用 <code>data-ui-extension-xxx</code> 属性注册一个扩展：</p>\n  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=\"main-panel\" class=\"wrapper\"</span><br><span class=\"line\">    data-ui-type=\"Panel\"</span><br><span class=\"line\">    data-ui-extension-command-type=\"Command\"</span><br><span class=\"line\">    data-ui-extension-command-events=\"click,keypress,keyup\"</span><br><span class=\"line\">    data-ui-extension-command-use-capture=\"false\"</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p>  在HTML中，使用 <code>data-ui-extension-*-property</code> 属性添加扩展，其中<code>*</code>作为扩展的分组，可以是任何字符串，相同的<code>*</code>将作为对同一扩展的定义，必须包含 <code>data-ui-extension-*-type</code> 定义扩展的类型，而其它 <code>data-ui-extension-*-property=&quot;value&quot;</code> 属性则将作为 <code>options</code> 参数的属性传递给扩展的构造函数。</p>\n</li>\n<li><p>在实例创建后动态地绑定</p>\n<p>  在控件创建后，可以动态创建扩展并在适当的时候绑定至控件。</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> panel = <span class=\"keyword\">new</span> Label(&#123; text: <span class=\"string\">'abc'</span> &#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> delegateDOMEvents = main.createExtension(</span><br><span class=\"line\">    <span class=\"string\">'Command'</span>,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        eventTypes: [<span class=\"string\">'click'</span>, <span class=\"string\">'keypress'</span>, <span class=\"string\">'keyup'</span>],</span><br><span class=\"line\">        useCapture: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">// 需主动调用attachTo方法</span></span><br><span class=\"line\">delegateDomEvents.attachTo(panel);</span><br><span class=\"line\">panel.appendTo(container);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>全局绑定</p>\n<p>  调用{@link main#attachExtension}函数可在全局注册一个扩展：</p>\n  <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">main.attachExtension(<span class=\"string\">'Command'</span>, &#123; events: [<span class=\"string\">'click'</span>] &#125;);</span><br></pre></td></tr></table></figure>\n<p>  全局注册的扩展，将会被附加到<strong>所有</strong>控件的实例上。使用 <code>options</code> 参数作为 <code>Extension</code> 创建时的选项，创建 <code>Extension</code> 实例时会对 <code>options</code> 做复制处理。</p>\n<p>  具体可以参考 extension.Command 作为示例，来学习扩展的编写。</p>\n</li>\n</ul>\n<h3 id=\"src-main-js-中的-main-init-方法\"><a href=\"#src-main-js-中的-main-init-方法\" class=\"headerlink\" title=\"src/main.js 中的 main.init() 方法\"></a>src/main.js 中的 main.init() 方法</h3><p>该方法是整个 esui 的入口方法，可以指定当前要使用 esui 的 dom 节点容器，类似于 angular.bootstrap() 或者 React.render()，都是以指定的 dom 元素为根，然后开始渲染这块地盘。具体参数传递可参看文档。</p>\n<p>该方法会返回一个这个块地盘初始化的控件对象集合，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:defaultBtn;\"</span>&gt;</span>默认按钮<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:springBtn;skin:spring\"</span>&gt;</span>创建<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:springAddBtn;skin:spring-add\"</span>&gt;</span>添加<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:downloadBtn;skin:download\"</span>&gt;</span>下载<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-ui</span>=<span class=\"string\">\"type:Button;id:actBtn;\"</span>&gt;</span>改变文字<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>此 container 初始化后就会返回五个控件对象控件的集合。</p>\n<h3 id=\"类关系\"><a href=\"#类关系\" class=\"headerlink\" title=\"类关系\"></a>类关系</h3><ul>\n<li>ControlCollection<ul>\n<li>ControlGroup</li>\n</ul>\n</li>\n<li>Extension</li>\n<li>EventTarget<ul>\n<li>Control<ul>\n<li>Button</li>\n<li>CommandMenu</li>\n<li>Crumb</li>\n<li>InputControl<ul>\n<li>BoxGroup</li>\n<li>Calendar</li>\n<li>CheckBox</li>\n<li>RangeCalendar</li>\n<li>Region</li>\n<li>RichCalendar</li>\n<li>Schedule</li>\n<li>Select</li>\n<li>TextBox</li>\n<li>TextLine</li>\n</ul>\n</li>\n<li>Dialog</li>\n<li>Label</li>\n<li>Frame</li>\n<li>Pager</li>\n<li>Panel<ul>\n<li>Form</li>\n<li>Overlay</li>\n</ul>\n</li>\n<li>SearchBox</li>\n<li>Sidebar</li>\n<li>Tab</li>\n<li>Table</li>\n<li>Tip</li>\n<li>TipLayer</li>\n<li>Toast</li>\n<li>Tree</li>\n<li>Validity</li>\n<li>Wizard</li>\n</ul>\n</li>\n<li>Layer</li>\n<li>Link</li>\n<li>MonthView</li>\n</ul>\n</li>\n<li>SafeWrapper</li>\n<li>TreeStrategy</li>\n<li>ViewContext</li>\n</ul>\n<h3 id=\"一些总结\"><a href=\"#一些总结\" class=\"headerlink\" title=\"一些总结\"></a>一些总结</h3><p>绝大多数控件在源码中其实都有比较详尽的说明了，只要仔细看看注释，再结合相关代码，很快就会用了。不过，在看代码的时候，以下几处务必留意：</p>\n<ul>\n<li>1、 initOption() 函数，该函数会初始化一些参数，很多都可以通过 <code>data-ui-xxx</code> 来设置，也可以通过 set() 方法来设置；</li>\n<li>2、 repaint 属性，该属性中存放了重绘相关的配置，留意会造成重绘的属性，这些属性往往也可以用上条所述方式设置；</li>\n<li>3、留意控件会触发什么事件，直接在源代码中搜索 <code>fire(</code> ，即可快速知道该控件会触发什么事件。</li>\n</ul>"},{"title":"记一次坑爹的对接经历","date":"2015-05-06T16:00:00.000Z","_content":"\n事情是这样的：\n\n后端提供了一个数据接口 `/account/my/address/` 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。\n<!-- more -->\n\n在前端请求这个地方，由于做的是移动端应用，果断采用了手写 xhr 请求，大致接口请求代码如下：\n\n```js\nfunction encodeParams(params) {\n    var paramsStr = [];\n    for (var k in params) {\n        paramsStr.push(k + '=' + params[k]);\n    }\n    return paramsStr.join('&');\n}\n\nfunction post(url, params) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', url);\n        xhr.onload = function() { resolve(xhr.response); };\n        xhr.onerror = function() { reject(xhr.response); };\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(encodeParams(params));\n    });\n}\n\npost('/account/my/address/', {/*参数*/})\n    .then(function(response) {\n        // some code\n    });\n```\n\n\n代码写好，拿到 chrome 中一测，出现一个似乎像是请求没发出去的错误：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/1.jpg?raw=true)\n\n对于当时不知道 chrome://net-internals/ 这个强大工具的我来说，这种错误简直就是一个莫名其妙的东西，很难搞。\n\n于是仔细看一眼 request header ，发现没有 `Content-Length` ！这是怎么回事？为什么浏览器没计算出来 `Content-Length` ？很不可思议！\n\n于是，尝试改变一下请求 body 的编码方式，将上述 post 函数改成这样：\n\n```js\nfunction createFormData(params) {\n    var fd = new FormData();\n    for (var k in params) {\n        fd.append(k, params[k]);\n    }\n    return fd;\n}\n\nfunction post(url, params) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', url);\n        xhr.onload = function() { resolve(xhr.response); };\n        xhr.onerror = function() { reject(xhr.response); };\n        xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n        xhr.send(createFormData(params));\n    });\n}\n```\n\n再测，出现这样的错：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/2.jpg?raw=true)\n\n仍然没有 `Content-Length` ，错误依旧，简直令人发指！\n\n于是重新审视当前的开发模式，整个结构是这样的：我在本地开发前端静态部分，需要数据的时候通过 xhr 请求到后端去请求，为了避免我本地开发的时候还要启动一个后端服务器程序，于是让后端的同学将后端代码部署在一个公网的服务器上，这样我就可以通过代理或者 CORS 的方式来请求相应的接口了。\n\n所以此时此刻，有点怀疑是不是这种模式引发的问题，但是再一想，其它很多获取数据提交数据都是这种模式啊，为啥就正常呢！所以这种怀疑被打消。\n\nchrome 的开发者工具提供的信息太有限，实在想不出来是什么问题，于是到 QQ 群求助网友，其中一位网页给出了这个： chrome://net-internals/ ，抱着试一试的心态，打开，观察，哇咔咔，好牛逼，请求的各个过程尽收眼底！其中我找到了我的 POST 请求：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/3.jpg?raw=true)\n\n嗯，看来请求还是被正常发送出去了的。再往下看，发现了这个：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/4.jpg?raw=true)\n\n`ERR_UNEXPECTED_PROXY_AUTH` 映入眼帘，代理需要认证？啥玩意儿？然后再看到一个 `Server: nginx/1.4.6 (Ubuntu)` ，仔细想想，为毛 nginx 会说代理认证错误！抓狂，去找后端人员，后端人员果断说不可能是 nginx 有问题！\n\n于是，再次崩溃， google 吧！于是尝试各种关键字搜索： `ERR_UNEXPECTED_PROXY_AUTH` 、 `net_error = -323` ...\n\n搜索的时候，出现了一条关于 http code 407 的记录，点进去一看，惊呆了， 407 的含义如下：\n\n> Proxy Authentication Required\n\n需要代理授权！再看看上面的那张图，后端返回的 http code 果然是407，于是找到后端人员，问他可能会返回407吗？答案是 yes ！（我“怒发冲冠”，于是后端同学，卒）\n\n#### 总结\n\n这次问题解决总结下来有这么几个点，以后要注意：\n\n* 1、在 RESTful 开发中，一定要对状态码足够敏感；\n* 2、好好使用 chrome://net-internals/ ，确实挺强大；\n* 3、chrome 出现上述类似错误的时候（407、请求未成功发送出去等等），很可能不显示完整的请求头，不显示响应信息（因为按照语义，此时根本无响应信息可显示）。\n\n\n","source":"_posts/记一次坑爹的对接经历.md","raw":"---\ntitle: 记一次坑爹的对接经历\ndate: 2015-05-07\n---\n\n事情是这样的：\n\n后端提供了一个数据接口 `/account/my/address/` 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。\n<!-- more -->\n\n在前端请求这个地方，由于做的是移动端应用，果断采用了手写 xhr 请求，大致接口请求代码如下：\n\n```js\nfunction encodeParams(params) {\n    var paramsStr = [];\n    for (var k in params) {\n        paramsStr.push(k + '=' + params[k]);\n    }\n    return paramsStr.join('&');\n}\n\nfunction post(url, params) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', url);\n        xhr.onload = function() { resolve(xhr.response); };\n        xhr.onerror = function() { reject(xhr.response); };\n        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        xhr.send(encodeParams(params));\n    });\n}\n\npost('/account/my/address/', {/*参数*/})\n    .then(function(response) {\n        // some code\n    });\n```\n\n\n代码写好，拿到 chrome 中一测，出现一个似乎像是请求没发出去的错误：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/1.jpg?raw=true)\n\n对于当时不知道 chrome://net-internals/ 这个强大工具的我来说，这种错误简直就是一个莫名其妙的东西，很难搞。\n\n于是仔细看一眼 request header ，发现没有 `Content-Length` ！这是怎么回事？为什么浏览器没计算出来 `Content-Length` ？很不可思议！\n\n于是，尝试改变一下请求 body 的编码方式，将上述 post 函数改成这样：\n\n```js\nfunction createFormData(params) {\n    var fd = new FormData();\n    for (var k in params) {\n        fd.append(k, params[k]);\n    }\n    return fd;\n}\n\nfunction post(url, params) {\n    return new Promise(function(resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('POST', url);\n        xhr.onload = function() { resolve(xhr.response); };\n        xhr.onerror = function() { reject(xhr.response); };\n        xhr.setRequestHeader('Content-Type', 'multipart/form-data');\n        xhr.send(createFormData(params));\n    });\n}\n```\n\n再测，出现这样的错：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/2.jpg?raw=true)\n\n仍然没有 `Content-Length` ，错误依旧，简直令人发指！\n\n于是重新审视当前的开发模式，整个结构是这样的：我在本地开发前端静态部分，需要数据的时候通过 xhr 请求到后端去请求，为了避免我本地开发的时候还要启动一个后端服务器程序，于是让后端的同学将后端代码部署在一个公网的服务器上，这样我就可以通过代理或者 CORS 的方式来请求相应的接口了。\n\n所以此时此刻，有点怀疑是不是这种模式引发的问题，但是再一想，其它很多获取数据提交数据都是这种模式啊，为啥就正常呢！所以这种怀疑被打消。\n\nchrome 的开发者工具提供的信息太有限，实在想不出来是什么问题，于是到 QQ 群求助网友，其中一位网页给出了这个： chrome://net-internals/ ，抱着试一试的心态，打开，观察，哇咔咔，好牛逼，请求的各个过程尽收眼底！其中我找到了我的 POST 请求：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/3.jpg?raw=true)\n\n嗯，看来请求还是被正常发送出去了的。再往下看，发现了这个：\n\n![](https://github.com/yibuyisheng/blogs/blob/master/imgs/4.jpg?raw=true)\n\n`ERR_UNEXPECTED_PROXY_AUTH` 映入眼帘，代理需要认证？啥玩意儿？然后再看到一个 `Server: nginx/1.4.6 (Ubuntu)` ，仔细想想，为毛 nginx 会说代理认证错误！抓狂，去找后端人员，后端人员果断说不可能是 nginx 有问题！\n\n于是，再次崩溃， google 吧！于是尝试各种关键字搜索： `ERR_UNEXPECTED_PROXY_AUTH` 、 `net_error = -323` ...\n\n搜索的时候，出现了一条关于 http code 407 的记录，点进去一看，惊呆了， 407 的含义如下：\n\n> Proxy Authentication Required\n\n需要代理授权！再看看上面的那张图，后端返回的 http code 果然是407，于是找到后端人员，问他可能会返回407吗？答案是 yes ！（我“怒发冲冠”，于是后端同学，卒）\n\n#### 总结\n\n这次问题解决总结下来有这么几个点，以后要注意：\n\n* 1、在 RESTful 开发中，一定要对状态码足够敏感；\n* 2、好好使用 chrome://net-internals/ ，确实挺强大；\n* 3、chrome 出现上述类似错误的时候（407、请求未成功发送出去等等），很可能不显示完整的请求头，不显示响应信息（因为按照语义，此时根本无响应信息可显示）。\n\n\n","slug":"记一次坑爹的对接经历","published":1,"updated":"2016-06-08T09:53:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cip6tknep000nn4079h0gww5o","content":"<p>事情是这样的：</p>\n<p>后端提供了一个数据接口 <code>/account/my/address/</code> 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。<br><a id=\"more\"></a></p>\n<p>在前端请求这个地方，由于做的是移动端应用，果断采用了手写 xhr 请求，大致接口请求代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encodeParams</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> paramsStr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">        paramsStr.push(k + <span class=\"string\">'='</span> + params[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> paramsStr.join(<span class=\"string\">'&amp;'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'POST'</span>, url);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>);</span><br><span class=\"line\">        xhr.send(encodeParams(params));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">post(<span class=\"string\">'/account/my/address/'</span>, &#123;<span class=\"comment\">/*参数*/</span>&#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>代码写好，拿到 chrome 中一测，出现一个似乎像是请求没发出去的错误：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/1.jpg?raw=true\" alt=\"\"></p>\n<p>对于当时不知道 chrome://net-internals/ 这个强大工具的我来说，这种错误简直就是一个莫名其妙的东西，很难搞。</p>\n<p>于是仔细看一眼 request header ，发现没有 <code>Content-Length</code> ！这是怎么回事？为什么浏览器没计算出来 <code>Content-Length</code> ？很不可思议！</p>\n<p>于是，尝试改变一下请求 body 的编码方式，将上述 post 函数改成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFormData</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fd = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">        fd.append(k, params[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'POST'</span>, url);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'multipart/form-data'</span>);</span><br><span class=\"line\">        xhr.send(createFormData(params));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再测，出现这样的错：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/2.jpg?raw=true\" alt=\"\"></p>\n<p>仍然没有 <code>Content-Length</code> ，错误依旧，简直令人发指！</p>\n<p>于是重新审视当前的开发模式，整个结构是这样的：我在本地开发前端静态部分，需要数据的时候通过 xhr 请求到后端去请求，为了避免我本地开发的时候还要启动一个后端服务器程序，于是让后端的同学将后端代码部署在一个公网的服务器上，这样我就可以通过代理或者 CORS 的方式来请求相应的接口了。</p>\n<p>所以此时此刻，有点怀疑是不是这种模式引发的问题，但是再一想，其它很多获取数据提交数据都是这种模式啊，为啥就正常呢！所以这种怀疑被打消。</p>\n<p>chrome 的开发者工具提供的信息太有限，实在想不出来是什么问题，于是到 QQ 群求助网友，其中一位网页给出了这个： chrome://net-internals/ ，抱着试一试的心态，打开，观察，哇咔咔，好牛逼，请求的各个过程尽收眼底！其中我找到了我的 POST 请求：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/3.jpg?raw=true\" alt=\"\"></p>\n<p>嗯，看来请求还是被正常发送出去了的。再往下看，发现了这个：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/4.jpg?raw=true\" alt=\"\"></p>\n<p><code>ERR_UNEXPECTED_PROXY_AUTH</code> 映入眼帘，代理需要认证？啥玩意儿？然后再看到一个 <code>Server: nginx/1.4.6 (Ubuntu)</code> ，仔细想想，为毛 nginx 会说代理认证错误！抓狂，去找后端人员，后端人员果断说不可能是 nginx 有问题！</p>\n<p>于是，再次崩溃， google 吧！于是尝试各种关键字搜索： <code>ERR_UNEXPECTED_PROXY_AUTH</code> 、 <code>net_error = -323</code> …</p>\n<p>搜索的时候，出现了一条关于 http code 407 的记录，点进去一看，惊呆了， 407 的含义如下：</p>\n<blockquote>\n<p>Proxy Authentication Required</p>\n</blockquote>\n<p>需要代理授权！再看看上面的那张图，后端返回的 http code 果然是407，于是找到后端人员，问他可能会返回407吗？答案是 yes ！（我“怒发冲冠”，于是后端同学，卒）</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这次问题解决总结下来有这么几个点，以后要注意：</p>\n<ul>\n<li>1、在 RESTful 开发中，一定要对状态码足够敏感；</li>\n<li>2、好好使用 chrome://net-internals/ ，确实挺强大；</li>\n<li>3、chrome 出现上述类似错误的时候（407、请求未成功发送出去等等），很可能不显示完整的请求头，不显示响应信息（因为按照语义，此时根本无响应信息可显示）。</li>\n</ul>\n","excerpt":"<p>事情是这样的：</p>\n<p>后端提供了一个数据接口 <code>/account/my/address/</code> 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。<br>","more":"</p>\n<p>在前端请求这个地方，由于做的是移动端应用，果断采用了手写 xhr 请求，大致接口请求代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encodeParams</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> paramsStr = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">        paramsStr.push(k + <span class=\"string\">'='</span> + params[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> paramsStr.join(<span class=\"string\">'&amp;'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'POST'</span>, url);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'application/x-www-form-urlencoded'</span>);</span><br><span class=\"line\">        xhr.send(encodeParams(params));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">post(<span class=\"string\">'/account/my/address/'</span>, &#123;<span class=\"comment\">/*参数*/</span>&#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// some code</span></span><br><span class=\"line\">    &#125;);</span><br></pre></td></tr></table></figure>\n<p>代码写好，拿到 chrome 中一测，出现一个似乎像是请求没发出去的错误：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/1.jpg?raw=true\" alt=\"\"></p>\n<p>对于当时不知道 chrome://net-internals/ 这个强大工具的我来说，这种错误简直就是一个莫名其妙的东西，很难搞。</p>\n<p>于是仔细看一眼 request header ，发现没有 <code>Content-Length</code> ！这是怎么回事？为什么浏览器没计算出来 <code>Content-Length</code> ？很不可思议！</p>\n<p>于是，尝试改变一下请求 body 的编码方式，将上述 post 函数改成这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createFormData</span>(<span class=\"params\">params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> fd = <span class=\"keyword\">new</span> FormData();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> params) &#123;</span><br><span class=\"line\">        fd.append(k, params[k]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">post</span>(<span class=\"params\">url, params</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        xhr.open(<span class=\"string\">'POST'</span>, url);</span><br><span class=\"line\">        xhr.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; resolve(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; reject(xhr.response); &#125;;</span><br><span class=\"line\">        xhr.setRequestHeader(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'multipart/form-data'</span>);</span><br><span class=\"line\">        xhr.send(createFormData(params));</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>再测，出现这样的错：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/2.jpg?raw=true\" alt=\"\"></p>\n<p>仍然没有 <code>Content-Length</code> ，错误依旧，简直令人发指！</p>\n<p>于是重新审视当前的开发模式，整个结构是这样的：我在本地开发前端静态部分，需要数据的时候通过 xhr 请求到后端去请求，为了避免我本地开发的时候还要启动一个后端服务器程序，于是让后端的同学将后端代码部署在一个公网的服务器上，这样我就可以通过代理或者 CORS 的方式来请求相应的接口了。</p>\n<p>所以此时此刻，有点怀疑是不是这种模式引发的问题，但是再一想，其它很多获取数据提交数据都是这种模式啊，为啥就正常呢！所以这种怀疑被打消。</p>\n<p>chrome 的开发者工具提供的信息太有限，实在想不出来是什么问题，于是到 QQ 群求助网友，其中一位网页给出了这个： chrome://net-internals/ ，抱着试一试的心态，打开，观察，哇咔咔，好牛逼，请求的各个过程尽收眼底！其中我找到了我的 POST 请求：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/3.jpg?raw=true\" alt=\"\"></p>\n<p>嗯，看来请求还是被正常发送出去了的。再往下看，发现了这个：</p>\n<p><img src=\"https://github.com/yibuyisheng/blogs/blob/master/imgs/4.jpg?raw=true\" alt=\"\"></p>\n<p><code>ERR_UNEXPECTED_PROXY_AUTH</code> 映入眼帘，代理需要认证？啥玩意儿？然后再看到一个 <code>Server: nginx/1.4.6 (Ubuntu)</code> ，仔细想想，为毛 nginx 会说代理认证错误！抓狂，去找后端人员，后端人员果断说不可能是 nginx 有问题！</p>\n<p>于是，再次崩溃， google 吧！于是尝试各种关键字搜索： <code>ERR_UNEXPECTED_PROXY_AUTH</code> 、 <code>net_error = -323</code> …</p>\n<p>搜索的时候，出现了一条关于 http code 407 的记录，点进去一看，惊呆了， 407 的含义如下：</p>\n<blockquote>\n<p>Proxy Authentication Required</p>\n</blockquote>\n<p>需要代理授权！再看看上面的那张图，后端返回的 http code 果然是407，于是找到后端人员，问他可能会返回407吗？答案是 yes ！（我“怒发冲冠”，于是后端同学，卒）</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>这次问题解决总结下来有这么几个点，以后要注意：</p>\n<ul>\n<li>1、在 RESTful 开发中，一定要对状态码足够敏感；</li>\n<li>2、好好使用 chrome://net-internals/ ，确实挺强大；</li>\n<li>3、chrome 出现上述类似错误的时候（407、请求未成功发送出去等等），很可能不显示完整的请求头，不显示响应信息（因为按照语义，此时根本无响应信息可显示）。</li>\n</ul>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cip6tkndw000an407g6fzxnz4","tag_id":"cip6tkne0000cn407tg9mfffk","_id":"cip6tknel000jn407bwsj4ruw"},{"post_id":"cip6tkndw000an407g6fzxnz4","tag_id":"cip6tkneg000fn407shdyqpt3","_id":"cip6tknen000ln407a03m928y"}],"Tag":[{"name":"oracle","_id":"cip6tkne0000cn407tg9mfffk"},{"name":"数据库","_id":"cip6tkneg000fn407shdyqpt3"}]}}