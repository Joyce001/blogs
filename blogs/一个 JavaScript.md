<!-- config.time: 2015-10-05 17:04 -->
# 一个 JavaScript

ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。

那么，什么是“版本化”？什么又是“一个 JavaScript”呢？

## 版本化

一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。

如果代码库升级到新的语言版本，就有两种处理方式。

第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。

第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：

```
Content-Type: application/ecmascript;version=6
```

也可以利用 `<script>` 标签的 `type` 属性来标记：

```html
<script type="application/ecmascript;version=6">
    ···
</script>
```

也可以在代码内部标记版本（类似于 `'use strict'` ，放在 JavaScript 文件第一行）：

```js
use version 6;
```

这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。

一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：

* 引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。
* 开发者需要记住版本之间的不同点。
* 代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。

因此，应该避免版本化，尤其是 JavaScript 和 web 。

## 一个 JavaScript

既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？

采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。

我们可以增加新的特性，使已有的特性更加强大。

这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“[一个 JavaScript ](http://exploringjs.com/es6/ch_one-javascript.html#one-js_1)”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。

“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 `let` 就是这样干的，它用于声明块级变量，是 `var` 的改进版。但是它并没有替换掉 `var` ，只是作为更好的方案与 `var` 并存。

将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：

* `let` 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：

```js
let[x] = arr;
```

调查发现， web 上没人会在非严格模式下这样使用 `let` 变量，这就使得 TC39 能够将 `let` 引入非严格模式。

## 严格模式和 ES6

ECMAScript 5 引入严格模式来清理语言，在文件或者函数的第一行放入下面的内容就可以开启严格模式：

```js
'use strict';
```


